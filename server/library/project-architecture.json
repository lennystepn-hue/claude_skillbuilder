{
  "id": "project-architecture",
  "name": "System Architecture",
  "description": "Design system architecture including component diagrams, microservices design, database architecture, API design patterns, scalability planning, and architectural decision-making",
  "category": "Project",
  "content": "---\nname: System Architecture\ndescription: Design system architecture including component diagrams, microservices design, database architecture, API design patterns, scalability planning, and architectural decision-making\ncategory: Project\n---\n\n# System Architecture\n\n## Overview\n\nThis skill guides the design of robust, scalable system architectures. It covers architectural patterns, component design, technology selection, scalability planning, and creating clear architectural documentation with diagrams and design rationale.\n\n## Activation\n\nThis skill activates when you need to:\n- Design system architecture for a new application\n- Plan microservices architecture\n- Create architectural diagrams (C4, UML, etc.)\n- Design database architecture and data flow\n- Plan API architecture and integration patterns\n- Evaluate architectural trade-offs\n- Document architectural decisions\n- Plan for scalability and performance\n\n## Instructions\n\nWhen activated, this skill will:\n\n1. **Understand Requirements**\n   - Functional requirements\n   - Non-functional requirements (performance, scalability, security)\n   - Constraints (budget, timeline, team skills)\n   - Growth projections\n\n2. **Design Architecture**\n   - Choose architectural pattern (monolith, microservices, serverless)\n   - Define system components and boundaries\n   - Design data flow and integration patterns\n   - Select technology stack\n\n3. **Create Diagrams**\n   - Context diagrams (system in environment)\n   - Container diagrams (high-level components)\n   - Component diagrams (detailed design)\n   - Deployment diagrams (infrastructure)\n\n4. **Plan for Scale**\n   - Identify bottlenecks\n   - Design caching strategy\n   - Plan database scaling\n   - Design for high availability\n\n5. **Document Decisions**\n   - Rationale for key decisions\n   - Trade-offs considered\n   - Alternative approaches\n   - Risk assessment\n\n## Architectural Patterns\n\n### 1. Monolithic Architecture\n\n```\n┌─────────────────────────────────────┐\n│        Monolithic Application       │\n│                                     │\n│  ┌───────────┐  ┌───────────┐     │\n│  │    UI     │  │    API    │     │\n│  └─────┬─────┘  └─────┬─────┘     │\n│        │              │            │\n│        └──────┬───────┘            │\n│               │                    │\n│    ┌──────────▼──────────┐        │\n│    │  Business Logic     │        │\n│    └──────────┬──────────┘        │\n│               │                    │\n│    ┌──────────▼──────────┐        │\n│    │   Data Access       │        │\n│    └──────────┬──────────┘        │\n└───────────────┼───────────────────┘\n                │\n         ┌──────▼──────┐\n         │  Database   │\n         └─────────────┘\n```\n\n**Use When**:\n- Small to medium applications\n- Team < 10 developers\n- Simple domain\n- Rapid development needed\n- Limited traffic (<1000 req/sec)\n\n**Pros**:\n- Simple to develop and deploy\n- Easy to test\n- No network overhead\n- Easier to debug\n\n**Cons**:\n- Scales as a unit\n- Tight coupling\n- Technology lock-in\n- Difficult to parallelize development\n\n### 2. Microservices Architecture\n\n```\n                    ┌──────────────┐\n                    │ API Gateway  │\n                    └───────┬──────┘\n            ┌───────────────┼───────────────┐\n            │               │               │\n     ┌──────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐\n     │   User      │ │   Product  │ │   Order    │\n     │   Service   │ │   Service  │ │   Service  │\n     └──────┬──────┘ └─────┬──────┘ └─────┬──────┘\n            │               │               │\n     ┌──────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐\n     │   User DB   │ │ Product DB │ │  Order DB  │\n     └─────────────┘ └────────────┘ └────────────┘\n```\n\n**Use When**:\n- Large, complex domains\n- Multiple teams (>10 developers)\n- Different scaling requirements per service\n- Need independent deployments\n- Polyglot technology needs\n\n**Pros**:\n- Independent scaling\n- Technology flexibility\n- Parallel development\n- Fault isolation\n\n**Cons**:\n- Increased complexity\n- Network overhead\n- Distributed tracing needed\n- Data consistency challenges\n\n### 3. Serverless Architecture\n\n```\n┌──────────┐\n│  Client  │\n└─────┬────┘\n      │\n┌─────▼──────────┐\n│  API Gateway   │\n└────────────────┘\n      │\n      ├──────────────┐\n      │              │\n┌─────▼─────┐  ┌────▼─────┐\n│ Lambda 1  │  │ Lambda 2 │\n│ (Auth)    │  │ (Orders) │\n└─────┬─────┘  └────┬─────┘\n      │             │\n┌─────▼─────────────▼─────┐\n│     DynamoDB/RDS        │\n└─────────────────────────┘\n```\n\n**Use When**:\n- Unpredictable traffic patterns\n- Event-driven workflows\n- Want zero infrastructure management\n- Cost optimization for low traffic\n- Rapid prototyping\n\n**Pros**:\n- Auto-scaling\n- Pay per execution\n- No server management\n- High availability built-in\n\n**Cons**:\n- Cold start latency\n- Vendor lock-in\n- Difficult to debug\n- Limited execution time\n\n### 4. Event-Driven Architecture\n\n```\n┌────────────┐      ┌────────────┐\n│  Service A │─────>│   Event    │\n└────────────┘      │    Bus     │\n                    └──────┬─────┘\n                           │\n          ┌────────────────┼────────────────┐\n          │                │                │\n   ┌──────▼──────┐  ┌─────▼──────┐  ┌─────▼──────┐\n   │  Service B  │  │  Service C │  │  Service D │\n   │ (Subscriber)│  │(Subscriber)│  │(Subscriber)│\n   └─────────────┘  └────────────┘  └────────────┘\n```\n\n**Use When**:\n- Asynchronous processing needed\n- Loose coupling desired\n- Multiple consumers per event\n- Event sourcing pattern\n- Real-time data processing\n\n**Pros**:\n- Loose coupling\n- Scalable\n- Asynchronous processing\n- Event history/replay\n\n**Cons**:\n- Eventual consistency\n- Difficult to trace flows\n- Message ordering challenges\n- Debugging complexity\n\n## Templates\n\n### Architecture Document Template\n\n```markdown\n# System Architecture: [Application Name]\n\n**Version**: 1.0\n**Last Updated**: [Date]\n**Author**: [Name]\n**Status**: [Draft | Review | Approved]\n\n## Executive Summary\n\n[2-3 paragraphs describing the system, its purpose, and architectural approach]\n\n## System Context\n\n### Business Goals\n- [Goal 1]\n- [Goal 2]\n- [Goal 3]\n\n### Key Requirements\n\n#### Functional Requirements\n- [Requirement 1]\n- [Requirement 2]\n\n#### Non-Functional Requirements\n\n| Requirement | Target | Measurement |\n|-------------|--------|-------------|\n| Performance | p95 < 200ms | API response time |\n| Availability | 99.9% | Uptime |\n| Scalability | 10k concurrent users | Load testing |\n| Security | SOC 2 compliant | Audit |\n\n### Constraints\n- Budget: [amount]\n- Timeline: [duration]\n- Team size: [count]\n- Technology: [any constraints]\n\n### Assumptions\n- [Assumption 1]\n- [Assumption 2]\n\n## Architecture Overview\n\n### Architectural Style\n[Monolithic | Microservices | Serverless | Hybrid]\n\n**Rationale**: [Why this style was chosen]\n\n### High-Level Architecture Diagram\n\n```\n[ASCII or Mermaid diagram]\n```\n\n### Key Components\n\n1. **[Component Name]**\n   - **Purpose**: [What it does]\n   - **Technology**: [Tech stack]\n   - **Responsibilities**: [Key responsibilities]\n   - **Interfaces**: [APIs it exposes]\n   - **Dependencies**: [What it depends on]\n\n2. **[Component Name]**\n   [Repeat]\n\n## Detailed Component Design\n\n### Component 1: [Name]\n\n#### Responsibilities\n- [Responsibility 1]\n- [Responsibility 2]\n\n#### Interfaces\n\n**REST API**:\n```\nGET    /api/v1/resources\nPOST   /api/v1/resources\nGET    /api/v1/resources/:id\nPUT    /api/v1/resources/:id\nDELETE /api/v1/resources/:id\n```\n\n**Events Published**:\n- `resource.created`\n- `resource.updated`\n- `resource.deleted`\n\n**Events Consumed**:\n- `user.registered`\n\n#### Technology Stack\n- Language: [e.g., Node.js/TypeScript]\n- Framework: [e.g., Express]\n- Database: [e.g., PostgreSQL]\n- Cache: [e.g., Redis]\n- Message Queue: [e.g., RabbitMQ]\n\n#### Data Model\n\n```sql\nCREATE TABLE resources (\n  id UUID PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  status VARCHAR(50),\n  created_at TIMESTAMP,\n  updated_at TIMESTAMP\n);\n```\n\n#### Scalability\n- **Horizontal Scaling**: Yes, stateless\n- **Caching Strategy**: Redis for frequently accessed data (5min TTL)\n- **Database**: Read replicas for scaling reads\n\n#### Security\n- Authentication: OAuth 2.0 JWT tokens\n- Authorization: Role-based access control (RBAC)\n- Encryption: TLS 1.3 for transport, AES-256 at rest\n- Rate Limiting: 100 req/min per user\n\n## Data Architecture\n\n### Database Design\n\n**Database Type**: [Relational | NoSQL | Hybrid]\n\n**Database Schema**:\n[ERD diagram or schema definition]\n\n**Partitioning Strategy**:\n- [How data is partitioned]\n\n**Backup Strategy**:\n- Frequency: [e.g., Daily]\n- Retention: [e.g., 30 days]\n- Recovery Time Objective (RTO): [e.g., 1 hour]\n- Recovery Point Objective (RPO): [e.g., 24 hours]\n\n### Data Flow\n\n```mermaid\nflowchart LR\n    User --> API\n    API --> Cache\n    Cache --> |miss| Database\n    API --> Queue\n    Queue --> Worker\n    Worker --> Database\n```\n\n### Caching Strategy\n\n| Data Type | Cache | TTL | Invalidation |\n|-----------|-------|-----|-------------|\n| User profile | Redis | 1 hour | On update |\n| Product catalog | Redis | 5 min | On change |\n| Session data | Redis | 24 hours | On logout |\n\n## Integration Architecture\n\n### Internal Communication\n\n**Synchronous**: REST APIs for request-response\n**Asynchronous**: Message queue for events\n\n### External Integrations\n\n| Service | Purpose | Protocol | SLA |\n|---------|---------|----------|-----|\n| Stripe | Payments | REST | 99.99% |\n| SendGrid | Email | REST | 99.9% |\n| Auth0 | Authentication | OAuth 2.0 | 99.99% |\n\n### API Gateway\n\n**Functions**:\n- Request routing\n- Rate limiting\n- Authentication\n- Request/response transformation\n- Monitoring\n\n## Infrastructure Architecture\n\n### Deployment Architecture\n\n```\n┌─────────────────────────────────────────┐\n│              Production                 │\n│                                         │\n│  ┌──────────┐         ┌──────────┐    │\n│  │  Region  │         │  Region  │    │\n│  │   US-E   │         │   US-W   │    │\n│  └────┬─────┘         └────┬─────┘    │\n│       │                    │           │\n│  ┌────▼──────────────────▼─────┐     │\n│  │    Load Balancer            │     │\n│  └────┬──────────────────┬─────┘     │\n│       │                  │            │\n│  ┌────▼────┐       ┌────▼────┐      │\n│  │  App    │       │  App    │      │\n│  │ Cluster │       │ Cluster │      │\n│  └────┬────┘       └────┬────┘      │\n│       │                  │            │\n│  ┌────▼──────────────────▼─────┐    │\n│  │       Database Cluster      │    │\n│  │   (Primary + Replicas)      │    │\n│  └─────────────────────────────┘    │\n└─────────────────────────────────────┘\n```\n\n### Infrastructure Components\n\n- **Cloud Provider**: [AWS | Azure | GCP | Multi-cloud]\n- **Container Orchestration**: [Kubernetes | ECS | None]\n- **Load Balancer**: [ALB | nginx | etc.]\n- **CDN**: [CloudFront | Cloudflare | etc.]\n- **Monitoring**: [DataDog | New Relic | Prometheus]\n- **Logging**: [ELK | CloudWatch | Splunk]\n\n### Scalability Plan\n\n#### Current Capacity\n- Users: [count]\n- Requests/sec: [count]\n- Data size: [size]\n\n#### Year 1 Projection\n- Users: [count]\n- Requests/sec: [count]\n- Data size: [size]\n\n#### Scaling Strategy\n\n**Application Tier**:\n- Auto-scaling: 2-10 instances\n- Trigger: CPU > 70%\n- Scale-up time: 2 minutes\n\n**Database Tier**:\n- Vertical scaling: Upgrade instance size\n- Read replicas: Add as read traffic grows\n- Sharding: When >1TB data\n\n**Caching Tier**:\n- Redis cluster: 3-10 nodes\n- Auto-scaling based on memory usage\n\n## Security Architecture\n\n### Authentication & Authorization\n\n- **Authentication**: OAuth 2.0 with JWT tokens\n- **Authorization**: Role-Based Access Control (RBAC)\n- **Session Management**: 24-hour token expiration\n- **MFA**: Optional for users, required for admins\n\n### Data Security\n\n- **Encryption in Transit**: TLS 1.3\n- **Encryption at Rest**: AES-256\n- **Key Management**: AWS KMS / HashiCorp Vault\n- **Sensitive Data**: PII hashed/encrypted\n\n### Network Security\n\n- **Firewall**: WAF for application layer\n- **DDoS Protection**: CloudFlare / AWS Shield\n- **VPC**: Private subnets for databases\n- **Security Groups**: Principle of least privilege\n\n### Compliance\n\n- [x] GDPR compliant\n- [x] SOC 2 Type II\n- [ ] HIPAA (if needed)\n- [x] PCI DSS (for payments)\n\n## Monitoring & Observability\n\n### Metrics\n\n**Application Metrics**:\n- Request rate, error rate, latency (RED method)\n- Business metrics (signups, conversions, etc.)\n\n**Infrastructure Metrics**:\n- CPU, memory, disk, network\n- Database connections, query time\n- Cache hit ratio\n\n### Logging\n\n**Log Levels**: DEBUG, INFO, WARN, ERROR, FATAL\n**Log Aggregation**: Centralized logging system\n**Retention**: 30 days (90 days for audit logs)\n\n### Alerting\n\n| Alert | Condition | Severity | Action |\n|-------|-----------|----------|--------|\n| API Error Rate | >5% for 5min | Critical | Page on-call |\n| Response Time | p95 >1s for 10min | High | Slack alert |\n| Database CPU | >80% for 15min | High | Slack alert |\n| Disk Space | >90% | Critical | Page on-call |\n\n### Distributed Tracing\n\n**Tool**: [Jaeger | Zipkin | AWS X-Ray]\n**Coverage**: All service-to-service calls\n**Sampling**: 1% in production, 100% in staging\n\n## Disaster Recovery\n\n### Backup Strategy\n\n- **Database**: Daily automated backups, retained 30 days\n- **File Storage**: Versioned, replicated across regions\n- **Configuration**: Version controlled in Git\n\n### Recovery Procedures\n\n**RTO (Recovery Time Objective)**: 2 hours\n**RPO (Recovery Point Objective)**: 24 hours\n\n**Scenarios**:\n\n1. **Database Failure**: Failover to replica (automatic, <5 min)\n2. **Region Outage**: Manual failover to backup region (<2 hours)\n3. **Data Corruption**: Restore from backup (<4 hours)\n\n## Cost Estimation\n\n| Component | Monthly Cost | Annual Cost |\n|-----------|--------------|-------------|\n| Compute (EC2/ECS) | $500 | $6,000 |\n| Database (RDS) | $300 | $3,600 |\n| Cache (ElastiCache) | $100 | $1,200 |\n| Storage (S3) | $50 | $600 |\n| CDN (CloudFront) | $100 | $1,200 |\n| Monitoring | $200 | $2,400 |\n| **Total** | **$1,250** | **$15,000** |\n\n**Cost Optimization**:\n- Use reserved instances (30% savings)\n- Auto-scaling to match demand\n- Lifecycle policies for old data\n\n## Risks and Mitigations\n\n| Risk | Probability | Impact | Mitigation |\n|------|------------|--------|------------|\n| Database bottleneck | Medium | High | Add read replicas, implement caching |\n| Third-party API outage | Low | Medium | Circuit breakers, fallback behavior |\n| Security breach | Low | Critical | Regular audits, penetration testing |\n| Cost overrun | Medium | Medium | Budget alerts, cost optimization |\n\n## Alternative Architectures Considered\n\n### Alternative 1: [Name]\n\n**Description**: [Brief description]\n\n**Pros**:\n- [Pro 1]\n- [Pro 2]\n\n**Cons**:\n- [Con 1]\n- [Con 2]\n\n**Why Not Chosen**: [Reason]\n\n## Technology Stack Rationale\n\n| Technology | Choice | Rationale |\n|------------|--------|----------|\n| Language | Node.js/TypeScript | Team expertise, async I/O, npm ecosystem |\n| Framework | Express | Mature, flexible, large ecosystem |\n| Database | PostgreSQL | ACID compliance, JSON support, full-text search |\n| Cache | Redis | Fast, versatile, pub/sub support |\n| Message Queue | RabbitMQ | Reliable, mature, flexible routing |\n| Cloud | AWS | Market leader, comprehensive services |\n\n## Migration Strategy\n\n[If migrating from existing system]\n\n**Phase 1**: [Description]\n**Phase 2**: [Description]\n**Phase 3**: [Description]\n\n## Future Enhancements\n\n- [ ] [Enhancement 1]: [Timeline]\n- [ ] [Enhancement 2]: [Timeline]\n- [ ] [Enhancement 3]: [Timeline]\n\n## Appendix\n\n### Glossary\n- **Term 1**: Definition\n- **Term 2**: Definition\n\n### References\n- [Link to related documentation]\n- [Link to research materials]\n```\n\n## Examples\n\n### Example 1: E-commerce Platform Architecture\n\n```markdown\n# System Architecture: E-commerce Platform\n\n## Executive Summary\n\nDesigning a scalable e-commerce platform to handle 100k active users, processing 1k orders/day with room to grow 10x over 2 years. Using microservices architecture for independent scaling of catalog, orders, and payments. Focus on 99.9% availability and sub-200ms API response times.\n\n## High-Level Architecture\n\n```\n                        ┌──────────────┐\n                        │   Cloudflare │\n                        │     (CDN)    │\n                        └──────┬───────┘\n                               │\n                        ┌──────▼───────┐\n                        │ Load Balancer│\n                        └──────┬───────┘\n                               │\n                    ┌──────────┼──────────┐\n                    │                     │\n            ┌───────▼──────┐      ┌─────▼───────┐\n            │   Web App    │      │ API Gateway │\n            │   (Next.js)  │      │   (Kong)    │\n            └──────────────┘      └─────┬───────┘\n                                        │\n        ┌───────────┬───────────┬──────┴────┬─────────────┐\n        │           │           │           │             │\n  ┌─────▼────┐ ┌───▼────┐ ┌───▼─────┐ ┌──▼──────┐ ┌────▼─────┐\n  │   User   │ │Product │ │  Order  │ │Payment  │ │Inventory │\n  │ Service  │ │Service │ │ Service │ │Service  │ │ Service  │\n  └─────┬────┘ └───┬────┘ └───┬─────┘ └──┬──────┘ └────┬─────┘\n        │          │          │           │             │\n  ┌─────▼────┐ ┌──▼─────┐ ┌──▼──────┐ ┌─▼───────┐ ┌───▼──────┐\n  │ User DB  │ │Catalog │ │Order DB │ │ Stripe  │ │Inventory │\n  │(Postgres)│ │   DB   │ │(Postgres│ │   API   │ │    DB    │\n  │          │ │(Postgres│ │         │ └─────────┘ │(Postgres)│\n  └──────────┘ │         │ └─────────┘             └──────────┘\n               └─────────┘                          \n                    │\n             ┌──────▼──────┐\n             │ Elasticsearch│\n             │   (Search)  │\n             └─────────────┘\n               \n        ┌──────────────────────┐\n        │    Event Bus         │\n        │    (RabbitMQ)        │\n        └──────────┬───────────┘\n                   │\n        ┌──────────┼───────────┐\n        │          │           │\n   ┌────▼───┐ ┌───▼────┐ ┌────▼─────┐\n   │ Email  │ │Analytics│ │Warehouse │\n   │Worker  │ │ Worker  │ │  Worker  │\n   └────────┘ └─────────┘ └──────────┘\n```\n\n## Service Design\n\n### Product Service\n\n**Responsibilities**:\n- Product catalog management (CRUD)\n- Product search and filtering\n- Category management\n- Product recommendations\n\n**API Endpoints**:\n```\nGET    /api/v1/products              # Search/list products\nGET    /api/v1/products/:id          # Get product details\nPOST   /api/v1/products              # Create product (admin)\nPUT    /api/v1/products/:id          # Update product (admin)\nDELETE /api/v1/products/:id          # Delete product (admin)\nGET    /api/v1/categories            # List categories\nGET    /api/v1/products/:id/related  # Related products\n```\n\n**Technology**:\n- Language: Node.js/TypeScript\n- Framework: NestJS\n- Database: PostgreSQL (product data)\n- Search: Elasticsearch (full-text search, filters)\n- Cache: Redis (popular products, 5min TTL)\n\n**Data Model**:\n```sql\nCREATE TABLE products (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  price DECIMAL(10, 2) NOT NULL,\n  category_id UUID REFERENCES categories(id),\n  image_urls TEXT[],\n  metadata JSONB, -- flexible fields\n  stock_status VARCHAR(50),\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_products_category ON products(category_id);\nCREATE INDEX idx_products_price ON products(price);\nCREATE INDEX idx_products_created ON products(created_at DESC);\n\n-- Full-text search\nCREATE INDEX idx_products_search ON products \n  USING GIN(to_tsvector('english', name || ' ' || description));\n```\n\n**Scaling Strategy**:\n- Horizontal scaling: 3-10 instances (auto-scale)\n- Read-heavy: 2 read replicas\n- Elasticsearch cluster: 3 nodes\n- Cache hit ratio target: >80%\n\n**Events Published**:\n- `product.created`\n- `product.updated`\n- `product.deleted`\n- `product.price_changed`\n\n### Order Service\n\n**Responsibilities**:\n- Order placement and processing\n- Order status tracking\n- Order history\n- Order validation\n\n**API Endpoints**:\n```\nPOST   /api/v1/orders              # Create order\nGET    /api/v1/orders              # List user's orders\nGET    /api/v1/orders/:id          # Get order details\nPUT    /api/v1/orders/:id/cancel   # Cancel order\nGET    /api/v1/orders/:id/status   # Track order\n```\n\n**Technology**:\n- Language: Node.js/TypeScript\n- Framework: Express\n- Database: PostgreSQL (orders)\n- Message Queue: RabbitMQ (order processing)\n\n**Data Model**:\n```sql\nCREATE TABLE orders (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL,\n  status VARCHAR(50) NOT NULL, -- pending, confirmed, shipped, delivered, cancelled\n  total_amount DECIMAL(10, 2) NOT NULL,\n  shipping_address JSONB NOT NULL,\n  billing_address JSONB NOT NULL,\n  payment_id VARCHAR(255), -- Stripe payment ID\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE TABLE order_items (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  order_id UUID NOT NULL REFERENCES orders(id),\n  product_id UUID NOT NULL,\n  product_name VARCHAR(255) NOT NULL, -- denormalized\n  quantity INTEGER NOT NULL,\n  unit_price DECIMAL(10, 2) NOT NULL,\n  subtotal DECIMAL(10, 2) NOT NULL\n);\n\nCREATE INDEX idx_orders_user ON orders(user_id);\nCREATE INDEX idx_orders_status ON orders(status);\nCREATE INDEX idx_orders_created ON orders(created_at DESC);\n```\n\n**Order Processing Flow**:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant OrderService\n    participant InventoryService\n    participant PaymentService\n    participant EventBus\n    participant EmailWorker\n\n    User->>OrderService: POST /orders\n    OrderService->>InventoryService: Check stock\n    InventoryService-->>OrderService: Stock available\n    OrderService->>InventoryService: Reserve items\n    OrderService->>PaymentService: Process payment\n    PaymentService->>Stripe: Charge card\n    Stripe-->>PaymentService: Payment successful\n    PaymentService-->>OrderService: Payment confirmed\n    OrderService->>InventoryService: Confirm reservation\n    OrderService->>EventBus: Publish order.created\n    EventBus->>EmailWorker: order.created event\n    EmailWorker->>User: Send confirmation email\n    OrderService-->>User: 201 Created (order ID)\n```\n\n**Events Published**:\n- `order.created`\n- `order.confirmed`\n- `order.shipped`\n- `order.delivered`\n- `order.cancelled`\n\n### Payment Service\n\n**Responsibilities**:\n- Process payments via Stripe\n- Handle webhooks\n- Refund processing\n- Payment history\n\n**Technology**:\n- Language: Node.js/TypeScript\n- Integration: Stripe API\n- Database: PostgreSQL (transaction records)\n\n**Security**:\n- PCI compliance via Stripe (no card data stored)\n- Webhook signature verification\n- Idempotency keys for retries\n- Audit logging for all transactions\n\n## Data Architecture\n\n### Database Strategy\n\n**Database per Service**: Each microservice has its own database\n\n**Rationale**:\n- Service independence\n- Different scaling needs\n- Technology flexibility\n\n**Trade-offs**:\n- No foreign keys across services\n- Eventual consistency\n- Distributed transactions complexity\n\n### Data Consistency\n\n**Pattern**: Saga Pattern for distributed transactions\n\n**Example**: Order Creation Saga\n\n1. Order Service: Create order (status: pending)\n2. Inventory Service: Reserve items\n3. Payment Service: Charge payment\n4. Order Service: Confirm order (status: confirmed)\n\n**Rollback** (if payment fails):\n1. Payment Service: Returns error\n2. Inventory Service: Release reservation\n3. Order Service: Cancel order\n\n### Caching Strategy\n\n| Data | Cache | TTL | Invalidation |\n|------|-------|-----|-------------|\n| Product details | Redis | 5 min | On product update |\n| Product search results | Redis | 1 min | On product change |\n| User session | Redis | 24 hrs | On logout |\n| Category tree | Redis | 1 hour | On category change |\n| Cart items | Redis | 7 days | On checkout |\n\n## Scalability Plan\n\n### Current Scale (Launch)\n- 10k users\n- 100 orders/day\n- 10k products\n- 1k concurrent users\n\n### Year 1 Target\n- 100k users\n- 1k orders/day\n- 50k products\n- 5k concurrent users\n\n### Year 2 Target\n- 1M users\n- 10k orders/day\n- 500k products\n- 50k concurrent users\n\n### Scaling Strategy\n\n**Application Tier**:\n- Auto-scaling groups (2-10 instances per service)\n- CPU target: 70%\n- Scale-up time: 2 minutes\n\n**Database Tier**:\n- Year 1: Single instance (db.r5.large)\n- Year 2: Primary + 2 read replicas\n- Sharding: If >500GB data\n\n**Search**:\n- Year 1: 3-node Elasticsearch cluster\n- Year 2: 5-node cluster with dedicated master\n\n**CDN**:\n- Cloudflare for static assets and images\n- Edge caching for product pages\n- 90%+ cache hit ratio target\n\n## Monitoring & Observability\n\n### Key Metrics\n\n**Business Metrics**:\n- Orders per hour\n- Conversion rate\n- Average order value\n- Cart abandonment rate\n\n**Technical Metrics**:\n- API response time (p50, p95, p99)\n- Error rate per service\n- Database query time\n- Cache hit ratio\n- Queue depth\n\n### Alerts\n\n| Alert | Condition | Severity | Action |\n|-------|-----------|----------|--------|\n| High error rate | >5% errors for 5min | Critical | Page on-call |\n| Slow API | p95 >500ms for 10min | High | Slack alert |\n| Payment failure | >10% failures | Critical | Page on-call |\n| Low inventory | Stock <10 for popular item | Medium | Email ops |\n| Queue backlog | >1000 messages | High | Slack alert |\n\n### Distributed Tracing\n\n**Tool**: Jaeger\n**Instrumentation**: All inter-service calls\n**Sampling**: 1% in production\n\n**Trace Example**: Order Creation\n- API Gateway → Order Service (50ms)\n  - Order Service → Inventory Service (20ms)\n  - Order Service → Payment Service (300ms)\n    - Payment Service → Stripe API (250ms)\n  - Order Service → EventBus (5ms)\n- Total: 375ms\n\n## Cost Estimation\n\n### Infrastructure Costs (Monthly)\n\n| Component | Specification | Cost |\n|-----------|--------------|------|\n| EC2 (App servers) | 10x t3.medium | $300 |\n| RDS (PostgreSQL) | 3x db.r5.large | $600 |\n| ElastiCache (Redis) | 3x cache.r5.large | $300 |\n| Elasticsearch | 3-node cluster | $400 |\n| ALB | 2x load balancers | $50 |\n| S3 (images) | 1TB storage + transfer | $100 |\n| CloudFront (CDN) | 5TB transfer | $200 |\n| RabbitMQ (CloudAMQP) | Production plan | $100 |\n| Monitoring (DataDog) | Infrastructure + APM | $400 |\n| **Total** | | **$2,450** |\n\n### Third-Party Services\n\n| Service | Cost |\n|---------|------|\n| Stripe | 2.9% + $0.30 per transaction |\n| SendGrid | $15/month (10k emails) |\n| Cloudflare | $20/month |\n| **Total** | **~$35/month** + transaction fees |\n\n### Total Monthly Cost\n**Infrastructure**: $2,450\n**Services**: $35 + Stripe fees\n**Estimated Total**: $2,500-3,000/month\n\n## Risk Mitigation\n\n| Risk | Impact | Mitigation |\n|------|--------|------------|\n| Payment gateway outage | High | Queue payments for retry, graceful degradation |\n| Database overload | High | Read replicas, connection pooling, caching |\n| Inventory sync issues | Medium | Event sourcing, reconciliation jobs |\n| DDoS attack | High | Cloudflare protection, rate limiting |\n| Service cascade failure | High | Circuit breakers, timeouts, fallbacks |\n```\n\n### Example 2: Real-Time Chat Application\n\n```markdown\n# System Architecture: Real-Time Chat Platform\n\n## Requirements\n\n- 1M concurrent users\n- Sub-100ms message delivery\n- Message history (30 days)\n- File sharing (images, documents)\n- Group chats (up to 100 members)\n- Presence indicators (online/offline)\n- Read receipts\n- 99.99% availability\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────┐\n│            Client Layer                         │\n│  (Web: React, Mobile: React Native)            │\n└───────────────┬─────────────────────────────────┘\n                │\n                │ WebSocket + HTTPS\n                │\n┌───────────────▼─────────────────────────────────┐\n│          Load Balancer (ALB)                    │\n│       (Sticky sessions for WebSocket)           │\n└───────────────┬─────────────────────────────────┘\n                │\n      ┌─────────┴─────────┐\n      │                   │\n┌─────▼────────┐    ┌─────▼────────┐\n│   Gateway    │    │   Gateway    │\n│   Server 1   │    │   Server 2   │\n│  (WebSocket) │    │  (WebSocket) │\n└─────┬────────┘    └─────┬────────┘\n      │                   │\n      └─────────┬─────────┘\n                │\n         ┌──────▼──────┐\n         │   Redis     │\n         │  (Pub/Sub)  │\n         └──────┬──────┘\n                │\n      ┌─────────┼─────────┬─────────┐\n      │         │         │         │\n┌─────▼───┐ ┌──▼────┐ ┌──▼────┐ ┌──▼──────┐\n│ Message │ │ User  │ │ Room  │ │Presence │\n│ Service │ │Service│ │Service│ │ Service │\n└────┬────┘ └───┬───┘ └───┬───┘ └────┬────┘\n     │          │         │          │\n┌────▼────┐ ┌───▼───┐ ┌───▼───┐ ┌───▼────┐\n│Cassandra│ │MongoDB│ │MongoDB│ │  Redis │\n│(Messages│ │(Users)│ │(Rooms)│ │(Status)│\n└─────────┘ └───────┘ └───────┘ └────────┘\n\n     ┌────────────┐\n     │    S3      │\n     │ (File      │\n     │  Storage)  │\n     └────────────┘\n```\n\n## Technology Choices\n\n### WebSocket Gateway\n**Choice**: Node.js with Socket.IO\n\n**Rationale**:\n- Excellent WebSocket support\n- Event-driven, handles many concurrent connections\n- Socket.IO provides fallbacks (polling) for old browsers\n\n**Scaling**: \n- Stateless gateway servers\n- Redis pub/sub for cross-server messaging\n- 10k connections per server\n- Auto-scale based on connection count\n\n### Message Storage\n**Choice**: Apache Cassandra\n\n**Rationale**:\n- Optimized for write-heavy workloads\n- Linear scalability\n- No single point of failure\n- Time-series data (messages with timestamps)\n\n**Schema**:\n```cql\nCREATE TABLE messages_by_room (\n  room_id UUID,\n  message_id TIMEUUID,\n  user_id UUID,\n  content TEXT,\n  attachments LIST<TEXT>,\n  created_at TIMESTAMP,\n  PRIMARY KEY ((room_id), message_id)\n) WITH CLUSTERING ORDER BY (message_id DESC);\n\n-- Recent messages first\n-- Efficient pagination\n```\n\n### Presence Service\n**Choice**: Redis with TTL\n\n**Rationale**:\n- Fast read/write\n- TTL for automatic status expiration\n- Pub/sub for presence updates\n\n**Implementation**:\n```javascript\n// User goes online\nawait redis.setex(`presence:${userId}`, 60, 'online');\n\n// Heartbeat every 30 seconds to stay online\nsetInterval(() => {\n  redis.expire(`presence:${userId}`, 60);\n}, 30000);\n\n// Check user status\nconst status = await redis.get(`presence:${userId}`);\n// Returns 'online' or null (offline)\n```\n\n## Message Flow\n\n```mermaid\nsequenceDiagram\n    participant Sender\n    participant Gateway1\n    participant Redis\n    participant Gateway2\n    participant Receiver\n    participant MessageService\n    participant Cassandra\n\n    Sender->>Gateway1: Send message (WebSocket)\n    Gateway1->>MessageService: Store message\n    MessageService->>Cassandra: INSERT message\n    Cassandra-->>MessageService: Stored\n    MessageService-->>Gateway1: Message ID\n    Gateway1->>Redis: PUBLISH message\n    Redis->>Gateway1: Delivered to sender\n    Redis->>Gateway2: Delivered to recipient's server\n    Gateway1-->>Sender: Ack (message sent)\n    Gateway2->>Receiver: Forward message (WebSocket)\n    Receiver-->>Gateway2: Ack (received)\n    Gateway2->>MessageService: Update delivery status\n```\n\n## Scalability\n\n### Connection Handling\n\n**Per Server**: 10k concurrent connections\n**Target**: 1M concurrent users\n**Servers Needed**: 100 gateway servers\n\n**Cost Optimization**:\n- Use smaller instances (t3.medium)\n- Auto-scaling (min 20, max 150)\n- Scale based on connection count\n\n### Message Throughput\n\n**Per Server**: 10k messages/second\n**Target**: 100k messages/second\n**Servers Needed**: 10-15 message service instances\n\n### Database Scaling\n\n**Cassandra Cluster**:\n- Start: 3 nodes\n- Year 1: 6 nodes\n- Year 2: 12 nodes\n- Replication factor: 3\n\n**Data Size**:\n- 1M users, 100 messages/user/day\n- 100M messages/day\n- ~1KB per message\n- ~100GB/day → ~3TB/month\n- With compression: ~1TB/month\n- 30-day retention: ~30TB\n\n## Reliability\n\n### High Availability\n\n- Multi-AZ deployment\n- No single point of failure\n- Automatic failover\n\n### Message Delivery Guarantees\n\n**At-least-once delivery**:\n- Messages queued until acknowledged\n- Retry on failure (exponential backoff)\n- Duplicate detection on client\n\n### Offline Message Delivery\n\n```javascript\n// When user comes online\nconst missedMessages = await messageService.getMessages({\n  roomId,\n  since: user.lastSeen,\n  limit: 100\n});\n\n// Send missed messages\nmissedMessages.forEach(msg => {\n  socket.emit('message', msg);\n});\n```\n\n## Cost Estimation\n\n### Peak Load (1M concurrent users)\n\n| Component | Specification | Cost/month |\n|-----------|--------------|------------|\n| Gateway servers | 100x t3.medium | $3,000 |\n| Message service | 15x t3.large | $1,500 |\n| Cassandra | 12x i3.2xlarge | $12,000 |\n| Redis | 2x cache.r5.2xlarge | $800 |\n| MongoDB | 3x r5.xlarge | $900 |\n| Load balancer | 2x ALB | $50 |\n| Data transfer | 10TB/month | $900 |\n| **Total** | | **$19,150** |\n\n### Optimization for Lower Scale (100k users)\n\n| Component | Specification | Cost/month |\n|-----------|--------------|------------|\n| Gateway servers | 15x t3.medium | $450 |\n| Message service | 3x t3.large | $300 |\n| Cassandra | 3x i3.xlarge | $2,000 |\n| Redis | cache.r5.large | $200 |\n| MongoDB | r5.large | $150 |\n| Load balancer | ALB | $25 |\n| Data transfer | 1TB/month | $90 |\n| **Total** | | **$3,215** |\n```\n\n## Best Practices\n\n1. **Start Simple**\n   - Begin with monolith or modular monolith\n   - Split into microservices only when needed\n   - Avoid premature optimization\n\n2. **Design for Failure**\n   - Assume everything will fail\n   - Implement circuit breakers\n   - Add timeouts and retries\n   - Graceful degradation\n\n3. **Optimize for Scalability**\n   - Stateless services\n   - Horizontal scaling\n   - Caching at multiple layers\n   - Async processing where possible\n\n4. **Security First**\n   - Defense in depth\n   - Principle of least privilege\n   - Encrypt data in transit and at rest\n   - Regular security audits\n\n5. **Observability**\n   - Comprehensive logging\n   - Distributed tracing\n   - Meaningful metrics and alerts\n   - Dashboards for key indicators\n\n6. **Document Decisions**\n   - Use ADRs for architectural decisions\n   - Keep diagrams up to date\n   - Document trade-offs\n   - Share knowledge across team\n\n## Common Pitfalls\n\n- **Over-engineering**: Building for 1M users when you have 100\n- **Micro-services too early**: Split before understanding domain boundaries\n- **Ignoring data consistency**: Not planning for distributed transactions\n- **No caching strategy**: Hammering database unnecessarily\n- **Single point of failure**: Not planning for redundancy\n- **Poor monitoring**: Flying blind without metrics\n- **Ignoring costs**: Over-provisioning infrastructure\n- **No disaster recovery**: Not planning for worst-case scenarios\n",
  "prompt": "A skill that guides design of robust, scalable system architectures including component diagrams using C4 model, microservices vs monolith decision-making, database architecture with data modeling, API design patterns, infrastructure planning with deployment diagrams, scalability strategies, and cost estimation. Provides comprehensive templates for architecture documents and detailed examples for e-commerce platforms with microservices breakdown, and real-time chat applications with WebSocket scaling and Cassandra data modeling.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}