{
  "id": "backend-authentication",
  "name": "Authentication & Authorization",
  "description": "Complete authentication patterns with JWT, OAuth, sessions, password hashing, refresh tokens, and role-based access control",
  "category": "Backend",
  "content": "---\nname: Authentication & Authorization\ndescription: Complete authentication patterns with JWT, OAuth, sessions, password hashing, refresh tokens, and role-based access control\ncategory: Backend\n---\n\n# Authentication & Authorization\n\n## Overview\n\nThis skill provides production-ready authentication and authorization patterns including JWT tokens, OAuth 2.0, session management, password hashing with bcrypt, refresh token rotation, role-based access control (RBAC), and security best practices.\n\n## Activation\n\nUse this skill when:\n- Implementing user authentication (login/signup)\n- Adding JWT or session-based authentication\n- Integrating OAuth providers (Google, GitHub, etc.)\n- Implementing password hashing and validation\n- Adding refresh token functionality\n- Implementing role-based or permission-based access control\n- Securing API endpoints with authentication middleware\n- Building logout and token revocation features\n\n## Instructions\n\n1. **Choose Auth Strategy**: Select JWT (stateless) or sessions (stateful)\n2. **Hash Passwords**: Use bcrypt with proper salt rounds (10-12)\n3. **Generate Tokens**: Create secure JWT tokens with expiration\n4. **Implement Refresh Tokens**: Add refresh token rotation for security\n5. **Add Middleware**: Protect routes with authentication middleware\n6. **Implement RBAC**: Add role-based access control\n7. **Secure Tokens**: Store tokens securely (httpOnly cookies or secure storage)\n8. **Add OAuth**: Integrate third-party OAuth providers\n9. **Handle Logout**: Implement token revocation and cleanup\n10. **Add Security**: Implement rate limiting, CSRF protection, and other security measures\n\n## Examples\n\n### JWT Authentication (Node.js/Express)\n\n```typescript\n// src/config/auth.config.ts\nexport const authConfig = {\n  jwt: {\n    accessTokenSecret: process.env.JWT_ACCESS_SECRET!,\n    refreshTokenSecret: process.env.JWT_REFRESH_SECRET!,\n    accessTokenExpiry: '15m',\n    refreshTokenExpiry: '7d',\n  },\n  bcrypt: {\n    saltRounds: 12,\n  },\n  oauth: {\n    google: {\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      callbackUrl: process.env.GOOGLE_CALLBACK_URL!,\n    },\n  },\n};\n\n// src/types/auth.types.ts\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  password: string;\n  role: 'user' | 'admin' | 'moderator';\n  refreshTokens: string[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n}\n\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport interface LoginDTO {\n  email: string;\n  password: string;\n}\n\nexport interface RegisterDTO {\n  email: string;\n  name: string;\n  password: string;\n}\n\n// src/utils/password.util.ts\nimport bcrypt from 'bcrypt';\nimport { authConfig } from '../config/auth.config';\n\nexport class PasswordUtil {\n  static async hash(password: string): Promise<string> {\n    return bcrypt.hash(password, authConfig.bcrypt.saltRounds);\n  }\n\n  static async verify(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n  }\n\n  static validate(password: string): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (password.length < 8) {\n      errors.push('Password must be at least 8 characters');\n    }\n    if (!/[A-Z]/.test(password)) {\n      errors.push('Password must contain at least one uppercase letter');\n    }\n    if (!/[a-z]/.test(password)) {\n      errors.push('Password must contain at least one lowercase letter');\n    }\n    if (!/[0-9]/.test(password)) {\n      errors.push('Password must contain at least one number');\n    }\n    if (!/[!@#$%^&*]/.test(password)) {\n      errors.push('Password must contain at least one special character');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n// src/utils/jwt.util.ts\nimport jwt from 'jsonwebtoken';\nimport { authConfig } from '../config/auth.config';\nimport { JWTPayload } from '../types/auth.types';\n\nexport class JWTUtil {\n  static generateAccessToken(payload: JWTPayload): string {\n    return jwt.sign(payload, authConfig.jwt.accessTokenSecret, {\n      expiresIn: authConfig.jwt.accessTokenExpiry,\n    });\n  }\n\n  static generateRefreshToken(payload: JWTPayload): string {\n    return jwt.sign(payload, authConfig.jwt.refreshTokenSecret, {\n      expiresIn: authConfig.jwt.refreshTokenExpiry,\n    });\n  }\n\n  static verifyAccessToken(token: string): JWTPayload | null {\n    try {\n      return jwt.verify(token, authConfig.jwt.accessTokenSecret) as JWTPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  static verifyRefreshToken(token: string): JWTPayload | null {\n    try {\n      return jwt.verify(token, authConfig.jwt.refreshTokenSecret) as JWTPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  static decodeToken(token: string): JWTPayload | null {\n    try {\n      return jwt.decode(token) as JWTPayload;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\n// src/services/auth.service.ts\nimport { v4 as uuidv4 } from 'uuid';\nimport { User, LoginDTO, RegisterDTO, AuthTokens, JWTPayload } from '../types/auth.types';\nimport { PasswordUtil } from '../utils/password.util';\nimport { JWTUtil } from '../utils/jwt.util';\nimport { AppError } from '../middleware/errorHandler';\n\n// Mock database\nconst usersDb: Map<string, User> = new Map();\n\nexport class AuthService {\n  static async register(data: RegisterDTO): Promise<{ user: Omit<User, 'password'>; tokens: AuthTokens }> {\n    // Check if user exists\n    const existingUser = Array.from(usersDb.values()).find(u => u.email === data.email);\n    if (existingUser) {\n      throw new AppError('Email already registered', 409, 'EMAIL_EXISTS');\n    }\n\n    // Validate password\n    const passwordValidation = PasswordUtil.validate(data.password);\n    if (!passwordValidation.valid) {\n      throw new AppError(\n        'Password validation failed',\n        400,\n        'INVALID_PASSWORD',\n        passwordValidation.errors\n      );\n    }\n\n    // Hash password\n    const hashedPassword = await PasswordUtil.hash(data.password);\n\n    // Create user\n    const userId = uuidv4();\n    const user: User = {\n      id: userId,\n      email: data.email,\n      name: data.name,\n      password: hashedPassword,\n      role: 'user',\n      refreshTokens: [],\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    usersDb.set(userId, user);\n\n    // Generate tokens\n    const tokens = await this.generateTokensForUser(user);\n\n    // Store refresh token\n    user.refreshTokens.push(tokens.refreshToken);\n\n    const { password, ...userWithoutPassword } = user;\n    return { user: userWithoutPassword, tokens };\n  }\n\n  static async login(data: LoginDTO): Promise<{ user: Omit<User, 'password'>; tokens: AuthTokens }> {\n    // Find user\n    const user = Array.from(usersDb.values()).find(u => u.email === data.email);\n    if (!user) {\n      throw new AppError('Invalid credentials', 401, 'INVALID_CREDENTIALS');\n    }\n\n    // Verify password\n    const isPasswordValid = await PasswordUtil.verify(data.password, user.password);\n    if (!isPasswordValid) {\n      throw new AppError('Invalid credentials', 401, 'INVALID_CREDENTIALS');\n    }\n\n    // Generate tokens\n    const tokens = await this.generateTokensForUser(user);\n\n    // Store refresh token (with rotation - limit to 5 active tokens)\n    user.refreshTokens.push(tokens.refreshToken);\n    if (user.refreshTokens.length > 5) {\n      user.refreshTokens = user.refreshTokens.slice(-5);\n    }\n\n    const { password, ...userWithoutPassword } = user;\n    return { user: userWithoutPassword, tokens };\n  }\n\n  static async refreshTokens(refreshToken: string): Promise<AuthTokens> {\n    // Verify refresh token\n    const payload = JWTUtil.verifyRefreshToken(refreshToken);\n    if (!payload) {\n      throw new AppError('Invalid refresh token', 401, 'INVALID_TOKEN');\n    }\n\n    // Find user\n    const user = usersDb.get(payload.userId);\n    if (!user) {\n      throw new AppError('User not found', 404, 'USER_NOT_FOUND');\n    }\n\n    // Check if refresh token is valid\n    if (!user.refreshTokens.includes(refreshToken)) {\n      throw new AppError('Invalid refresh token', 401, 'INVALID_TOKEN');\n    }\n\n    // Generate new tokens\n    const tokens = await this.generateTokensForUser(user);\n\n    // Rotate refresh tokens\n    user.refreshTokens = user.refreshTokens.filter(t => t !== refreshToken);\n    user.refreshTokens.push(tokens.refreshToken);\n\n    return tokens;\n  }\n\n  static async logout(userId: string, refreshToken: string): Promise<void> {\n    const user = usersDb.get(userId);\n    if (!user) {\n      throw new AppError('User not found', 404, 'USER_NOT_FOUND');\n    }\n\n    // Remove refresh token\n    user.refreshTokens = user.refreshTokens.filter(t => t !== refreshToken);\n  }\n\n  static async logoutAll(userId: string): Promise<void> {\n    const user = usersDb.get(userId);\n    if (!user) {\n      throw new AppError('User not found', 404, 'USER_NOT_FOUND');\n    }\n\n    // Clear all refresh tokens\n    user.refreshTokens = [];\n  }\n\n  private static async generateTokensForUser(user: User): Promise<AuthTokens> {\n    const payload: JWTPayload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n    };\n\n    return {\n      accessToken: JWTUtil.generateAccessToken(payload),\n      refreshToken: JWTUtil.generateRefreshToken(payload),\n    };\n  }\n}\n\n// src/middleware/auth.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { JWTUtil } from '../utils/jwt.util';\nimport { AppError } from './errorHandler';\nimport { JWTPayload } from '../types/auth.types';\n\n// Extend Express Request type\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: JWTPayload;\n    }\n  }\n}\n\nexport const authenticate = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    // Get token from header\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      throw new AppError('No token provided', 401, 'NO_TOKEN');\n    }\n\n    const token = authHeader.substring(7);\n\n    // Verify token\n    const payload = JWTUtil.verifyAccessToken(token);\n    if (!payload) {\n      throw new AppError('Invalid or expired token', 401, 'INVALID_TOKEN');\n    }\n\n    // Attach user to request\n    req.user = payload;\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const authorize = (...roles: string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      throw new AppError('Unauthorized', 401, 'UNAUTHORIZED');\n    }\n\n    if (!roles.includes(req.user.role)) {\n      throw new AppError(\n        'Insufficient permissions',\n        403,\n        'FORBIDDEN',\n        { requiredRoles: roles, userRole: req.user.role }\n      );\n    }\n\n    next();\n  };\n};\n\n// Optional: Extract token from cookie\nexport const authenticateFromCookie = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const token = req.cookies?.accessToken;\n    \n    if (!token) {\n      throw new AppError('No token provided', 401, 'NO_TOKEN');\n    }\n\n    const payload = JWTUtil.verifyAccessToken(token);\n    if (!payload) {\n      throw new AppError('Invalid or expired token', 401, 'INVALID_TOKEN');\n    }\n\n    req.user = payload;\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n\n// src/controllers/auth.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AuthService } from '../services/auth.service';\nimport { LoginDTO, RegisterDTO } from '../types/auth.types';\n\nexport class AuthController {\n  static async register(\n    req: Request<{}, {}, RegisterDTO>,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      const result = await AuthService.register(req.body);\n\n      // Set refresh token as httpOnly cookie\n      res.cookie('refreshToken', result.tokens.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n      });\n\n      res.status(201).json({\n        success: true,\n        data: {\n          user: result.user,\n          accessToken: result.tokens.accessToken,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async login(\n    req: Request<{}, {}, LoginDTO>,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      const result = await AuthService.login(req.body);\n\n      // Set refresh token as httpOnly cookie\n      res.cookie('refreshToken', result.tokens.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000,\n      });\n\n      res.json({\n        success: true,\n        data: {\n          user: result.user,\n          accessToken: result.tokens.accessToken,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async refreshToken(\n    req: Request,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      const refreshToken = req.cookies?.refreshToken || req.body.refreshToken;\n\n      if (!refreshToken) {\n        throw new AppError('No refresh token provided', 401, 'NO_TOKEN');\n      }\n\n      const tokens = await AuthService.refreshTokens(refreshToken);\n\n      // Update refresh token cookie\n      res.cookie('refreshToken', tokens.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000,\n      });\n\n      res.json({\n        success: true,\n        data: {\n          accessToken: tokens.accessToken,\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async logout(\n    req: Request,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      const refreshToken = req.cookies?.refreshToken;\n      const userId = req.user?.userId;\n\n      if (userId && refreshToken) {\n        await AuthService.logout(userId, refreshToken);\n      }\n\n      res.clearCookie('refreshToken');\n\n      res.json({\n        success: true,\n        message: 'Logged out successfully',\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async logoutAll(\n    req: Request,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      const userId = req.user?.userId;\n\n      if (!userId) {\n        throw new AppError('Unauthorized', 401, 'UNAUTHORIZED');\n      }\n\n      await AuthService.logoutAll(userId);\n\n      res.clearCookie('refreshToken');\n\n      res.json({\n        success: true,\n        message: 'Logged out from all devices',\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async me(\n    req: Request,\n    res: Response,\n    next: NextFunction\n  ) {\n    try {\n      res.json({\n        success: true,\n        data: req.user,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\n// src/routes/auth.routes.ts\nimport { Router } from 'express';\nimport { AuthController } from '../controllers/auth.controller';\nimport { authenticate, authorize } from '../middleware/auth.middleware';\nimport { validate } from '../middleware/validation';\nimport { z } from 'zod';\n\nconst router = Router();\n\nconst registerSchema = z.object({\n  body: z.object({\n    email: z.string().email(),\n    name: z.string().min(2),\n    password: z.string().min(8),\n  }),\n});\n\nconst loginSchema = z.object({\n  body: z.object({\n    email: z.string().email(),\n    password: z.string(),\n  }),\n});\n\nrouter.post('/register', validate(registerSchema), AuthController.register);\nrouter.post('/login', validate(loginSchema), AuthController.login);\nrouter.post('/refresh', AuthController.refreshToken);\nrouter.post('/logout', authenticate, AuthController.logout);\nrouter.post('/logout-all', authenticate, AuthController.logoutAll);\nrouter.get('/me', authenticate, AuthController.me);\n\n// Protected route example\nrouter.get('/admin', authenticate, authorize('admin'), (req, res) => {\n  res.json({ message: 'Admin only route' });\n});\n\nexport default router;\n```\n\n### OAuth 2.0 Integration (Google)\n\n```typescript\n// src/services/oauth.service.ts\nimport { OAuth2Client } from 'google-auth-library';\nimport { authConfig } from '../config/auth.config';\nimport { v4 as uuidv4 } from 'uuid';\nimport { User } from '../types/auth.types';\nimport { AppError } from '../middleware/errorHandler';\n\nconst googleClient = new OAuth2Client(\n  authConfig.oauth.google.clientId,\n  authConfig.oauth.google.clientSecret,\n  authConfig.oauth.google.callbackUrl\n);\n\nexport class OAuthService {\n  static getGoogleAuthUrl(): string {\n    return googleClient.generateAuthUrl({\n      access_type: 'offline',\n      scope: [\n        'https://www.googleapis.com/auth/userinfo.profile',\n        'https://www.googleapis.com/auth/userinfo.email',\n      ],\n    });\n  }\n\n  static async handleGoogleCallback(code: string): Promise<User> {\n    try {\n      // Exchange code for tokens\n      const { tokens } = await googleClient.getToken(code);\n      googleClient.setCredentials(tokens);\n\n      // Get user info\n      const ticket = await googleClient.verifyIdToken({\n        idToken: tokens.id_token!,\n        audience: authConfig.oauth.google.clientId,\n      });\n\n      const payload = ticket.getPayload();\n      if (!payload) {\n        throw new AppError('Failed to get user info', 400, 'OAUTH_ERROR');\n      }\n\n      // Find or create user\n      const existingUser = Array.from(usersDb.values()).find(\n        u => u.email === payload.email\n      );\n\n      if (existingUser) {\n        return existingUser;\n      }\n\n      // Create new user\n      const userId = uuidv4();\n      const user: User = {\n        id: userId,\n        email: payload.email!,\n        name: payload.name || 'User',\n        password: '', // No password for OAuth users\n        role: 'user',\n        refreshTokens: [],\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      usersDb.set(userId, user);\n      return user;\n    } catch (error) {\n      throw new AppError('OAuth authentication failed', 400, 'OAUTH_ERROR');\n    }\n  }\n}\n\n// src/controllers/oauth.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { OAuthService } from '../services/oauth.service';\nimport { AuthService } from '../services/auth.service';\n\nexport class OAuthController {\n  static async googleAuth(req: Request, res: Response, next: NextFunction) {\n    try {\n      const authUrl = OAuthService.getGoogleAuthUrl();\n      res.redirect(authUrl);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  static async googleCallback(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { code } = req.query;\n\n      if (!code || typeof code !== 'string') {\n        throw new AppError('No authorization code', 400, 'INVALID_REQUEST');\n      }\n\n      const user = await OAuthService.handleGoogleCallback(code);\n      const tokens = await AuthService.generateTokensForUser(user);\n\n      // Set refresh token cookie\n      res.cookie('refreshToken', tokens.refreshToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'strict',\n        maxAge: 7 * 24 * 60 * 60 * 1000,\n      });\n\n      // Redirect to frontend with access token\n      res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${tokens.accessToken}`);\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\n// src/routes/oauth.routes.ts\nimport { Router } from 'express';\nimport { OAuthController } from '../controllers/oauth.controller';\n\nconst router = Router();\n\nrouter.get('/google', OAuthController.googleAuth);\nrouter.get('/google/callback', OAuthController.googleCallback);\n\nexport default router;\n```\n\n## Best Practices\n\n1. **Never store passwords in plain text**: Always hash with bcrypt (12+ rounds)\n2. **Use secure token storage**: httpOnly cookies or secure local storage\n3. **Implement token rotation**: Rotate refresh tokens on each use\n4. **Short-lived access tokens**: 15-30 minutes maximum\n5. **Longer refresh tokens**: 7-30 days with secure storage\n6. **Validate all inputs**: Check password strength, email format\n7. **Rate limit auth endpoints**: Prevent brute force attacks\n8. **Use HTTPS only**: Never send tokens over HTTP\n9. **Implement CSRF protection**: For cookie-based auth\n10. **Log security events**: Track failed logins, token refresh, etc.",
  "prompt": "A skill that provides complete authentication and authorization patterns with JWT, OAuth, sessions, password hashing, refresh tokens, and role-based access control with production-ready security best practices",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
