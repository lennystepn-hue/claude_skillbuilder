{
  "id": "ai-structured-output",
  "name": "structured-output",
  "description": "Extract structured data from LLM responses",
  "category": "AI",
  "content": "---\nname: structured-output\ndescription: Get structured data from LLMs\ncategory: AI\n---\n\n# Structured Output\n\n## Overview\nExtract reliable, validated structured data from LLM responses using schemas, function calling, and parsing.\n\n## Activation\nActivates when user mentions \"structured output\", \"JSON output\", \"extract data\", \"parse response\", \"function calling\", or \"schema validation\".\n\n## Instructions\n\n### Methods for Structured Output\n1. **Function Calling**: OpenAI/Anthropic native support\n2. **JSON Mode**: Force JSON response format\n3. **Pydantic + Instructor**: Type-safe extraction\n4. **Output Parsers**: LangChain parsers\n5. **XML Tags**: Claude-style structured responses\n\n## Examples\n\n**OpenAI Function Calling:**\n```python\nfrom openai import OpenAI\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nimport json\n\nclass ExtractedEntity(BaseModel):\n    name: str\n    type: str  # person, company, location\n    confidence: float\n\nclass ExtractionResult(BaseModel):\n    entities: List[ExtractedEntity]\n    summary: str\n    sentiment: str\n\ndef extract_structured(text: str) -> ExtractionResult:\n    client = OpenAI()\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": f\"Extract entities from: {text}\"}],\n        functions=[{\n            \"name\": \"extract_entities\",\n            \"description\": \"Extract named entities and analyze text\",\n            \"parameters\": ExtractionResult.model_json_schema()\n        }],\n        function_call={\"name\": \"extract_entities\"}\n    )\n    \n    result = json.loads(response.choices[0].message.function_call.arguments)\n    return ExtractionResult(**result)\n\n# Usage\nresult = extract_structured(\"Apple CEO Tim Cook announced new products in Cupertino.\")\nprint(result.entities)  # [{name: 'Tim Cook', type: 'person'}, ...]\n```\n\n**Using Instructor Library (Recommended):**\n```python\nimport instructor\nfrom openai import OpenAI\nfrom pydantic import BaseModel, Field\nfrom typing import List\nfrom enum import Enum\n\nclass Priority(str, Enum):\n    low = \"low\"\n    medium = \"medium\"\n    high = \"high\"\n    critical = \"critical\"\n\nclass Task(BaseModel):\n    title: str = Field(description=\"Short task title\")\n    description: str = Field(description=\"Detailed description\")\n    priority: Priority\n    estimated_hours: float = Field(ge=0, le=100)\n    dependencies: List[str] = Field(default_factory=list)\n\nclass ProjectPlan(BaseModel):\n    project_name: str\n    tasks: List[Task]\n    total_hours: float\n    risks: List[str]\n\n# Patch OpenAI client\nclient = instructor.from_openai(OpenAI())\n\ndef generate_project_plan(description: str) -> ProjectPlan:\n    return client.chat.completions.create(\n        model=\"gpt-4o\",\n        response_model=ProjectPlan,\n        messages=[{\n            \"role\": \"user\",\n            \"content\": f\"Create a detailed project plan for: {description}\"\n        }],\n        max_retries=3  # Auto-retry on validation errors\n    )\n\n# Usage\nplan = generate_project_plan(\"Build a REST API for a todo app\")\nfor task in plan.tasks:\n    print(f\"- [{task.priority}] {task.title}: {task.estimated_hours}h\")\n```\n\n**Anthropic Claude Structured Output:**\n```python\nimport anthropic\nimport json\nimport re\n\ndef extract_with_claude(text: str, schema: dict) -> dict:\n    client = anthropic.Anthropic()\n    \n    prompt = f\"\"\"Extract information from the following text.\n\nText: {text}\n\nRespond with ONLY a JSON object matching this schema:\n{json.dumps(schema, indent=2)}\n\nJSON Response:\"\"\"\n    \n    response = client.messages.create(\n        model=\"claude-sonnet-4-20250514\",\n        max_tokens=1024,\n        messages=[{\"role\": \"user\", \"content\": prompt}]\n    )\n    \n    # Extract JSON from response\n    content = response.content[0].text\n    json_match = re.search(r'\\{[\\s\\S]*\\}', content)\n    if json_match:\n        return json.loads(json_match.group())\n    raise ValueError(\"No valid JSON found in response\")\n\n# Usage\nschema = {\n    \"product_name\": \"string\",\n    \"price\": \"number\",\n    \"features\": [\"string\"],\n    \"in_stock\": \"boolean\"\n}\nresult = extract_with_claude(\"iPhone 15 Pro costs $999, has USB-C and titanium frame. Currently available.\", schema)\n```\n\n**Reliable JSON with Retry:**\n```python\nfrom tenacity import retry, stop_after_attempt, retry_if_exception_type\nimport json\n\nclass JSONParseError(Exception):\n    pass\n\n@retry(stop=stop_after_attempt(3), retry=retry_if_exception_type(JSONParseError))\ndef extract_json_reliable(prompt: str) -> dict:\n    client = OpenAI()\n    \n    response = client.chat.completions.create(\n        model=\"gpt-4o\",\n        messages=[{\"role\": \"user\", \"content\": prompt}],\n        response_format={\"type\": \"json_object\"}  # JSON mode\n    )\n    \n    try:\n        return json.loads(response.choices[0].message.content)\n    except json.JSONDecodeError as e:\n        raise JSONParseError(f\"Invalid JSON: {e}\")\n```",
  "prompt": "A skill for extracting structured data from LLMs",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
