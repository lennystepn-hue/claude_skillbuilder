{
  "id": "frontend-hooks",
  "name": "frontend-hooks",
  "description": "Custom React hooks library for common patterns including useDebounce, useLocalStorage, useAsync, useFetch, and advanced hook composition",
  "category": "Frontend",
  "content": "---\nname: frontend-hooks\ndescription: Custom React hooks library for common patterns including useDebounce, useLocalStorage, useAsync, useFetch, and advanced hook composition\ncategory: Frontend\n---\n\n# Custom React Hooks\n\n## Overview\n\nThis skill provides a comprehensive library of custom React hooks for common patterns and use cases. It includes hooks for state management, side effects, data fetching, form handling, performance optimization, and DOM interactions. Each hook is production-ready with proper TypeScript typing and error handling.\n\n## Activation\n\nUse this skill when:\n- Building reusable logic with React hooks\n- Implementing common patterns like debouncing, throttling, or local storage\n- Managing async operations and data fetching\n- Handling form state and validation\n- Working with DOM APIs (intersection observer, media queries, etc.)\n- Optimizing component performance\n- Managing component lifecycle and side effects\n\n## Instructions\n\n### Hook Design Principles\n\n1. **Single Responsibility**: Each hook should do one thing well\n2. **Composability**: Hooks should be composable to build complex functionality\n3. **Type Safety**: Use TypeScript for proper typing\n4. **Error Handling**: Handle edge cases and errors gracefully\n5. **Cleanup**: Always clean up side effects in useEffect\n6. **Testing**: Write tests for custom hooks using @testing-library/react-hooks\n\n### Best Practices\n\n1. Prefix custom hooks with \"use\" (e.g., useDebounce)\n2. Keep hooks pure and predictable\n3. Document hook parameters and return values\n4. Handle SSR compatibility when needed\n5. Memoize return values when appropriate\n\n## Examples\n\n### Example 1: State Management Hooks\n\n```typescript\n// useToggle.ts - Simple boolean toggle\nimport { useState, useCallback } from 'react';\n\ntype UseToggleReturn = [boolean, () => void, (value: boolean) => void];\n\nexport const useToggle = (initialValue = false): UseToggleReturn => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => {\n    setValue(v => !v);\n  }, []);\n\n  return [value, toggle, setValue];\n};\n\n// Usage\nconst App = () => {\n  const [isOpen, toggleOpen, setIsOpen] = useToggle(false);\n\n  return (\n    <div>\n      <button onClick={toggleOpen}>Toggle</button>\n      {isOpen && <Modal onClose={() => setIsOpen(false)} />}\n    </div>\n  );\n};\n\n// useCounter.ts - Enhanced counter with min/max\nimport { useState, useCallback } from 'react';\n\ninterface UseCounterOptions {\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\ninterface UseCounterReturn {\n  count: number;\n  increment: () => void;\n  decrement: () => void;\n  reset: () => void;\n  set: (value: number) => void;\n}\n\nexport const useCounter = (\n  initialValue = 0,\n  options: UseCounterOptions = {}\n): UseCounterReturn => {\n  const { min = -Infinity, max = Infinity, step = 1 } = options;\n  const [count, setCount] = useState(() => {\n    return Math.max(min, Math.min(max, initialValue));\n  });\n\n  const increment = useCallback(() => {\n    setCount(c => Math.min(max, c + step));\n  }, [max, step]);\n\n  const decrement = useCallback(() => {\n    setCount(c => Math.max(min, c - step));\n  }, [min, step]);\n\n  const reset = useCallback(() => {\n    setCount(initialValue);\n  }, [initialValue]);\n\n  const set = useCallback((value: number) => {\n    setCount(Math.max(min, Math.min(max, value)));\n  }, [min, max]);\n\n  return { count, increment, decrement, reset, set };\n};\n\n// useLocalStorage.ts - Persistent state in localStorage\nimport { useState, useEffect, useCallback } from 'react';\n\ntype SetValue<T> = (value: T | ((prev: T) => T)) => void;\n\nexport const useLocalStorage = <T>(\n  key: string,\n  initialValue: T\n): [T, SetValue<T>, () => void] => {\n  // Get from local storage then parse stored json or return initialValue\n  const readValue = useCallback((): T => {\n    if (typeof window === 'undefined') {\n      return initialValue;\n    }\n\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  }, [initialValue, key]);\n\n  const [storedValue, setStoredValue] = useState<T>(readValue);\n\n  const setValue: SetValue<T> = useCallback((value) => {\n    if (typeof window === 'undefined') {\n      console.warn(`Tried setting localStorage key \"${key}\" in SSR`);\n      return;\n    }\n\n    try {\n      const newValue = value instanceof Function ? value(storedValue) : value;\n      window.localStorage.setItem(key, JSON.stringify(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new Event('local-storage'));\n    } catch (error) {\n      console.warn(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  const removeValue = useCallback(() => {\n    if (typeof window === 'undefined') return;\n    \n    try {\n      window.localStorage.removeItem(key);\n      setStoredValue(initialValue);\n      window.dispatchEvent(new Event('local-storage'));\n    } catch (error) {\n      console.warn(`Error removing localStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n\n  // Sync state across tabs\n  useEffect(() => {\n    const handleStorageChange = () => {\n      setStoredValue(readValue());\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    window.addEventListener('local-storage', handleStorageChange);\n\n    return () => {\n      window.removeEventListener('storage', handleStorageChange);\n      window.removeEventListener('local-storage', handleStorageChange);\n    };\n  }, [readValue]);\n\n  return [storedValue, setValue, removeValue];\n};\n```\n\n### Example 2: Performance Optimization Hooks\n\n```typescript\n// useDebounce.ts - Debounce value changes\nimport { useState, useEffect } from 'react';\n\nexport const useDebounce = <T>(value: T, delay: number): T => {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n};\n\n// Usage\nconst SearchComponent = () => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const debouncedSearch = useDebounce(searchTerm, 500);\n\n  useEffect(() => {\n    if (debouncedSearch) {\n      // Perform API call\n      searchAPI(debouncedSearch);\n    }\n  }, [debouncedSearch]);\n\n  return (\n    <input\n      type=\"text\"\n      value={searchTerm}\n      onChange={(e) => setSearchTerm(e.target.value)}\n      placeholder=\"Search...\"\n    />\n  );\n};\n\n// useThrottle.ts - Throttle value changes\nimport { useState, useEffect, useRef } from 'react';\n\nexport const useThrottle = <T>(value: T, interval: number): T => {\n  const [throttledValue, setThrottledValue] = useState<T>(value);\n  const lastUpdated = useRef<number>(Date.now());\n\n  useEffect(() => {\n    const now = Date.now();\n    const timeSinceLastUpdate = now - lastUpdated.current;\n\n    if (timeSinceLastUpdate >= interval) {\n      lastUpdated.current = now;\n      setThrottledValue(value);\n    } else {\n      const timer = setTimeout(() => {\n        lastUpdated.current = Date.now();\n        setThrottledValue(value);\n      }, interval - timeSinceLastUpdate);\n\n      return () => clearTimeout(timer);\n    }\n  }, [value, interval]);\n\n  return throttledValue;\n};\n\n// useMemoCompare.ts - Memoize with custom comparison\nimport { useRef, useEffect } from 'react';\n\ntype CompareFn<T> = (prev: T | undefined, next: T) => boolean;\n\nexport const useMemoCompare = <T>(\n  next: T,\n  compare: CompareFn<T>\n): T | undefined => {\n  const previousRef = useRef<T>();\n  const previous = previousRef.current;\n\n  const isEqual = compare(previous, next);\n\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = next;\n    }\n  });\n\n  return isEqual ? previous : next;\n};\n\n// Usage - deep comparison for objects\nimport isEqual from 'lodash/isEqual';\n\nconst useDeepEffect = (callback: () => void, dependencies: any[]) => {\n  const memoizedDeps = useMemoCompare(dependencies, (prev, next) => {\n    return prev ? isEqual(prev, next) : false;\n  });\n\n  useEffect(callback, [memoizedDeps]);\n};\n```\n\n### Example 3: Async and Data Fetching Hooks\n\n```typescript\n// useAsync.ts - Generic async operation handler\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface AsyncState<T> {\n  status: 'idle' | 'pending' | 'success' | 'error';\n  data: T | null;\n  error: Error | null;\n}\n\ninterface UseAsyncReturn<T> extends AsyncState<T> {\n  execute: () => Promise<void>;\n  reset: () => void;\n}\n\nexport const useAsync = <T>(\n  asyncFunction: () => Promise<T>,\n  immediate = true\n): UseAsyncReturn<T> => {\n  const [state, setState] = useState<AsyncState<T>>({\n    status: 'idle',\n    data: null,\n    error: null\n  });\n\n  const execute = useCallback(async () => {\n    setState({ status: 'pending', data: null, error: null });\n\n    try {\n      const data = await asyncFunction();\n      setState({ status: 'success', data, error: null });\n    } catch (error) {\n      setState({ \n        status: 'error', \n        data: null, \n        error: error as Error \n      });\n    }\n  }, [asyncFunction]);\n\n  const reset = useCallback(() => {\n    setState({ status: 'idle', data: null, error: null });\n  }, []);\n\n  useEffect(() => {\n    if (immediate) {\n      execute();\n    }\n  }, [execute, immediate]);\n\n  return { ...state, execute, reset };\n};\n\n// useFetch.ts - Fetch data with caching\nimport { useState, useEffect, useRef } from 'react';\n\ninterface FetchState<T> {\n  data: T | null;\n  isLoading: boolean;\n  error: Error | null;\n}\n\ninterface UseFetchOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  headers?: HeadersInit;\n  body?: BodyInit;\n}\n\nconst cache = new Map<string, any>();\n\nexport const useFetch = <T>(\n  url: string,\n  options: UseFetchOptions = {}\n): FetchState<T> & { refetch: () => void } => {\n  const [state, setState] = useState<FetchState<T>>({\n    data: null,\n    isLoading: true,\n    error: null\n  });\n\n  const abortControllerRef = useRef<AbortController>();\n\n  const fetchData = useCallback(async () => {\n    // Check cache first\n    const cacheKey = `${url}-${JSON.stringify(options)}`;\n    if (cache.has(cacheKey)) {\n      setState({\n        data: cache.get(cacheKey),\n        isLoading: false,\n        error: null\n      });\n      return;\n    }\n\n    // Cancel previous request\n    abortControllerRef.current?.abort();\n    abortControllerRef.current = new AbortController();\n\n    setState(prev => ({ ...prev, isLoading: true }));\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: abortControllerRef.current.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      cache.set(cacheKey, data);\n\n      setState({ data, isLoading: false, error: null });\n    } catch (error) {\n      if ((error as Error).name === 'AbortError') {\n        return;\n      }\n      setState({ data: null, isLoading: false, error: error as Error });\n    }\n  }, [url, options]);\n\n  useEffect(() => {\n    fetchData();\n\n    return () => {\n      abortControllerRef.current?.abort();\n    };\n  }, [fetchData]);\n\n  return { ...state, refetch: fetchData };\n};\n\n// Usage\nconst UserProfile = ({ userId }: { userId: string }) => {\n  const { data, isLoading, error, refetch } = useFetch<User>(\n    `/api/users/${userId}`\n  );\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data) return null;\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n      <button onClick={refetch}>Refresh</button>\n    </div>\n  );\n};\n```\n\n### Example 4: Form Handling Hooks\n\n```typescript\n// useForm.ts - Comprehensive form management\nimport { useState, useCallback, ChangeEvent, FormEvent } from 'react';\n\ntype ValidationRule<T> = {\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  custom?: (value: T[keyof T]) => string | null;\n};\n\ntype ValidationRules<T> = {\n  [K in keyof T]?: ValidationRule<T>;\n};\n\ntype Errors<T> = {\n  [K in keyof T]?: string;\n};\n\ninterface UseFormReturn<T> {\n  values: T;\n  errors: Errors<T>;\n  touched: { [K in keyof T]?: boolean };\n  isValid: boolean;\n  handleChange: (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;\n  handleBlur: (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;\n  handleSubmit: (onSubmit: (values: T) => void) => (e: FormEvent) => void;\n  setValue: <K extends keyof T>(field: K, value: T[K]) => void;\n  reset: () => void;\n}\n\nexport const useForm = <T extends Record<string, any>>(\n  initialValues: T,\n  validationRules?: ValidationRules<T>\n): UseFormReturn<T> => {\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<Errors<T>>({});\n  const [touched, setTouched] = useState<{ [K in keyof T]?: boolean }>({});\n\n  const validate = useCallback((name: keyof T, value: any): string | null => {\n    const rules = validationRules?.[name];\n    if (!rules) return null;\n\n    if (rules.required && !value) {\n      return 'This field is required';\n    }\n\n    if (rules.minLength && value.length < rules.minLength) {\n      return `Minimum length is ${rules.minLength}`;\n    }\n\n    if (rules.maxLength && value.length > rules.maxLength) {\n      return `Maximum length is ${rules.maxLength}`;\n    }\n\n    if (rules.pattern && !rules.pattern.test(value)) {\n      return 'Invalid format';\n    }\n\n    if (rules.custom) {\n      return rules.custom(value);\n    }\n\n    return null;\n  }, [validationRules]);\n\n  const handleChange = useCallback((e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n\n    // Validate on change if field has been touched\n    if (touched[name as keyof T]) {\n      const error = validate(name as keyof T, value);\n      setErrors(prev => ({ ...prev, [name]: error || undefined }));\n    }\n  }, [touched, validate]);\n\n  const handleBlur = useCallback((e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {\n    const { name, value } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n\n    const error = validate(name as keyof T, value);\n    setErrors(prev => ({ ...prev, [name]: error || undefined }));\n  }, [validate]);\n\n  const handleSubmit = useCallback((onSubmit: (values: T) => void) => {\n    return (e: FormEvent) => {\n      e.preventDefault();\n\n      // Validate all fields\n      const newErrors: Errors<T> = {};\n      let isValid = true;\n\n      Object.keys(values).forEach(key => {\n        const error = validate(key as keyof T, values[key]);\n        if (error) {\n          newErrors[key as keyof T] = error;\n          isValid = false;\n        }\n      });\n\n      setErrors(newErrors);\n      setTouched(Object.keys(values).reduce((acc, key) => ({ ...acc, [key]: true }), {}));\n\n      if (isValid) {\n        onSubmit(values);\n      }\n    };\n  }, [values, validate]);\n\n  const setValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {\n    setValues(prev => ({ ...prev, [field]: value }));\n  }, []);\n\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n  }, [initialValues]);\n\n  const isValid = Object.keys(errors).length === 0;\n\n  return {\n    values,\n    errors,\n    touched,\n    isValid,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    setValue,\n    reset\n  };\n};\n\n// Usage\ninterface LoginFormValues {\n  email: string;\n  password: string;\n}\n\nconst LoginForm = () => {\n  const { values, errors, touched, handleChange, handleBlur, handleSubmit } = \n    useForm<LoginFormValues>(\n      { email: '', password: '' },\n      {\n        email: {\n          required: true,\n          pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n        },\n        password: {\n          required: true,\n          minLength: 8,\n        }\n      }\n    );\n\n  const onSubmit = (values: LoginFormValues) => {\n    console.log('Form submitted:', values);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <input\n          name=\"email\"\n          type=\"email\"\n          value={values.email}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.email && errors.email && <span>{errors.email}</span>}\n      </div>\n      <div>\n        <input\n          name=\"password\"\n          type=\"password\"\n          value={values.password}\n          onChange={handleChange}\n          onBlur={handleBlur}\n        />\n        {touched.password && errors.password && <span>{errors.password}</span>}\n      </div>\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n};\n```\n\n### Example 5: DOM and Browser API Hooks\n\n```typescript\n// useIntersectionObserver.ts - Detect element visibility\nimport { useEffect, useState, RefObject } from 'react';\n\ninterface UseIntersectionObserverOptions extends IntersectionObserverInit {\n  freezeOnceVisible?: boolean;\n}\n\nexport const useIntersectionObserver = (\n  elementRef: RefObject<Element>,\n  options: UseIntersectionObserverOptions = {}\n): IntersectionObserverEntry | undefined => {\n  const { threshold = 0, root = null, rootMargin = '0%', freezeOnceVisible = false } = options;\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const frozen = entry?.isIntersecting && freezeOnceVisible;\n\n  useEffect(() => {\n    const node = elementRef?.current;\n    const hasIOSupport = !!window.IntersectionObserver;\n\n    if (!hasIOSupport || frozen || !node) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => setEntry(entry),\n      { threshold, root, rootMargin }\n    );\n\n    observer.observe(node);\n\n    return () => observer.disconnect();\n  }, [elementRef, threshold, root, rootMargin, frozen]);\n\n  return entry;\n};\n\n// Usage - Lazy load images\nconst LazyImage = ({ src, alt }: { src: string; alt: string }) => {\n  const ref = useRef<HTMLImageElement>(null);\n  const entry = useIntersectionObserver(ref, { freezeOnceVisible: true });\n  const isVisible = !!entry?.isIntersecting;\n\n  return (\n    <img\n      ref={ref}\n      src={isVisible ? src : undefined}\n      alt={alt}\n    />\n  );\n};\n\n// useMediaQuery.ts - Responsive design hook\nimport { useState, useEffect } from 'react';\n\nexport const useMediaQuery = (query: string): boolean => {\n  const [matches, setMatches] = useState(() => {\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia(query);\n    \n    const handler = (event: MediaQueryListEvent) => {\n      setMatches(event.matches);\n    };\n\n    mediaQuery.addEventListener('change', handler);\n    \n    return () => mediaQuery.removeEventListener('change', handler);\n  }, [query]);\n\n  return matches;\n};\n\n// Usage\nconst ResponsiveComponent = () => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');\n  const isDesktop = useMediaQuery('(min-width: 1025px)');\n  const isDarkMode = useMediaQuery('(prefers-color-scheme: dark)');\n\n  return (\n    <div>\n      {isMobile && <MobileView />}\n      {isTablet && <TabletView />}\n      {isDesktop && <DesktopView />}\n      <p>Theme: {isDarkMode ? 'Dark' : 'Light'}</p>\n    </div>\n  );\n};\n\n// useWindowSize.ts - Track window dimensions\nimport { useState, useEffect } from 'react';\n\ninterface WindowSize {\n  width: number;\n  height: number;\n}\n\nexport const useWindowSize = (): WindowSize => {\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: typeof window !== 'undefined' ? window.innerWidth : 0,\n    height: typeof window !== 'undefined' ? window.innerHeight : 0,\n  });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return windowSize;\n};\n\n// useClickOutside.ts - Detect clicks outside element\nimport { useEffect, RefObject } from 'react';\n\nexport const useClickOutside = <T extends HTMLElement>(\n  ref: RefObject<T>,\n  handler: (event: MouseEvent | TouchEvent) => void\n): void => {\n  useEffect(() => {\n    const listener = (event: MouseEvent | TouchEvent) => {\n      const el = ref?.current;\n      if (!el || el.contains(event.target as Node)) {\n        return;\n      }\n      handler(event);\n    };\n\n    document.addEventListener('mousedown', listener);\n    document.addEventListener('touchstart', listener);\n\n    return () => {\n      document.removeEventListener('mousedown', listener);\n      document.removeEventListener('touchstart', listener);\n    };\n  }, [ref, handler]);\n};\n\n// Usage - Close dropdown when clicking outside\nconst Dropdown = () => {\n  const [isOpen, setIsOpen] = useState(false);\n  const dropdownRef = useRef<HTMLDivElement>(null);\n\n  useClickOutside(dropdownRef, () => setIsOpen(false));\n\n  return (\n    <div ref={dropdownRef}>\n      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>\n      {isOpen && <div className=\"dropdown-menu\">Menu content</div>}\n    </div>\n  );\n};\n```\n\n### Example 6: Advanced Lifecycle Hooks\n\n```typescript\n// usePrevious.ts - Track previous value\nimport { useRef, useEffect } from 'react';\n\nexport const usePrevious = <T>(value: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n};\n\n// Usage\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  const previousCount = usePrevious(count);\n\n  return (\n    <div>\n      <p>Current: {count}</p>\n      <p>Previous: {previousCount}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\n// useMount.ts - Run effect only on mount\nimport { useEffect } from 'react';\n\nexport const useMount = (callback: () => void): void => {\n  useEffect(() => {\n    callback();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\n\n// useUnmount.ts - Run effect only on unmount\nimport { useEffect, useRef } from 'react';\n\nexport const useUnmount = (callback: () => void): void => {\n  const callbackRef = useRef(callback);\n  callbackRef.current = callback;\n\n  useEffect(() => {\n    return () => callbackRef.current();\n  }, []);\n};\n\n// useInterval.ts - Declarative interval\nimport { useEffect, useRef } from 'react';\n\nexport const useInterval = (callback: () => void, delay: number | null): void => {\n  const savedCallback = useRef<() => void>();\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    if (delay === null) return;\n\n    const tick = () => savedCallback.current?.();\n    const id = setInterval(tick, delay);\n\n    return () => clearInterval(id);\n  }, [delay]);\n};\n\n// Usage\nconst Timer = () => {\n  const [count, setCount] = useState(0);\n  const [isRunning, setIsRunning] = useState(true);\n\n  useInterval(\n    () => setCount(count + 1),\n    isRunning ? 1000 : null\n  );\n\n  return (\n    <div>\n      <p>Time: {count}s</p>\n      <button onClick={() => setIsRunning(!isRunning)}>\n        {isRunning ? 'Pause' : 'Start'}\n      </button>\n    </div>\n  );\n};\n\n// useUpdateEffect.ts - Skip effect on mount\nimport { useEffect, useRef } from 'react';\n\nexport const useUpdateEffect = (\n  effect: React.EffectCallback,\n  deps?: React.DependencyList\n): void => {\n  const isFirstMount = useRef(true);\n\n  useEffect(() => {\n    if (isFirstMount.current) {\n      isFirstMount.current = false;\n      return;\n    }\n\n    return effect();\n  }, deps);\n};\n```\n\n### Example 7: Utility Hooks\n\n```typescript\n// useCopyToClipboard.ts - Copy text to clipboard\nimport { useState, useCallback } from 'react';\n\ntype CopyFn = (text: string) => Promise<boolean>;\n\nexport const useCopyToClipboard = (): [boolean, CopyFn] => {\n  const [isCopied, setIsCopied] = useState(false);\n\n  const copy: CopyFn = useCallback(async (text) => {\n    if (!navigator?.clipboard) {\n      console.warn('Clipboard not supported');\n      return false;\n    }\n\n    try {\n      await navigator.clipboard.writeText(text);\n      setIsCopied(true);\n      setTimeout(() => setIsCopied(false), 2000);\n      return true;\n    } catch (error) {\n      console.warn('Copy failed', error);\n      setIsCopied(false);\n      return false;\n    }\n  }, []);\n\n  return [isCopied, copy];\n};\n\n// Usage\nconst CopyButton = ({ text }: { text: string }) => {\n  const [isCopied, copy] = useCopyToClipboard();\n\n  return (\n    <button onClick={() => copy(text)}>\n      {isCopied ? 'Copied!' : 'Copy'}\n    </button>\n  );\n};\n\n// useIdle.ts - Detect user inactivity\nimport { useState, useEffect } from 'react';\n\nexport const useIdle = (timeout: number = 5000): boolean => {\n  const [isIdle, setIsIdle] = useState(false);\n\n  useEffect(() => {\n    let timer: NodeJS.Timeout;\n\n    const handleActivity = () => {\n      setIsIdle(false);\n      clearTimeout(timer);\n      timer = setTimeout(() => setIsIdle(true), timeout);\n    };\n\n    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];\n    \n    events.forEach(event => {\n      document.addEventListener(event, handleActivity);\n    });\n\n    timer = setTimeout(() => setIsIdle(true), timeout);\n\n    return () => {\n      events.forEach(event => {\n        document.removeEventListener(event, handleActivity);\n      });\n      clearTimeout(timer);\n    };\n  }, [timeout]);\n\n  return isIdle;\n};\n\n// useOnlineStatus.ts - Detect online/offline status\nimport { useState, useEffect } from 'react';\n\nexport const useOnlineStatus = (): boolean => {\n  const [isOnline, setIsOnline] = useState(\n    typeof navigator !== 'undefined' ? navigator.onLine : true\n  );\n\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  return isOnline;\n};\n\n// useDocumentTitle.ts - Update document title\nimport { useRef, useEffect } from 'react';\n\nexport const useDocumentTitle = (title: string, retainOnUnmount = false): void => {\n  const defaultTitle = useRef(document.title);\n\n  useEffect(() => {\n    document.title = title;\n  }, [title]);\n\n  useEffect(() => {\n    return () => {\n      if (!retainOnUnmount) {\n        document.title = defaultTitle.current;\n      }\n    };\n  }, [retainOnUnmount]);\n};\n```\n\n## Hook Composition Examples\n\n```typescript\n// Combine multiple hooks for complex functionality\nimport { useEffect, useState } from 'react';\nimport { useDebounce } from './useDebounce';\nimport { useFetch } from './useFetch';\nimport { useLocalStorage } from './useLocalStorage';\n\n// Complex search with debounce, caching, and persistence\nconst useSearch = (initialQuery = '') => {\n  const [query, setQuery] = useLocalStorage('searchQuery', initialQuery);\n  const debouncedQuery = useDebounce(query, 500);\n  const { data, isLoading, error } = useFetch(\n    `/api/search?q=${encodeURIComponent(debouncedQuery)}`\n  );\n\n  return { query, setQuery, results: data, isLoading, error };\n};\n\n// Usage\nconst SearchPage = () => {\n  const { query, setQuery, results, isLoading } = useSearch();\n\n  return (\n    <div>\n      <input value={query} onChange={(e) => setQuery(e.target.value)} />\n      {isLoading && <div>Searching...</div>}\n      {results?.map(result => <div key={result.id}>{result.title}</div>)}\n    </div>\n  );\n};\n```\n\nThis skill provides a comprehensive, production-ready library of custom React hooks for common use cases.",
  "prompt": "A skill that provides a comprehensive library of production-ready custom React hooks for common patterns including state management, performance optimization, async operations, form handling, DOM interactions, and advanced lifecycle management with proper TypeScript typing.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
