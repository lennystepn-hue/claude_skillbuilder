{
  "id": "frontend-forms",
  "name": "Form Master",
  "description": "Form handling with React Hook Form, Zod validation, error states, and best practices for building robust forms",
  "category": "Frontend",
  "content": "---\nname: Form Master\ndescription: Form handling with React Hook Form, Zod validation, error states, and best practices for building robust forms\ncategory: Frontend\n---\n\n# Form Master\n\n## Overview\n\nThis skill provides expert guidance on form handling in React, including React Hook Form integration, Zod schema validation, error handling, field types, form patterns, and accessibility. It helps you build performant, type-safe forms with excellent UX.\n\n## Activation\n\nUse this skill when:\n- Building forms in React applications\n- Implementing form validation\n- Handling form submission and errors\n- Creating multi-step forms\n- Building dynamic form fields\n- Integrating with backend APIs\n- Ensuring form accessibility\n\n## Instructions\n\n### 1. React Hook Form Setup\n\n**Installation:**\n```bash\nnpm install react-hook-form zod @hookform/resolvers\n```\n\n**Basic Form:**\n```jsx\nimport { useForm } from 'react-hook-form';\n\nfunction BasicForm() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm();\n\n  const onSubmit = async (data) => {\n    console.log(data);\n    // API call\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input\n          id=\"name\"\n          {...register('name', { required: 'Name is required' })}\n        />\n        {errors.name && <span className=\"error\">{errors.name.message}</span>}\n      </div>\n\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          {...register('email', {\n            required: 'Email is required',\n            pattern: {\n              value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i,\n              message: 'Invalid email address',\n            },\n          })}\n        />\n        {errors.email && <span className=\"error\">{errors.email.message}</span>}\n      </div>\n\n      <button type=\"submit\" disabled={isSubmitting}>\n        {isSubmitting ? 'Submitting...' : 'Submit'}\n      </button>\n    </form>\n  );\n}\n```\n\n### 2. Zod Schema Validation\n\n**Define Schema:**\n```tsx\nimport { z } from 'zod';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useForm } from 'react-hook-form';\n\n// Schema definition\nconst formSchema = z.object({\n  username: z\n    .string()\n    .min(3, 'Username must be at least 3 characters')\n    .max(20, 'Username must be less than 20 characters')\n    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),\n  \n  email: z\n    .string()\n    .email('Invalid email address'),\n  \n  password: z\n    .string()\n    .min(8, 'Password must be at least 8 characters')\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\n    .regex(/[0-9]/, 'Password must contain at least one number')\n    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),\n  \n  confirmPassword: z.string(),\n  \n  age: z\n    .number()\n    .min(18, 'Must be at least 18 years old')\n    .max(120, 'Invalid age'),\n  \n  website: z\n    .string()\n    .url('Invalid URL')\n    .optional()\n    .or(z.literal('')),\n  \n  bio: z\n    .string()\n    .max(500, 'Bio must be less than 500 characters')\n    .optional(),\n  \n  acceptTerms: z\n    .boolean()\n    .refine((val) => val === true, 'You must accept the terms and conditions'),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: \"Passwords don't match\",\n  path: ['confirmPassword'],\n});\n\ntype FormData = z.infer<typeof formSchema>;\n\nfunction RegistrationForm() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm<FormData>({\n    resolver: zodResolver(formSchema),\n  });\n\n  const onSubmit = async (data: FormData) => {\n    try {\n      const response = await fetch('/api/register', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n      });\n      \n      if (!response.ok) throw new Error('Registration failed');\n      \n      // Success handling\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* Form fields */}\n    </form>\n  );\n}\n```\n\n**Complex Validation Schemas:**\n```tsx\n// Nested objects\nconst addressSchema = z.object({\n  street: z.string().min(1, 'Street is required'),\n  city: z.string().min(1, 'City is required'),\n  state: z.string().length(2, 'State must be 2 characters'),\n  zipCode: z.string().regex(/^\\d{5}$/, 'Invalid ZIP code'),\n});\n\nconst userSchema = z.object({\n  name: z.string(),\n  address: addressSchema,\n});\n\n// Arrays\nconst tagsSchema = z.array(z.string()).min(1, 'At least one tag is required');\n\nconst formSchema = z.object({\n  title: z.string(),\n  tags: tagsSchema,\n});\n\n// Conditional validation\nconst conditionalSchema = z.object({\n  accountType: z.enum(['personal', 'business']),\n  companyName: z.string().optional(),\n}).refine(\n  (data) => {\n    if (data.accountType === 'business') {\n      return !!data.companyName;\n    }\n    return true;\n  },\n  {\n    message: 'Company name is required for business accounts',\n    path: ['companyName'],\n  }\n);\n\n// Union types\nconst paymentSchema = z.discriminatedUnion('method', [\n  z.object({\n    method: z.literal('card'),\n    cardNumber: z.string(),\n    expiryDate: z.string(),\n  }),\n  z.object({\n    method: z.literal('paypal'),\n    email: z.string().email(),\n  }),\n]);\n```\n\n### 3. Form Field Components\n\n**Reusable Input Component:**\n```tsx\nimport { forwardRef } from 'react';\nimport { FieldError } from 'react-hook-form';\n\ninterface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  label: string;\n  error?: FieldError;\n}\n\nconst Input = forwardRef<HTMLInputElement, InputProps>(\n  ({ label, error, ...props }, ref) => {\n    return (\n      <div className=\"form-group\">\n        <label htmlFor={props.id || props.name}>\n          {label}\n          {props.required && <span className=\"required\">*</span>}\n        </label>\n        <input\n          ref={ref}\n          className={error ? 'input-error' : ''}\n          aria-invalid={error ? 'true' : 'false'}\n          aria-describedby={error ? `${props.name}-error` : undefined}\n          {...props}\n        />\n        {error && (\n          <span id={`${props.name}-error`} className=\"error\" role=\"alert\">\n            {error.message}\n          </span>\n        )}\n      </div>\n    );\n  }\n);\n\n// Usage\nfunction MyForm() {\n  const { register, formState: { errors } } = useForm();\n  \n  return (\n    <form>\n      <Input\n        label=\"Email\"\n        type=\"email\"\n        {...register('email')}\n        error={errors.email}\n      />\n    </form>\n  );\n}\n```\n\n**Select Component:**\n```tsx\ninterface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement> {\n  label: string;\n  options: { value: string; label: string }[];\n  error?: FieldError;\n}\n\nconst Select = forwardRef<HTMLSelectElement, SelectProps>(\n  ({ label, options, error, ...props }, ref) => {\n    return (\n      <div className=\"form-group\">\n        <label htmlFor={props.id || props.name}>{label}</label>\n        <select\n          ref={ref}\n          className={error ? 'select-error' : ''}\n          {...props}\n        >\n          <option value=\"\">Select an option</option>\n          {options.map((option) => (\n            <option key={option.value} value={option.value}>\n              {option.label}\n            </option>\n          ))}\n        </select>\n        {error && <span className=\"error\">{error.message}</span>}\n      </div>\n    );\n  }\n);\n```\n\n**Checkbox Component:**\n```tsx\ninterface CheckboxProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  label: string;\n  error?: FieldError;\n}\n\nconst Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(\n  ({ label, error, ...props }, ref) => {\n    return (\n      <div className=\"checkbox-group\">\n        <label>\n          <input\n            ref={ref}\n            type=\"checkbox\"\n            {...props}\n          />\n          <span>{label}</span>\n        </label>\n        {error && <span className=\"error\">{error.message}</span>}\n      </div>\n    );\n  }\n);\n```\n\n### 4. Advanced Form Patterns\n\n**Multi-Step Form:**\n```tsx\nconst step1Schema = z.object({\n  firstName: z.string().min(1, 'First name is required'),\n  lastName: z.string().min(1, 'Last name is required'),\n  email: z.string().email(),\n});\n\nconst step2Schema = z.object({\n  address: z.string().min(1, 'Address is required'),\n  city: z.string().min(1, 'City is required'),\n  zipCode: z.string().regex(/^\\d{5}$/),\n});\n\nconst step3Schema = z.object({\n  cardNumber: z.string().regex(/^\\d{16}$/),\n  expiryDate: z.string().regex(/^\\d{2}\\/\\d{2}$/),\n  cvv: z.string().regex(/^\\d{3}$/),\n});\n\ntype Step1Data = z.infer<typeof step1Schema>;\ntype Step2Data = z.infer<typeof step2Schema>;\ntype Step3Data = z.infer<typeof step3Schema>;\ntype FormData = Step1Data & Step2Data & Step3Data;\n\nfunction MultiStepForm() {\n  const [step, setStep] = useState(1);\n  const [formData, setFormData] = useState<Partial<FormData>>({});\n\n  const step1Form = useForm<Step1Data>({\n    resolver: zodResolver(step1Schema),\n    defaultValues: formData,\n  });\n\n  const step2Form = useForm<Step2Data>({\n    resolver: zodResolver(step2Schema),\n    defaultValues: formData,\n  });\n\n  const step3Form = useForm<Step3Data>({\n    resolver: zodResolver(step3Schema),\n    defaultValues: formData,\n  });\n\n  const onStep1Submit = (data: Step1Data) => {\n    setFormData((prev) => ({ ...prev, ...data }));\n    setStep(2);\n  };\n\n  const onStep2Submit = (data: Step2Data) => {\n    setFormData((prev) => ({ ...prev, ...data }));\n    setStep(3);\n  };\n\n  const onStep3Submit = async (data: Step3Data) => {\n    const finalData = { ...formData, ...data };\n    // Submit to API\n  };\n\n  return (\n    <div>\n      <ProgressBar currentStep={step} totalSteps={3} />\n      \n      {step === 1 && (\n        <form onSubmit={step1Form.handleSubmit(onStep1Submit)}>\n          {/* Step 1 fields */}\n          <button type=\"submit\">Next</button>\n        </form>\n      )}\n\n      {step === 2 && (\n        <form onSubmit={step2Form.handleSubmit(onStep2Submit)}>\n          {/* Step 2 fields */}\n          <button type=\"button\" onClick={() => setStep(1)}>Back</button>\n          <button type=\"submit\">Next</button>\n        </form>\n      )}\n\n      {step === 3 && (\n        <form onSubmit={step3Form.handleSubmit(onStep3Submit)}>\n          {/* Step 3 fields */}\n          <button type=\"button\" onClick={() => setStep(2)}>Back</button>\n          <button type=\"submit\">Submit</button>\n        </form>\n      )}\n    </div>\n  );\n}\n```\n\n**Dynamic Form Fields:**\n```tsx\nimport { useFieldArray } from 'react-hook-form';\n\nconst schema = z.object({\n  items: z.array(\n    z.object({\n      name: z.string().min(1, 'Name is required'),\n      quantity: z.number().min(1),\n      price: z.number().min(0),\n    })\n  ).min(1, 'At least one item is required'),\n});\n\ntype FormData = z.infer<typeof schema>;\n\nfunction DynamicForm() {\n  const { register, control, handleSubmit, formState: { errors } } = useForm<FormData>({\n    resolver: zodResolver(schema),\n    defaultValues: {\n      items: [{ name: '', quantity: 1, price: 0 }],\n    },\n  });\n\n  const { fields, append, remove } = useFieldArray({\n    control,\n    name: 'items',\n  });\n\n  const onSubmit = (data: FormData) => {\n    console.log(data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {fields.map((field, index) => (\n        <div key={field.id} className=\"item-row\">\n          <Input\n            label=\"Name\"\n            {...register(`items.${index}.name`)}\n            error={errors.items?.[index]?.name}\n          />\n          <Input\n            label=\"Quantity\"\n            type=\"number\"\n            {...register(`items.${index}.quantity`, { valueAsNumber: true })}\n            error={errors.items?.[index]?.quantity}\n          />\n          <Input\n            label=\"Price\"\n            type=\"number\"\n            step=\"0.01\"\n            {...register(`items.${index}.price`, { valueAsNumber: true })}\n            error={errors.items?.[index]?.price}\n          />\n          <button\n            type=\"button\"\n            onClick={() => remove(index)}\n            disabled={fields.length === 1}\n          >\n            Remove\n          </button>\n        </div>\n      ))}\n      \n      <button\n        type=\"button\"\n        onClick={() => append({ name: '', quantity: 1, price: 0 })}\n      >\n        Add Item\n      </button>\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**Form with File Upload:**\n```tsx\nconst schema = z.object({\n  name: z.string().min(1),\n  avatar: z\n    .instanceof(FileList)\n    .refine((files) => files.length > 0, 'Avatar is required')\n    .refine(\n      (files) => files[0]?.size <= 5000000,\n      'Max file size is 5MB'\n    )\n    .refine(\n      (files) => ['image/jpeg', 'image/png', 'image/webp'].includes(files[0]?.type),\n      'Only .jpg, .png and .webp formats are supported'\n    ),\n});\n\nfunction FileUploadForm() {\n  const [preview, setPreview] = useState<string | null>(null);\n  const { register, handleSubmit, watch } = useForm({\n    resolver: zodResolver(schema),\n  });\n\n  const avatarFile = watch('avatar');\n\n  useEffect(() => {\n    if (avatarFile && avatarFile[0]) {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        setPreview(reader.result as string);\n      };\n      reader.readAsDataURL(avatarFile[0]);\n    }\n  }, [avatarFile]);\n\n  const onSubmit = async (data: z.infer<typeof schema>) => {\n    const formData = new FormData();\n    formData.append('name', data.name);\n    formData.append('avatar', data.avatar[0]);\n    \n    const response = await fetch('/api/upload', {\n      method: 'POST',\n      body: formData,\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <Input label=\"Name\" {...register('name')} />\n      \n      <div>\n        <label>Avatar</label>\n        <input type=\"file\" accept=\"image/*\" {...register('avatar')} />\n        {preview && <img src={preview} alt=\"Preview\" width={200} />}\n      </div>\n      \n      <button type=\"submit\">Upload</button>\n    </form>\n  );\n}\n```\n\n### 5. Form State Management\n\n**Watch Field Values:**\n```tsx\nfunction WatchedForm() {\n  const { register, watch } = useForm();\n  \n  const accountType = watch('accountType');\n  const watchAll = watch(); // Watch all fields\n  \n  return (\n    <form>\n      <Select\n        label=\"Account Type\"\n        options={[\n          { value: 'personal', label: 'Personal' },\n          { value: 'business', label: 'Business' },\n        ]}\n        {...register('accountType')}\n      />\n      \n      {accountType === 'business' && (\n        <Input\n          label=\"Company Name\"\n          {...register('companyName')}\n        />\n      )}\n    </form>\n  );\n}\n```\n\n**Set Form Values:**\n```tsx\nfunction EditForm({ userId }) {\n  const { register, setValue, reset } = useForm();\n  \n  useEffect(() => {\n    // Fetch user data\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        // Option 1: Set individual values\n        setValue('name', data.name);\n        setValue('email', data.email);\n        \n        // Option 2: Reset entire form\n        reset(data);\n      });\n  }, [userId, setValue, reset]);\n  \n  return <form>{/* fields */}</form>;\n}\n```\n\n**Form Dirty State:**\n```tsx\nfunction FormWithUnsavedChanges() {\n  const { register, formState: { isDirty, dirtyFields } } = useForm();\n  \n  useEffect(() => {\n    const handleBeforeUnload = (e: BeforeUnloadEvent) => {\n      if (isDirty) {\n        e.preventDefault();\n        e.returnValue = '';\n      }\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n  }, [isDirty]);\n  \n  return <form>{/* fields */}</form>;\n}\n```\n\n### 6. Error Handling\n\n**Server-Side Errors:**\n```tsx\nfunction FormWithServerErrors() {\n  const { register, handleSubmit, setError, formState: { errors } } = useForm();\n  \n  const onSubmit = async (data: FormData) => {\n    try {\n      const response = await fetch('/api/submit', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        \n        // Set field-specific errors\n        if (errorData.errors) {\n          Object.entries(errorData.errors).forEach(([field, message]) => {\n            setError(field as any, {\n              type: 'server',\n              message: message as string,\n            });\n          });\n        }\n        \n        // Set form-level error\n        setError('root.serverError', {\n          type: 'server',\n          message: errorData.message,\n        });\n      }\n    } catch (error) {\n      setError('root.serverError', {\n        type: 'network',\n        message: 'Network error. Please try again.',\n      });\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {errors.root?.serverError && (\n        <div className=\"error-banner\" role=\"alert\">\n          {errors.root.serverError.message}\n        </div>\n      )}\n      {/* form fields */}\n    </form>\n  );\n}\n```\n\n## Examples\n\n### Example 1: Complete Contact Form\n\n```tsx\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\n\nconst contactSchema = z.object({\n  name: z.string().min(1, 'Name is required'),\n  email: z.string().email('Invalid email'),\n  subject: z.string().min(1, 'Subject is required'),\n  message: z.string().min(10, 'Message must be at least 10 characters'),\n  category: z.enum(['general', 'support', 'sales']),\n});\n\ntype ContactFormData = z.infer<typeof contactSchema>;\n\nfunction ContactForm() {\n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { errors, isSubmitting, isSubmitSuccessful },\n  } = useForm<ContactFormData>({\n    resolver: zodResolver(contactSchema),\n  });\n\n  const onSubmit = async (data: ContactFormData) => {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    console.log(data);\n    reset();\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className=\"max-w-lg mx-auto p-6\">\n      <h2 className=\"text-2xl font-bold mb-6\">Contact Us</h2>\n      \n      {isSubmitSuccessful && (\n        <div className=\"success-message\" role=\"alert\">\n          Thank you! We'll get back to you soon.\n        </div>\n      )}\n      \n      <Input\n        label=\"Name\"\n        {...register('name')}\n        error={errors.name}\n      />\n      \n      <Input\n        label=\"Email\"\n        type=\"email\"\n        {...register('email')}\n        error={errors.email}\n      />\n      \n      <Select\n        label=\"Category\"\n        options={[\n          { value: 'general', label: 'General Inquiry' },\n          { value: 'support', label: 'Support' },\n          { value: 'sales', label: 'Sales' },\n        ]}\n        {...register('category')}\n        error={errors.category}\n      />\n      \n      <Input\n        label=\"Subject\"\n        {...register('subject')}\n        error={errors.subject}\n      />\n      \n      <div className=\"form-group\">\n        <label htmlFor=\"message\">Message</label>\n        <textarea\n          id=\"message\"\n          rows={5}\n          {...register('message')}\n          className={errors.message ? 'error' : ''}\n        />\n        {errors.message && (\n          <span className=\"error\">{errors.message.message}</span>\n        )}\n      </div>\n      \n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className=\"btn-primary\"\n      >\n        {isSubmitting ? 'Sending...' : 'Send Message'}\n      </button>\n    </form>\n  );\n}\n```\n\n## Best Practices\n\n1. **Use Zod for type-safe validation** with TypeScript\n2. **Create reusable form components** with forwardRef\n3. **Handle server-side errors** properly with setError\n4. **Provide immediate feedback** on validation errors\n5. **Use proper HTML input types** for better UX\n6. **Implement proper accessibility** with labels and ARIA\n7. **Show loading states** during submission\n8. **Reset forms after successful submission**\n9. **Validate on blur** for better UX\n10. **Use optimistic UI updates** when appropriate\n",
  "prompt": "A skill that provides comprehensive form handling expertise including React Hook Form, Zod validation, error handling, dynamic fields, multi-step forms, and best practices for building robust, type-safe forms in React.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
