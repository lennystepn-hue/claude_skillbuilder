{
  "id": "ai-agents",
  "name": "ai-agents",
  "description": "Build autonomous AI agents with tool use and planning",
  "category": "AI",
  "content": "---\nname: ai-agents\ndescription: Build autonomous AI agents\ncategory: AI\n---\n\n# AI Agents\n\n## Overview\nBuild autonomous AI agents that can plan, use tools, and accomplish complex tasks.\n\n## Activation\nActivates when user mentions \"AI agent\", \"autonomous agent\", \"tool use\", \"ReAct\", \"agent loop\", or \"multi-step reasoning\".\n\n## Instructions\n\n### Agent Architecture Patterns\n1. **ReAct**: Reason + Act in alternating steps\n2. **Plan-and-Execute**: Create plan first, then execute\n3. **Tree of Thoughts**: Explore multiple reasoning paths\n4. **Reflexion**: Self-critique and improve\n\n### Key Components\n- **Planning**: Break tasks into subtasks\n- **Memory**: Short-term (context) and long-term (vector DB)\n- **Tools**: External capabilities (search, code, APIs)\n- **Reasoning**: Chain-of-thought for decisions\n\n## Examples\n\n**Simple ReAct Agent:**\n```python\nfrom openai import OpenAI\nfrom typing import Callable\nimport json\n\nclass ReActAgent:\n    def __init__(self, tools: dict[str, Callable]):\n        self.client = OpenAI()\n        self.tools = tools\n        self.max_steps = 10\n        \n    def run(self, task: str) -> str:\n        messages = [{\n            \"role\": \"system\",\n            \"content\": f\"\"\"You are an AI agent. To complete tasks, you can use these tools:\n{self._format_tools()}\n\nFor each step, respond with:\nThought: <your reasoning>\nAction: <tool_name>\nAction Input: <input for the tool>\n\nOr if you have the final answer:\nThought: <your reasoning>\nFinal Answer: <your answer>\"\"\"\n        }, {\n            \"role\": \"user\",\n            \"content\": task\n        }]\n        \n        for step in range(self.max_steps):\n            response = self.client.chat.completions.create(\n                model=\"gpt-4o\",\n                messages=messages,\n                temperature=0\n            )\n            \n            content = response.choices[0].message.content\n            messages.append({\"role\": \"assistant\", \"content\": content})\n            \n            if \"Final Answer:\" in content:\n                return content.split(\"Final Answer:\")[-1].strip()\n            \n            # Parse action\n            if \"Action:\" in content and \"Action Input:\" in content:\n                action = content.split(\"Action:\")[1].split(\"\\n\")[0].strip()\n                action_input = content.split(\"Action Input:\")[1].split(\"\\n\")[0].strip()\n                \n                if action in self.tools:\n                    result = self.tools[action](action_input)\n                    messages.append({\n                        \"role\": \"user\",\n                        \"content\": f\"Observation: {result}\"\n                    })\n                else:\n                    messages.append({\n                        \"role\": \"user\",\n                        \"content\": f\"Observation: Tool '{action}' not found\"\n                    })\n        \n        return \"Max steps reached without final answer\"\n    \n    def _format_tools(self) -> str:\n        return \"\\n\".join(f\"- {name}: {func.__doc__}\" for name, func in self.tools.items())\n\n# Define tools\ndef search(query: str) -> str:\n    \"\"\"Search the web for information\"\"\"\n    return f\"Search results for '{query}': [simulated results]\"\n\ndef calculate(expr: str) -> str:\n    \"\"\"Evaluate a math expression\"\"\"\n    return str(eval(expr))\n\ndef get_weather(city: str) -> str:\n    \"\"\"Get current weather for a city\"\"\"\n    return f\"Weather in {city}: 72Â°F, Sunny\"\n\n# Usage\nagent = ReActAgent({\n    \"search\": search,\n    \"calculate\": calculate,\n    \"get_weather\": get_weather\n})\nresult = agent.run(\"What's the weather in NYC and what's 15% tip on a $85 dinner?\")\n```\n\n**Plan-and-Execute Agent:**\n```python\nclass PlanExecuteAgent:\n    def __init__(self, tools: dict):\n        self.client = OpenAI()\n        self.tools = tools\n    \n    def plan(self, task: str) -> list[str]:\n        response = self.client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\n                \"role\": \"user\",\n                \"content\": f\"\"\"Create a step-by-step plan to accomplish this task:\n{task}\n\nAvailable tools: {list(self.tools.keys())}\n\nRespond with a JSON array of steps:\n[\"step 1\", \"step 2\", ...]\"\"\"\n            }],\n            response_format={\"type\": \"json_object\"}\n        )\n        return json.loads(response.choices[0].message.content).get(\"steps\", [])\n    \n    def execute_step(self, step: str, context: str) -> str:\n        response = self.client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\n                \"role\": \"system\",\n                \"content\": f\"Execute this step using available tools. Context: {context}\"\n            }, {\n                \"role\": \"user\",\n                \"content\": step\n            }],\n            tools=[{\"type\": \"function\", \"function\": {\n                \"name\": name,\n                \"description\": func.__doc__,\n                \"parameters\": {\"type\": \"object\", \"properties\": {\"input\": {\"type\": \"string\"}}}\n            }} for name, func in self.tools.items()]\n        )\n        \n        msg = response.choices[0].message\n        if msg.tool_calls:\n            tool_call = msg.tool_calls[0]\n            result = self.tools[tool_call.function.name](\n                json.loads(tool_call.function.arguments)[\"input\"]\n            )\n            return result\n        return msg.content\n    \n    def run(self, task: str) -> str:\n        plan = self.plan(task)\n        print(f\"Plan: {plan}\")\n        \n        context = \"\"\n        for i, step in enumerate(plan):\n            print(f\"\\nExecuting step {i+1}: {step}\")\n            result = self.execute_step(step, context)\n            context += f\"\\nStep {i+1} result: {result}\"\n        \n        return context\n```\n\n**Agent with Memory:**\n```python\nimport chromadb\n\nclass MemoryAgent:\n    def __init__(self):\n        self.client = OpenAI()\n        self.chroma = chromadb.Client()\n        self.memory = self.chroma.create_collection(\"agent_memory\")\n        self.conversation = []\n    \n    def remember(self, text: str, metadata: dict = None):\n        self.memory.add(\n            documents=[text],\n            ids=[f\"mem_{len(self.memory.get()['ids'])}\"],\n            metadatas=[metadata or {}]\n        )\n    \n    def recall(self, query: str, n: int = 3) -> list[str]:\n        results = self.memory.query(query_texts=[query], n_results=n)\n        return results[\"documents\"][0]\n    \n    def chat(self, message: str) -> str:\n        # Recall relevant memories\n        memories = self.recall(message)\n        memory_context = \"\\n\".join(f\"- {m}\" for m in memories) if memories else \"None\"\n        \n        self.conversation.append({\"role\": \"user\", \"content\": message})\n        \n        response = self.client.chat.completions.create(\n            model=\"gpt-4o\",\n            messages=[{\n                \"role\": \"system\",\n                \"content\": f\"You are a helpful assistant. Relevant memories:\\n{memory_context}\"\n            }] + self.conversation[-10:]  # Last 10 messages\n        )\n        \n        reply = response.choices[0].message.content\n        self.conversation.append({\"role\": \"assistant\", \"content\": reply})\n        self.remember(f\"User: {message}\\nAssistant: {reply}\")\n        \n        return reply\n```",
  "prompt": "A skill for building AI agents",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
