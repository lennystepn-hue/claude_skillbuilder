{
  "id": "productivity-regex",
  "name": "Regex Builder",
  "description": "Build, explain, and test regex patterns with comprehensive examples and test cases",
  "category": "Productivity",
  "content": "---\nname: Regex Builder\ndescription: Build, explain, and test regex patterns with comprehensive examples and test cases\ncategory: Productivity\n---\n\n# Regex Builder\n\n## Overview\n\nThe Regex Builder skill helps you create, understand, and test regular expressions. It provides pattern explanations, generates regex for specific use cases, validates patterns with test cases, and explains why patterns match or fail.\n\nRegex is powerful but notoriously difficult to read and debug. This skill makes it approachable by:\n- Breaking down complex patterns into understandable parts\n- Providing comprehensive test cases with match explanations\n- Suggesting optimizations and alternatives\n- Highlighting common pitfalls and edge cases\n- Offering patterns for common real-world scenarios\n\n## Activation\n\nThis skill activates when you:\n- Ask to create a regex pattern for a specific use case\n- Request explanation of an existing regex\n- Need help debugging why a pattern isn't working\n- Want to validate a pattern with test cases\n- Ask for regex optimization or simplification\n- Need regex for common tasks (email, URL, phone numbers, etc.)\n\n## Instructions\n\nWhen working with regex, I will:\n\n1. **Understand the requirement** clearly before building the pattern\n\n2. **Provide the regex pattern** in multiple flavors when relevant (JavaScript, Python, etc.)\n\n3. **Explain each component** of the pattern in plain English\n\n4. **Include comprehensive test cases:**\n   - Strings that should match\n   - Strings that should NOT match\n   - Edge cases and boundary conditions\n\n5. **Show working code examples** in relevant programming languages\n\n6. **Highlight potential issues:**\n   - Performance concerns with catastrophic backtracking\n   - Unicode and special character handling\n   - Greedy vs. lazy matching implications\n\n7. **Suggest improvements** and alternatives when applicable\n\n## Examples\n\n### Example 1: Email Validation\n\n**Requirement:** Match valid email addresses\n\n**Regex Pattern:**\n```regex\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n```\n\n**Pattern Breakdown:**\n- `^` - Start of string\n- `[a-zA-Z0-9._%+-]+` - Local part (before @)\n  - One or more letters, digits, dots, underscores, percent, plus, or hyphens\n- `@` - Literal @ symbol (required)\n- `[a-zA-Z0-9.-]+` - Domain name\n  - One or more letters, digits, dots, or hyphens\n- `\\.` - Literal dot (escaped)\n- `[a-zA-Z]{2,}` - Top-level domain\n  - At least 2 letters (.com, .org, .museum)\n- `$` - End of string\n\n**Test Cases:**\n\n✅ **Should Match:**\n```\nuser@example.com\njohn.doe@company.co.uk\ntest+filter@gmail.com\nfirst_last@sub.domain.org\nadmin123@test-site.io\n```\n\n❌ **Should NOT Match:**\n```\n@example.com              # Missing local part\nuser@                     # Missing domain\nuser@domain              # Missing TLD\nuser @example.com        # Space in email\nuser@domain..com         # Consecutive dots\nuser.@example.com        # Dot before @\n```\n\n**JavaScript Implementation:**\n```javascript\nfunction isValidEmail(email) {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailRegex.test(email);\n}\n\n// Test cases\nconsole.log(isValidEmail('user@example.com'));        // true\nconsole.log(isValidEmail('invalid.email'));           // false\nconsole.log(isValidEmail('test+tag@domain.co.uk'));   // true\nconsole.log(isValidEmail('@nodomain.com'));           // false\n```\n\n**Python Implementation:**\n```python\nimport re\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\n# Test cases\ntest_emails = [\n    ('user@example.com', True),\n    ('invalid.email', False),\n    ('test+tag@domain.co.uk', True),\n    ('@nodomain.com', False),\n]\n\nfor email, expected in test_emails:\n    result = is_valid_email(email)\n    status = '✓' if result == expected else '✗'\n    print(f'{status} {email}: {result}')\n```\n\n**Important Notes:**\n- This is a simplified pattern; RFC 5322 compliant email validation is much more complex\n- For production, consider using dedicated email validation libraries\n- This pattern doesn't validate that the domain actually exists\n- International domains (IDN) with unicode characters need different handling\n\n---\n\n### Example 2: Extract Phone Numbers\n\n**Requirement:** Extract US phone numbers in various formats\n\n**Regex Pattern:**\n```regex\n(?:\\+1[-.\\s]?)?(?:\\(?([0-9]{3})\\)?[-.\\s]?)?([0-9]{3})[-.\\s]?([0-9]{4})\n```\n\n**Pattern Breakdown:**\n- `(?:\\+1[-.\\s]?)?` - Optional country code\n  - `(?:...)` - Non-capturing group\n  - `\\+1` - Literal +1\n  - `[-.\\s]?` - Optional separator (dash, dot, or space)\n  - `?` - Entire group is optional\n- `(?:\\(?([0-9]{3})\\)?[-.\\s]?)?` - Optional area code\n  - `\\(?` - Optional opening parenthesis\n  - `([0-9]{3})` - Capturing group: exactly 3 digits\n  - `\\)?` - Optional closing parenthesis\n  - `[-.\\s]?` - Optional separator\n  - `?` - Entire group is optional\n- `([0-9]{3})` - Capturing group: 3 digits (exchange)\n- `[-.\\s]?` - Optional separator\n- `([0-9]{4})` - Capturing group: 4 digits (line number)\n\n**Test Cases:**\n\n✅ **Should Match:**\n```\n(555) 123-4567\n555-123-4567\n555.123.4567\n5551234567\n+1 555 123 4567\n+1-555-123-4567\n(555)123-4567\n123-4567              # Without area code\n```\n\n❌ **Should NOT Match:**\n```\n555-12-4567           # Wrong format\n(555) 12-34567        # Wrong grouping\n+44 555 123 4567      # Wrong country code\n```\n\n**JavaScript Implementation with Extraction:**\n```javascript\nfunction extractPhoneNumbers(text) {\n  const phoneRegex = /(?:\\+1[-.\\s]?)?(?:\\(?([0-9]{3})\\)?[-.\\s]?)?([0-9]{3})[-.\\s]?([0-9]{4})/g;\n  const matches = [];\n  \n  let match;\n  while ((match = phoneRegex.exec(text)) !== null) {\n    const [fullMatch, areaCode, exchange, lineNumber] = match;\n    matches.push({\n      original: fullMatch,\n      formatted: areaCode \n        ? `(${areaCode}) ${exchange}-${lineNumber}`\n        : `${exchange}-${lineNumber}`,\n      parts: {\n        areaCode: areaCode || null,\n        exchange,\n        lineNumber\n      }\n    });\n  }\n  \n  return matches;\n}\n\n// Example usage\nconst text = `\n  Call me at (555) 123-4567 or my office at 555-987-6543.\n  International: +1-555-111-2222\n`;\n\nconst phones = extractPhoneNumbers(text);\nconsole.log(JSON.stringify(phones, null, 2));\n\n// Output:\n// [\n//   {\n//     \"original\": \"(555) 123-4567\",\n//     \"formatted\": \"(555) 123-4567\",\n//     \"parts\": { \"areaCode\": \"555\", \"exchange\": \"123\", \"lineNumber\": \"4567\" }\n//   },\n//   ...\n// ]\n```\n\n**Python Implementation:**\n```python\nimport re\nfrom typing import List, Dict, Optional\n\ndef extract_phone_numbers(text: str) -> List[Dict]:\n    pattern = r'(?:\\+1[-.\\s]?)?(?:\\(?([0-9]{3})\\)?[-.\\s]?)?([0-9]{3})[-.\\s]?([0-9]{4})'\n    matches = []\n    \n    for match in re.finditer(pattern, text):\n        full_match = match.group(0)\n        area_code = match.group(1)\n        exchange = match.group(2)\n        line_number = match.group(3)\n        \n        formatted = (\n            f'({area_code}) {exchange}-{line_number}' if area_code\n            else f'{exchange}-{line_number}'\n        )\n        \n        matches.append({\n            'original': full_match,\n            'formatted': formatted,\n            'parts': {\n                'area_code': area_code,\n                'exchange': exchange,\n                'line_number': line_number\n            }\n        })\n    \n    return matches\n\n# Example\ntext = '''\nCall me at (555) 123-4567 or my office at 555-987-6543.\nInternational: +1-555-111-2222\n'''\n\nfor phone in extract_phone_numbers(text):\n    print(f\"{phone['original']} -> {phone['formatted']}\")\n```\n\n---\n\n### Example 3: Password Strength Validation\n\n**Requirement:** Validate password with specific requirements:\n- At least 8 characters\n- At least one uppercase letter\n- At least one lowercase letter\n- At least one digit\n- At least one special character (!@#$%^&*)\n\n**Regex Pattern (using lookaheads):**\n```regex\n^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*])[A-Za-z\\d!@#$%^&*]{8,}$\n```\n\n**Pattern Breakdown:**\n- `^` - Start of string\n- `(?=.*[a-z])` - Positive lookahead: must contain at least one lowercase\n  - `(?=...)` - Lookahead assertion (doesn't consume characters)\n  - `.*` - Any characters\n  - `[a-z]` - Followed by lowercase letter\n- `(?=.*[A-Z])` - Positive lookahead: must contain at least one uppercase\n- `(?=.*\\d)` - Positive lookahead: must contain at least one digit\n- `(?=.*[!@#$%^&*])` - Positive lookahead: must contain special character\n- `[A-Za-z\\d!@#$%^&*]{8,}` - Main pattern: 8+ allowed characters\n- `$` - End of string\n\n**Why Lookaheads?**\nLookaheads check conditions without consuming characters. Each lookahead independently verifies a requirement exists SOMEWHERE in the string, then the main pattern enforces length and allowed characters.\n\n**Test Cases:**\n\n✅ **Should Match:**\n```\nPassword123!\nSecure@Pass1\nMyP@ssw0rd\nCompl3x!tyRul3s\n!Aa1bcdefgh\n```\n\n❌ **Should NOT Match:**\n```\npassword123!         # No uppercase\nPASSWORD123!         # No lowercase\nPassword!            # No digit\nPassword123          # No special char\nPa1!                 # Too short (< 8 chars)\nPassword 123!        # Contains space (not allowed)\n```\n\n**JavaScript Implementation with Detailed Feedback:**\n```javascript\nfunction validatePassword(password) {\n  const requirements = [\n    {\n      regex: /.{8,}/,\n      message: 'At least 8 characters'\n    },\n    {\n      regex: /[a-z]/,\n      message: 'At least one lowercase letter'\n    },\n    {\n      regex: /[A-Z]/,\n      message: 'At least one uppercase letter'\n    },\n    {\n      regex: /\\d/,\n      message: 'At least one digit'\n    },\n    {\n      regex: /[!@#$%^&*]/,\n      message: 'At least one special character (!@#$%^&*)'\n    },\n    {\n      regex: /^[A-Za-z\\d!@#$%^&*]+$/,\n      message: 'Only letters, digits, and !@#$%^&* allowed'\n    }\n  ];\n  \n  const failed = requirements.filter(req => !req.regex.test(password));\n  \n  return {\n    valid: failed.length === 0,\n    failures: failed.map(f => f.message)\n  };\n}\n\n// Example usage\nconst passwords = [\n  'Password123!',\n  'weak',\n  'NoDigitsOrSpecial',\n  'noupperca$e123'\n];\n\npasswords.forEach(pwd => {\n  const result = validatePassword(pwd);\n  console.log(`\\n\"${pwd}\"`);\n  if (result.valid) {\n    console.log('✓ Valid password');\n  } else {\n    console.log('✗ Invalid password:');\n    result.failures.forEach(f => console.log(`  - ${f}`));\n  }\n});\n```\n\n**Python Implementation:**\n```python\nimport re\nfrom typing import Dict, List\n\ndef validate_password(password: str) -> Dict[str, any]:\n    requirements = [\n        (r'.{8,}', 'At least 8 characters'),\n        (r'[a-z]', 'At least one lowercase letter'),\n        (r'[A-Z]', 'At least one uppercase letter'),\n        (r'\\d', 'At least one digit'),\n        (r'[!@#$%^&*]', 'At least one special character (!@#$%^&*)'),\n        (r'^[A-Za-z\\d!@#$%^&*]+$', 'Only letters, digits, and !@#$%^&* allowed'),\n    ]\n    \n    failures = [\n        message for pattern, message in requirements\n        if not re.search(pattern, password)\n    ]\n    \n    return {\n        'valid': len(failures) == 0,\n        'failures': failures\n    }\n\n# Example usage\ntest_passwords = [\n    'Password123!',\n    'weak',\n    'NoDigitsOrSpecial',\n    'noupperca$e123'\n]\n\nfor pwd in test_passwords:\n    result = validate_password(pwd)\n    print(f'\\n\"{pwd}\"')\n    if result['valid']:\n        print('✓ Valid password')\n    else:\n        print('✗ Invalid password:')\n        for failure in result['failures']:\n            print(f'  - {failure}')\n```\n\n---\n\n### Example 4: Parse and Extract URL Components\n\n**Requirement:** Extract protocol, domain, path, query params, and fragment from URLs\n\n**Regex Pattern:**\n```regex\n^(https?:\\/\\/)?(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,})(:\\d+)?(\\/[^?#]*)?(\\?[^#]*)?(#.*)?$\n```\n\n**Pattern Breakdown:**\n- `^` - Start of string\n- `(https?:\\/\\/)?` - Group 1: Optional protocol\n  - `https?` - \"http\" or \"https\"\n  - `:` - Literal colon\n  - `\\/\\/` - Two forward slashes (escaped)\n  - `?` - Entire group optional\n- `(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,})` - Group 2: Domain\n  - `([a-zA-Z0-9-]+\\.)+` - Subdomains (one or more)\n  - `[a-zA-Z]{2,}` - TLD (at least 2 letters)\n- `(:\\d+)?` - Group 3: Optional port\n- `(\\/[^?#]*)?` - Group 4: Optional path\n  - `\\/` - Leading slash\n  - `[^?#]*` - Everything except ? and #\n- `(\\?[^#]*)?` - Group 5: Optional query string\n- `(#.*)?` - Group 6: Optional fragment\n- `$` - End of string\n\n**JavaScript Implementation:**\n```javascript\nfunction parseURL(url) {\n  const urlRegex = /^(https?:\\/\\/)?(([a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,})(:\\d+)?(\\/[^?#]*)?(\\?[^#]*)?(#.*)?$/;\n  \n  const match = url.match(urlRegex);\n  \n  if (!match) {\n    return null;\n  }\n  \n  const [, protocol, domain, , port, path, query, fragment] = match;\n  \n  // Parse query string into object\n  const queryParams = {};\n  if (query) {\n    query.substring(1).split('&').forEach(param => {\n      const [key, value] = param.split('=');\n      queryParams[decodeURIComponent(key)] = decodeURIComponent(value || '');\n    });\n  }\n  \n  return {\n    original: url,\n    protocol: protocol ? protocol.replace('://', '') : null,\n    domain: domain,\n    port: port ? parseInt(port.substring(1)) : null,\n    path: path || '/',\n    query: queryParams,\n    fragment: fragment ? fragment.substring(1) : null\n  };\n}\n\n// Test cases\nconst urls = [\n  'https://www.example.com/path/to/page?id=123&name=test#section',\n  'http://api.github.com:443/users',\n  'subdomain.example.co.uk/path',\n  'https://localhost:3000/?debug=true',\n];\n\nurls.forEach(url => {\n  console.log('\\nURL:', url);\n  console.log(JSON.stringify(parseURL(url), null, 2));\n});\n```\n\n**Example Output:**\n```json\n{\n  \"original\": \"https://www.example.com/path/to/page?id=123&name=test#section\",\n  \"protocol\": \"https\",\n  \"domain\": \"www.example.com\",\n  \"port\": null,\n  \"path\": \"/path/to/page\",\n  \"query\": {\n    \"id\": \"123\",\n    \"name\": \"test\"\n  },\n  \"fragment\": \"section\"\n}\n```\n\n---\n\n### Example 5: Find and Replace with Capture Groups\n\n**Requirement:** Convert date format from MM/DD/YYYY to YYYY-MM-DD\n\n**Regex Pattern:**\n```regex\n(\\d{2})\\/(\\d{2})\\/(\\d{4})\n```\n\n**Pattern Breakdown:**\n- `(\\d{2})` - Capture group 1: 2 digits (month)\n- `\\/` - Literal forward slash\n- `(\\d{2})` - Capture group 2: 2 digits (day)\n- `\\/` - Literal forward slash\n- `(\\d{4})` - Capture group 3: 4 digits (year)\n\n**Replacement Pattern:**\n```\n$3-$1-$2\n```\n- `$3` - Year (group 3)\n- `-` - Literal dash\n- `$1` - Month (group 1)\n- `-` - Literal dash\n- `$2` - Day (group 2)\n\n**JavaScript Implementation:**\n```javascript\nfunction convertDateFormat(text) {\n  const dateRegex = /(\\d{2})\\/(\\d{2})\\/(\\d{4})/g;\n  return text.replace(dateRegex, '$3-$1-$2');\n}\n\n// Test cases\nconst testCases = [\n  'Meeting on 12/25/2024',\n  'Dates: 01/15/2024, 03/30/2024, 12/31/2024',\n  'Born on 06/15/1990 and married on 08/20/2015',\n];\n\ntestCases.forEach(text => {\n  console.log('Before:', text);\n  console.log('After: ', convertDateFormat(text));\n  console.log();\n});\n\n// Output:\n// Before: Meeting on 12/25/2024\n// After:  Meeting on 2024-12-25\n```\n\n**Python Implementation:**\n```python\nimport re\n\ndef convert_date_format(text: str) -> str:\n    pattern = r'(\\d{2})/(\\d{2})/(\\d{4})'\n    return re.sub(pattern, r'\\3-\\1-\\2', text)\n\n# Test cases\ntest_cases = [\n    'Meeting on 12/25/2024',\n    'Dates: 01/15/2024, 03/30/2024, 12/31/2024',\n    'Born on 06/15/1990 and married on 08/20/2015',\n]\n\nfor text in test_cases:\n    print(f'Before: {text}')\n    print(f'After:  {convert_date_format(text)}')\n    print()\n```\n\n**Advanced: With Validation**\n```javascript\nfunction convertAndValidateDates(text) {\n  const dateRegex = /(\\d{2})\\/(\\d{2})\\/(\\d{4})/g;\n  \n  return text.replace(dateRegex, (match, month, day, year) => {\n    const m = parseInt(month);\n    const d = parseInt(day);\n    const y = parseInt(year);\n    \n    // Validate ranges\n    if (m < 1 || m > 12) return match; // Invalid month, keep original\n    if (d < 1 || d > 31) return match; // Invalid day, keep original\n    if (y < 1900 || y > 2100) return match; // Unrealistic year\n    \n    // Check if date is valid (handles month-specific day limits)\n    const date = new Date(y, m - 1, d);\n    if (date.getMonth() !== m - 1 || date.getDate() !== d) {\n      return match; // Invalid date (e.g., 02/31/2024)\n    }\n    \n    // Convert to ISO format\n    return `${year}-${month}-${day}`;\n  });\n}\n\n// Test with invalid dates\nconsole.log(convertAndValidateDates('Valid: 12/25/2024'));\n// Output: Valid: 2024-12-25\n\nconsole.log(convertAndValidateDates('Invalid: 13/45/2024'));\n// Output: Invalid: 13/45/2024 (unchanged)\n\nconsole.log(convertAndValidateDates('Invalid: 02/31/2024'));\n// Output: Invalid: 02/31/2024 (Feb doesn't have 31 days)\n```\n\n---\n\n### Example 6: Greedy vs Lazy Matching\n\n**Requirement:** Extract content between HTML tags\n\n**Problem with Greedy Matching:**\n```regex\n<div>(.*)</div>\n```\n\nThis is **greedy** - it matches as much as possible.\n\n**Test String:**\n```html\n<div>First</div> Some text <div>Second</div>\n```\n\n**Greedy Match:** `<div>First</div> Some text <div>Second</div>`\n- Matches from the FIRST `<div>` to the LAST `</div>`\n- Captures: \"First</div> Some text <div>Second\"\n\n**Solution with Lazy Matching:**\n```regex\n<div>(.*?)</div>\n```\n\nThe `?` after `*` makes it **lazy** - matches as little as possible.\n\n**Lazy Matches:** \n1. `<div>First</div>` - Captures: \"First\"\n2. `<div>Second</div>` - Captures: \"Second\"\n\n**JavaScript Comparison:**\n```javascript\nconst html = '<div>First</div> Some text <div>Second</div>';\n\n// Greedy\nconst greedyRegex = /<div>(.*)<\\/div>/;\nconst greedyMatch = html.match(greedyRegex);\nconsole.log('Greedy:', greedyMatch[1]);\n// Output: First</div> Some text <div>Second\n\n// Lazy\nconst lazyRegex = /<div>(.*?)<\\/div>/g;\nconst lazyMatches = [];\nlet match;\nwhile ((match = lazyRegex.exec(html)) !== null) {\n  lazyMatches.push(match[1]);\n}\nconsole.log('Lazy:', lazyMatches);\n// Output: ['First', 'Second']\n```\n\n**Rule of Thumb:**\n- Use `*?` or `+?` when extracting content between delimiters\n- Greedy is default and usually not what you want for extraction\n- Lazy prevents over-matching across multiple instances\n\n---\n\n## Common Regex Patterns Library\n\n### Numbers and Dates\n```regex\n# Integer\n^-?\\d+$\n\n# Decimal (with optional decimals)\n^-?\\d+(\\.\\d+)?$\n\n# Credit Card (basic)\n^\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}$\n\n# US Zip Code\n^\\d{5}(-\\d{4})?$\n\n# ISO Date (YYYY-MM-DD)\n^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$\n\n# Time (24-hour)\n^([01]\\d|2[0-3]):[0-5]\\d(:[0-5]\\d)?$\n```\n\n### Text Patterns\n```regex\n# Username (alphanumeric, underscore, dash, 3-16 chars)\n^[a-zA-Z0-9_-]{3,16}$\n\n# Hex Color\n^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$\n\n# IPv4 Address\n^((25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$\n\n# Slug (URL-friendly)\n^[a-z0-9]+(?:-[a-z0-9]+)*$\n```\n\n### File Paths\n```regex\n# File extension\n\\.([a-zA-Z0-9]+)$\n\n# Image files\n\\.(jpg|jpeg|png|gif|webp|svg)$\n\n# Windows path\n^[a-zA-Z]:\\\\(?:[^\\\\/:*?\"<>|\\r\\n]+\\\\)*[^\\\\/:*?\"<>|\\r\\n]*$\n\n# Unix path\n^\\/(?:[^\\/\\0]+\\/)*[^\\/\\0]*$\n```\n\n---\n\n## Performance Tips\n\n1. **Avoid Catastrophic Backtracking:**\n```regex\n# BAD: Can hang on long strings\n(a+)+b\n\n# GOOD: More specific\na+b\n```\n\n2. **Use Non-Capturing Groups When Possible:**\n```regex\n# If you don't need the captured value:\n(?:pattern)  # Instead of (pattern)\n```\n\n3. **Be Specific:**\n```regex\n# BAD: Too greedy\n.*\n\n# GOOD: More specific\n[a-zA-Z0-9]+\n```\n\n4. **Anchor When Possible:**\n```regex\n# Using ^ and $ prevents unnecessary scanning\n^pattern$\n```\n\n---\n\n## Debugging Regex\n\n**Recommended Tools:**\n- regex101.com - Interactive testing with explanation\n- regexr.com - Visual representation\n- debuggex.com - Railroad diagrams\n\n**Common Issues:**\n1. **Forgetting to escape special characters:** `. * + ? [ ] { } ( ) ^ $ | \\`\n2. **Using greedy when you need lazy:** Use `*?` or `+?`\n3. **Not testing edge cases:** Empty strings, special characters, unicode\n4. **Overly complex patterns:** Sometimes string methods are simpler\n\n## When NOT to Use Regex\n\n- Parsing HTML/XML (use a parser instead)\n- Complex nested structures (use a proper parser)\n- When a simple string method works (`includes()`, `startsWith()`, `split()`)\n- Email validation in production (use a library)\n- When readability is critical (regex is hard to maintain)\n",
  "prompt": "A skill that builds, explains, and tests regex patterns with comprehensive examples, test cases, and working code in multiple languages. Helps create patterns for common use cases, debug existing regex, and understand complex matching behavior.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
