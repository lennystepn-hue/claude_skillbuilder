{
  "id": "frontend-performance",
  "name": "frontend-performance",
  "description": "React performance optimization with lazy loading, code splitting, memoization, bundle analysis, and advanced optimization techniques",
  "category": "Frontend",
  "content": "---\nname: frontend-performance\ndescription: React performance optimization with lazy loading, code splitting, memoization, bundle analysis, and advanced optimization techniques\ncategory: Frontend\n---\n\n# React Performance Optimization\n\n## Overview\n\nThis skill provides comprehensive strategies for optimizing React application performance. It covers lazy loading, code splitting, memoization techniques, bundle analysis, rendering optimization, image optimization, and advanced performance patterns to create fast, efficient React applications.\n\n## Activation\n\nUse this skill when:\n- Optimizing slow React applications\n- Reducing bundle sizes and improving load times\n- Preventing unnecessary re-renders\n- Implementing code splitting and lazy loading\n- Analyzing and optimizing bundle composition\n- Improving perceived performance and user experience\n- Optimizing images and assets\n- Implementing virtualization for large lists\n- Debugging performance issues\n\n## Instructions\n\n### Performance Optimization Workflow\n\n1. **Measure First**: Use React DevTools Profiler and browser tools to identify bottlenecks\n2. **Analyze Bundle**: Use webpack-bundle-analyzer or similar tools\n3. **Implement Code Splitting**: Split routes and heavy components\n4. **Optimize Renders**: Use memoization where appropriate\n5. **Lazy Load Resources**: Images, components, and routes\n6. **Monitor Results**: Measure improvements with tools\n\n### Key Principles\n\n1. **Don't optimize prematurely**: Profile first, then optimize\n2. **Lazy load non-critical resources**: Load what's needed when it's needed\n3. **Memoize expensive computations**: Not every component needs memoization\n4. **Split code at route boundaries**: Natural separation points\n5. **Optimize assets**: Compress images, use modern formats\n\n## Examples\n\n### Example 1: Code Splitting and Lazy Loading\n\n```typescript\n// App.tsx - Route-based code splitting\nimport React, { Suspense, lazy } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport { LoadingSpinner } from './components/LoadingSpinner';\n\n// Static imports for critical components\nimport { Header } from './components/Header';\nimport { Footer } from './components/Footer';\n\n// Lazy load route components\nconst Home = lazy(() => import('./pages/Home'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Settings = lazy(() => import('./pages/Settings'));\nconst Analytics = lazy(() => import('./pages/Analytics'));\n\n// Lazy load with retry logic for better UX\nconst lazyWithRetry = (componentImport: () => Promise<any>) => {\n  return new Promise((resolve, reject) => {\n    const hasRefreshed = JSON.parse(\n      window.sessionStorage.getItem('retry-lazy-refreshed') || 'false'\n    );\n\n    componentImport()\n      .then((component) => {\n        window.sessionStorage.setItem('retry-lazy-refreshed', 'false');\n        resolve(component);\n      })\n      .catch((error) => {\n        if (!hasRefreshed) {\n          window.sessionStorage.setItem('retry-lazy-refreshed', 'true');\n          return window.location.reload();\n        }\n        reject(error);\n      });\n  });\n};\n\nconst UserProfile = lazy(() => \n  lazyWithRetry(() => import('./pages/UserProfile'))\n);\n\nexport const App: React.FC = () => {\n  return (\n    <BrowserRouter>\n      <Header />\n      <Suspense fallback={<LoadingSpinner />}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/settings\" element={<Settings />} />\n          <Route path=\"/analytics\" element={<Analytics />} />\n          <Route path=\"/profile/:id\" element={<UserProfile />} />\n        </Routes>\n      </Suspense>\n      <Footer />\n    </BrowserRouter>\n  );\n};\n\n// LoadingSpinner.tsx - Optimized loading component\nimport React from 'react';\n\nexport const LoadingSpinner: React.FC = () => {\n  return (\n    <div \n      className=\"loading-container\"\n      role=\"status\" \n      aria-label=\"Loading\"\n    >\n      <div className=\"spinner\" />\n      <span className=\"sr-only\">Loading...</span>\n    </div>\n  );\n};\n```\n\n### Example 2: Component Memoization and React.memo\n\n```typescript\n// UserCard.tsx - Properly memoized component\nimport React, { memo } from 'react';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  avatar: string;\n}\n\ninterface UserCardProps {\n  user: User;\n  onSelect: (userId: string) => void;\n}\n\n// Memoize component to prevent re-renders when props don't change\nexport const UserCard = memo<UserCardProps>(({ user, onSelect }) => {\n  console.log('UserCard rendered for:', user.name);\n\n  return (\n    <div className=\"user-card\">\n      <img src={user.avatar} alt={user.name} loading=\"lazy\" />\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n      <button onClick={() => onSelect(user.id)}>Select</button>\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Custom comparison function\n  // Return true if props are equal (skip re-render)\n  // Return false if props are different (re-render)\n  return (\n    prevProps.user.id === nextProps.user.id &&\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.user.email === nextProps.user.email &&\n    prevProps.onSelect === nextProps.onSelect\n  );\n});\n\nUserCard.displayName = 'UserCard';\n\n// UserList.tsx - Parent component with optimized callbacks\nimport React, { useState, useCallback, useMemo } from 'react';\nimport { UserCard } from './UserCard';\n\ninterface UserListProps {\n  users: User[];\n  filter: string;\n}\n\nexport const UserList: React.FC<UserListProps> = ({ users, filter }) => {\n  const [selectedId, setSelectedId] = useState<string | null>(null);\n\n  // Memoize callback to prevent UserCard re-renders\n  const handleSelect = useCallback((userId: string) => {\n    setSelectedId(userId);\n    console.log('Selected user:', userId);\n  }, []);\n\n  // Memoize filtered users to avoid recalculation\n  const filteredUsers = useMemo(() => {\n    if (!filter) return users;\n    \n    return users.filter(user => \n      user.name.toLowerCase().includes(filter.toLowerCase()) ||\n      user.email.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [users, filter]);\n\n  return (\n    <div className=\"user-list\">\n      {filteredUsers.map(user => (\n        <UserCard \n          key={user.id} \n          user={user} \n          onSelect={handleSelect}\n        />\n      ))}\n    </div>\n  );\n};\n```\n\n### Example 3: useMemo and useCallback Optimization\n\n```typescript\n// ProductFilter.tsx - Expensive computation optimization\nimport React, { useState, useMemo, useCallback } from 'react';\n\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n  category: string;\n  tags: string[];\n  inStock: boolean;\n}\n\ninterface ProductFilterProps {\n  products: Product[];\n}\n\nexport const ProductFilter: React.FC<ProductFilterProps> = ({ products }) => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState<string>('all');\n  const [priceRange, setPriceRange] = useState<[number, number]>([0, 1000]);\n  const [showInStockOnly, setShowInStockOnly] = useState(false);\n\n  // Expensive computation - memoize it\n  const filteredProducts = useMemo(() => {\n    console.log('Filtering products...');\n    \n    return products.filter(product => {\n      const matchesSearch = product.name.toLowerCase().includes(searchTerm.toLowerCase());\n      const matchesCategory = selectedCategory === 'all' || product.category === selectedCategory;\n      const matchesPrice = product.price >= priceRange[0] && product.price <= priceRange[1];\n      const matchesStock = !showInStockOnly || product.inStock;\n      \n      return matchesSearch && matchesCategory && matchesPrice && matchesStock;\n    });\n  }, [products, searchTerm, selectedCategory, priceRange, showInStockOnly]);\n\n  // Memoize categories to avoid recalculation\n  const categories = useMemo(() => {\n    const cats = new Set(products.map(p => p.category));\n    return ['all', ...Array.from(cats)];\n  }, [products]);\n\n  // Memoize statistics calculation\n  const statistics = useMemo(() => {\n    const total = filteredProducts.length;\n    const inStock = filteredProducts.filter(p => p.inStock).length;\n    const averagePrice = filteredProducts.reduce((sum, p) => sum + p.price, 0) / total || 0;\n    \n    return { total, inStock, averagePrice };\n  }, [filteredProducts]);\n\n  // Memoize event handlers\n  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    setSearchTerm(e.target.value);\n  }, []);\n\n  const handleCategoryChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {\n    setSelectedCategory(e.target.value);\n  }, []);\n\n  const handlePriceChange = useCallback((min: number, max: number) => {\n    setPriceRange([min, max]);\n  }, []);\n\n  const handleStockToggle = useCallback(() => {\n    setShowInStockOnly(prev => !prev);\n  }, []);\n\n  return (\n    <div className=\"product-filter\">\n      <div className=\"filters\">\n        <input\n          type=\"text\"\n          value={searchTerm}\n          onChange={handleSearchChange}\n          placeholder=\"Search products...\"\n        />\n        \n        <select value={selectedCategory} onChange={handleCategoryChange}>\n          {categories.map(cat => (\n            <option key={cat} value={cat}>{cat}</option>\n          ))}\n        </select>\n        \n        <label>\n          <input\n            type=\"checkbox\"\n            checked={showInStockOnly}\n            onChange={handleStockToggle}\n          />\n          In stock only\n        </label>\n      </div>\n\n      <div className=\"statistics\">\n        <p>Total: {statistics.total}</p>\n        <p>In Stock: {statistics.inStock}</p>\n        <p>Avg Price: ${statistics.averagePrice.toFixed(2)}</p>\n      </div>\n\n      <div className=\"product-grid\">\n        {filteredProducts.map(product => (\n          <ProductCard key={product.id} product={product} />\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n### Example 4: Virtual Scrolling for Large Lists\n\n```typescript\n// VirtualList.tsx - Windowing for performance\nimport React, { useState, useRef, useEffect, useCallback } from 'react';\n\ninterface VirtualListProps<T> {\n  items: T[];\n  itemHeight: number;\n  containerHeight: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n  overscan?: number;\n}\n\nexport const VirtualList = <T,>({\n  items,\n  itemHeight,\n  containerHeight,\n  renderItem,\n  overscan = 3\n}: VirtualListProps<T>) => {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  }, []);\n\n  // Calculate visible range\n  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);\n  const endIndex = Math.min(\n    items.length - 1,\n    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan\n  );\n\n  const visibleItems = items.slice(startIndex, endIndex + 1);\n  const totalHeight = items.length * itemHeight;\n  const offsetY = startIndex * itemHeight;\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={handleScroll}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${offsetY}px)` }}>\n          {visibleItems.map((item, index) => (\n            <div key={startIndex + index} style={{ height: itemHeight }}>\n              {renderItem(item, startIndex + index)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Usage with react-window (recommended for production)\nimport { FixedSizeList as List } from 'react-window';\nimport AutoSizer from 'react-virtualized-auto-sizer';\n\ninterface Message {\n  id: string;\n  text: string;\n  sender: string;\n  timestamp: Date;\n}\n\ninterface MessageListProps {\n  messages: Message[];\n}\n\nconst Row: React.FC<{ index: number; style: React.CSSProperties; data: Message[] }> = ({\n  index,\n  style,\n  data\n}) => {\n  const message = data[index];\n  \n  return (\n    <div style={style} className=\"message-row\">\n      <div className=\"message\">\n        <strong>{message.sender}</strong>\n        <p>{message.text}</p>\n        <small>{message.timestamp.toLocaleString()}</small>\n      </div>\n    </div>\n  );\n};\n\nexport const MessageList: React.FC<MessageListProps> = ({ messages }) => {\n  return (\n    <AutoSizer>\n      {({ height, width }) => (\n        <List\n          height={height}\n          width={width}\n          itemCount={messages.length}\n          itemSize={80}\n          itemData={messages}\n          overscanCount={5}\n        >\n          {Row}\n        </List>\n      )}\n    </AutoSizer>\n  );\n};\n```\n\n### Example 5: Image Optimization\n\n```typescript\n// OptimizedImage.tsx - Progressive image loading\nimport React, { useState, useEffect } from 'react';\n\ninterface OptimizedImageProps {\n  src: string;\n  alt: string;\n  placeholderSrc?: string;\n  className?: string;\n  width?: number;\n  height?: number;\n}\n\nexport const OptimizedImage: React.FC<OptimizedImageProps> = ({\n  src,\n  alt,\n  placeholderSrc,\n  className,\n  width,\n  height\n}) => {\n  const [imageSrc, setImageSrc] = useState(placeholderSrc || src);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const img = new Image();\n    img.src = src;\n    \n    img.onload = () => {\n      setImageSrc(src);\n      setIsLoading(false);\n    };\n    \n    return () => {\n      img.onload = null;\n    };\n  }, [src]);\n\n  return (\n    <img\n      src={imageSrc}\n      alt={alt}\n      className={`${className} ${isLoading ? 'loading' : 'loaded'}`}\n      width={width}\n      height={height}\n      loading=\"lazy\"\n      decoding=\"async\"\n    />\n  );\n};\n\n// ResponsiveImage.tsx - Responsive images with srcset\ninterface ResponsiveImageProps {\n  src: string;\n  alt: string;\n  sizes?: string;\n  className?: string;\n}\n\nexport const ResponsiveImage: React.FC<ResponsiveImageProps> = ({\n  src,\n  alt,\n  sizes = '100vw',\n  className\n}) => {\n  // Generate srcset for different sizes\n  const generateSrcSet = (baseSrc: string) => {\n    const sizes = [400, 800, 1200, 1600];\n    return sizes\n      .map(size => {\n        const url = baseSrc.replace(/\\.([^.]+)$/, `-${size}w.$1`);\n        return `${url} ${size}w`;\n      })\n      .join(', ');\n  };\n\n  return (\n    <img\n      src={src}\n      srcSet={generateSrcSet(src)}\n      sizes={sizes}\n      alt={alt}\n      className={className}\n      loading=\"lazy\"\n      decoding=\"async\"\n    />\n  );\n};\n\n// WebPImage.tsx - WebP with fallback\ninterface WebPImageProps {\n  src: string;\n  webpSrc: string;\n  alt: string;\n  className?: string;\n}\n\nexport const WebPImage: React.FC<WebPImageProps> = ({\n  src,\n  webpSrc,\n  alt,\n  className\n}) => {\n  return (\n    <picture>\n      <source srcSet={webpSrc} type=\"image/webp\" />\n      <source srcSet={src} type=\"image/jpeg\" />\n      <img \n        src={src} \n        alt={alt} \n        className={className}\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </picture>\n  );\n};\n```\n\n### Example 6: Bundle Analysis and Code Splitting Strategy\n\n```typescript\n// webpack.config.js - Webpack configuration for optimization\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nconst CompressionPlugin = require('compression-webpack-plugin');\n\nmodule.exports = {\n  mode: 'production',\n  entry: './src/index.tsx',\n  output: {\n    filename: '[name].[contenthash].js',\n    chunkFilename: '[name].[contenthash].chunk.js',\n    path: path.resolve(__dirname, 'dist'),\n    clean: true\n  },\n  optimization: {\n    moduleIds: 'deterministic',\n    runtimeChunk: 'single',\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        // Vendor splitting\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          priority: 10\n        },\n        // React and friends in separate chunk\n        react: {\n          test: /[\\\\/]node_modules[\\\\/](react|react-dom|react-router-dom)[\\\\/]/,\n          name: 'react-vendor',\n          priority: 20\n        },\n        // Common code used across multiple chunks\n        common: {\n          minChunks: 2,\n          priority: 5,\n          reuseExistingChunk: true,\n          enforce: true\n        }\n      }\n    },\n    minimize: true,\n    minimizer: [\n      new TerserPlugin({\n        terserOptions: {\n          compress: {\n            drop_console: true,\n          },\n        },\n      }),\n    ],\n  },\n  plugins: [\n    new BundleAnalyzerPlugin({\n      analyzerMode: 'static',\n      openAnalyzer: false,\n      reportFilename: 'bundle-report.html'\n    }),\n    new CompressionPlugin({\n      filename: '[path][base].gz',\n      algorithm: 'gzip',\n      test: /\\.(js|css|html|svg)$/,\n      threshold: 8192,\n      minRatio: 0.8\n    })\n  ]\n};\n\n// Dynamic imports for heavy libraries\n// ChartComponent.tsx\nimport React, { useState, useEffect } from 'react';\n\ninterface ChartData {\n  labels: string[];\n  datasets: any[];\n}\n\ninterface ChartComponentProps {\n  data: ChartData;\n}\n\nexport const ChartComponent: React.FC<ChartComponentProps> = ({ data }) => {\n  const [Chart, setChart] = useState<any>(null);\n\n  useEffect(() => {\n    // Dynamically import Chart.js only when needed\n    import('chart.js/auto').then((module) => {\n      setChart(() => module.Chart);\n    });\n  }, []);\n\n  if (!Chart) {\n    return <div>Loading chart...</div>;\n  }\n\n  return (\n    <canvas ref={(canvas) => {\n      if (canvas) {\n        new Chart(canvas, {\n          type: 'bar',\n          data: data,\n          options: {\n            responsive: true,\n            maintainAspectRatio: false\n          }\n        });\n      }\n    }} />\n  );\n};\n```\n\n### Example 7: React Suspense and Concurrent Features\n\n```typescript\n// Using React 18 concurrent features\nimport React, { Suspense, useTransition, useDeferredValue, useState } from 'react';\n\ninterface SearchResultsProps {\n  query: string;\n}\n\nconst SearchResults: React.FC<SearchResultsProps> = ({ query }) => {\n  // Simulate expensive filtering operation\n  const results = expensiveSearch(query);\n  \n  return (\n    <ul>\n      {results.map(result => (\n        <li key={result.id}>{result.title}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport const SearchPage: React.FC = () => {\n  const [query, setQuery] = useState('');\n  const [isPending, startTransition] = useTransition();\n  const deferredQuery = useDeferredValue(query);\n\n  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    \n    // Update input immediately\n    setQuery(value);\n    \n    // Defer expensive search update\n    startTransition(() => {\n      // This update is marked as non-urgent\n      // React can interrupt it for more urgent updates\n    });\n  };\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={query}\n        onChange={handleSearch}\n        placeholder=\"Search...\"\n      />\n      \n      {isPending && <div className=\"spinner\">Searching...</div>}\n      \n      <Suspense fallback={<div>Loading results...</div>}>\n        <SearchResults query={deferredQuery} />\n      </Suspense>\n    </div>\n  );\n};\n\n// SuspenseImage.tsx - Image loading with Suspense\nconst imageCache = new Map<string, Promise<string>>();\n\nconst loadImage = (src: string): Promise<string> => {\n  if (imageCache.has(src)) {\n    return imageCache.get(src)!;\n  }\n\n  const promise = new Promise<string>((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(src);\n    img.onerror = reject;\n    img.src = src;\n  });\n\n  imageCache.set(src, promise);\n  return promise;\n};\n\nconst SuspenseImage: React.FC<{ src: string; alt: string }> = ({ src, alt }) => {\n  // This will suspend the component until the image loads\n  const imageSrc = use(loadImage(src));\n  \n  return <img src={imageSrc} alt={alt} />;\n};\n\nexport const ImageGallery: React.FC<{ images: string[] }> = ({ images }) => {\n  return (\n    <div className=\"gallery\">\n      {images.map((src, index) => (\n        <Suspense key={src} fallback={<ImageSkeleton />}>\n          <SuspenseImage src={src} alt={`Image ${index + 1}`} />\n        </Suspense>\n      ))}\n    </div>\n  );\n};\n```\n\n### Example 8: Performance Monitoring\n\n```typescript\n// PerformanceMonitor.tsx\nimport { useEffect } from 'react';\n\nexport const usePerformanceMonitor = (componentName: string) => {\n  useEffect(() => {\n    const observer = new PerformanceObserver((list) => {\n      for (const entry of list.getEntries()) {\n        console.log(`${componentName} - ${entry.name}:`, entry.duration);\n      }\n    });\n\n    observer.observe({ entryTypes: ['measure'] });\n\n    return () => observer.disconnect();\n  }, [componentName]);\n};\n\n// Usage\nexport const HeavyComponent: React.FC = () => {\n  usePerformanceMonitor('HeavyComponent');\n\n  useEffect(() => {\n    performance.mark('heavy-start');\n    \n    // Expensive operation\n    const result = expensiveCalculation();\n    \n    performance.mark('heavy-end');\n    performance.measure('heavy-calculation', 'heavy-start', 'heavy-end');\n  }, []);\n\n  return <div>Heavy Component</div>;\n};\n\n// Web Vitals tracking\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nconst sendToAnalytics = (metric: any) => {\n  const body = JSON.stringify(metric);\n  const url = '/analytics';\n  \n  if (navigator.sendBeacon) {\n    navigator.sendBeacon(url, body);\n  } else {\n    fetch(url, { body, method: 'POST', keepalive: true });\n  }\n};\n\nexport const measureWebVitals = () => {\n  getCLS(sendToAnalytics);\n  getFID(sendToAnalytics);\n  getFCP(sendToAnalytics);\n  getLCP(sendToAnalytics);\n  getTTFB(sendToAnalytics);\n};\n```\n\n## Performance Checklist\n\n### Initial Load Performance\n- [ ] Implement code splitting at route boundaries\n- [ ] Lazy load non-critical components\n- [ ] Optimize bundle size (< 200KB initial)\n- [ ] Enable compression (gzip/brotli)\n- [ ] Use CDN for static assets\n- [ ] Implement service worker for caching\n\n### Runtime Performance\n- [ ] Use React.memo for expensive components\n- [ ] Memoize callbacks with useCallback\n- [ ] Memoize expensive computations with useMemo\n- [ ] Implement virtualization for long lists\n- [ ] Debounce/throttle frequent operations\n- [ ] Use CSS instead of JS for animations\n\n### Asset Optimization\n- [ ] Lazy load images with loading=\"lazy\"\n- [ ] Use modern image formats (WebP, AVIF)\n- [ ] Implement responsive images with srcset\n- [ ] Compress images (TinyPNG, ImageOptim)\n- [ ] Use SVG for icons and simple graphics\n\n### Monitoring\n- [ ] Set up bundle analysis\n- [ ] Monitor Core Web Vitals\n- [ ] Use React DevTools Profiler\n- [ ] Implement performance budgets\n- [ ] Track real user metrics (RUM)\n\nThis skill provides production-ready patterns for comprehensive React performance optimization.",
  "prompt": "A skill that provides comprehensive React performance optimization strategies including lazy loading, code splitting, memoization techniques, bundle analysis, virtual scrolling, image optimization, and advanced performance patterns for building fast, efficient React applications.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
