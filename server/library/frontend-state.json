{
  "id": "frontend-state",
  "name": "State Management Pro",
  "description": "State management patterns with Zustand, Context API, React Query, and best practices for managing application state",
  "category": "Frontend",
  "content": "---\nname: State Management Pro\ndescription: State management patterns with Zustand, Context API, React Query, and best practices for managing application state\ncategory: Frontend\n---\n\n# State Management Pro\n\n## Overview\n\nThis skill provides expert guidance on state management in React applications, including Zustand, Context API, React Query, local state patterns, and best practices. It helps you choose the right state management solution and implement it effectively.\n\n## Activation\n\nUse this skill when:\n- Managing global state in React apps\n- Implementing data fetching and caching\n- Building complex state logic\n- Optimizing component re-renders\n- Choosing between state management solutions\n- Working with server state vs client state\n- Implementing state persistence\n\n## Instructions\n\n### 1. Local State with useState\n\n**Basic Usage:**\n```jsx\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prev => prev - 1)}>Decrement</button>\n    </div>\n  );\n}\n\n// Complex state\nfunction Form() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    message: '',\n  });\n  \n  const handleChange = (e) => {\n    setFormData(prev => ({\n      ...prev,\n      [e.target.name]: e.target.value,\n    }));\n  };\n  \n  return (\n    <form>\n      <input name=\"name\" value={formData.name} onChange={handleChange} />\n      <input name=\"email\" value={formData.email} onChange={handleChange} />\n      <textarea name=\"message\" value={formData.message} onChange={handleChange} />\n    </form>\n  );\n}\n```\n\n**useReducer for Complex State:**\n```jsx\nimport { useReducer } from 'react';\n\ntype State = {\n  count: number;\n  step: number;\n};\n\ntype Action =\n  | { type: 'increment' }\n  | { type: 'decrement' }\n  | { type: 'reset' }\n  | { type: 'setStep'; payload: number };\n\nconst initialState: State = {\n  count: 0,\n  step: 1,\n};\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'increment':\n      return { ...state, count: state.count + state.step };\n    case 'decrement':\n      return { ...state, count: state.count - state.step };\n    case 'reset':\n      return initialState;\n    case 'setStep':\n      return { ...state, step: action.payload };\n    default:\n      return state;\n  }\n}\n\nfunction AdvancedCounter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <p>Step: {state.step}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n      <input\n        type=\"number\"\n        value={state.step}\n        onChange={(e) => dispatch({ type: 'setStep', payload: Number(e.target.value) })}\n      />\n    </div>\n  );\n}\n```\n\n### 2. Context API\n\n**Basic Context Setup:**\n```tsx\nimport { createContext, useContext, useState, ReactNode } from 'react';\n\ninterface ThemeContextType {\n  theme: 'light' | 'dark';\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport function ThemeProvider({ children }: { children: ReactNode }) {\n  const [theme, setTheme] = useState<'light' | 'dark'>('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n\n// Usage\nfunction App() {\n  return (\n    <ThemeProvider>\n      <Header />\n      <Main />\n    </ThemeProvider>\n  );\n}\n\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <header className={theme}>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </header>\n  );\n}\n```\n\n**Complex Context with Reducer:**\n```tsx\nimport { createContext, useContext, useReducer, ReactNode } from 'react';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface AuthState {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\ntype AuthAction =\n  | { type: 'LOGIN_START' }\n  | { type: 'LOGIN_SUCCESS'; payload: User }\n  | { type: 'LOGIN_FAILURE'; payload: string }\n  | { type: 'LOGOUT' };\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: false,\n  error: null,\n};\n\nfunction authReducer(state: AuthState, action: AuthAction): AuthState {\n  switch (action.type) {\n    case 'LOGIN_START':\n      return { ...state, isLoading: true, error: null };\n    case 'LOGIN_SUCCESS':\n      return {\n        user: action.payload,\n        isAuthenticated: true,\n        isLoading: false,\n        error: null,\n      };\n    case 'LOGIN_FAILURE':\n      return {\n        ...state,\n        isLoading: false,\n        error: action.payload,\n      };\n    case 'LOGOUT':\n      return initialState;\n    default:\n      return state;\n  }\n}\n\ninterface AuthContextType extends AuthState {\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n  \n  const login = async (email: string, password: string) => {\n    dispatch({ type: 'LOGIN_START' });\n    \n    try {\n      const response = await fetch('/api/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, password }),\n      });\n      \n      if (!response.ok) throw new Error('Login failed');\n      \n      const user = await response.json();\n      dispatch({ type: 'LOGIN_SUCCESS', payload: user });\n    } catch (error) {\n      dispatch({ \n        type: 'LOGIN_FAILURE', \n        payload: error instanceof Error ? error.message : 'Unknown error' \n      });\n    }\n  };\n  \n  const logout = () => {\n    dispatch({ type: 'LOGOUT' });\n  };\n  \n  return (\n    <AuthContext.Provider value={{ ...state, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n```\n\n### 3. Zustand\n\n**Installation:**\n```bash\nnpm install zustand\n```\n\n**Basic Store:**\n```tsx\nimport { create } from 'zustand';\n\ninterface BearState {\n  bears: number;\n  increasePopulation: () => void;\n  removeAllBears: () => void;\n}\n\nconst useBearStore = create<BearState>((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}));\n\n// Usage\nfunction BearCounter() {\n  const bears = useBearStore((state) => state.bears);\n  return <h1>{bears} around here...</h1>;\n}\n\nfunction Controls() {\n  const increasePopulation = useBearStore((state) => state.increasePopulation);\n  return <button onClick={increasePopulation}>Add Bear</button>;\n}\n```\n\n**Complex Store with TypeScript:**\n```tsx\nimport { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\nimport { immer } from 'zustand/middleware/immer';\n\ninterface Todo {\n  id: string;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoState {\n  todos: Todo[];\n  filter: 'all' | 'active' | 'completed';\n  addTodo: (text: string) => void;\n  toggleTodo: (id: string) => void;\n  deleteTodo: (id: string) => void;\n  setFilter: (filter: TodoState['filter']) => void;\n  clearCompleted: () => void;\n}\n\nconst useTodoStore = create<TodoState>()()\n  devtools(\n    persist(\n      immer((set) => ({\n        todos: [],\n        filter: 'all',\n        \n        addTodo: (text) =>\n          set((state) => {\n            state.todos.push({\n              id: Date.now().toString(),\n              text,\n              completed: false,\n            });\n          }),\n        \n        toggleTodo: (id) =>\n          set((state) => {\n            const todo = state.todos.find((t) => t.id === id);\n            if (todo) {\n              todo.completed = !todo.completed;\n            }\n          }),\n        \n        deleteTodo: (id) =>\n          set((state) => {\n            state.todos = state.todos.filter((t) => t.id !== id);\n          }),\n        \n        setFilter: (filter) =>\n          set({ filter }),\n        \n        clearCompleted: () =>\n          set((state) => {\n            state.todos = state.todos.filter((t) => !t.completed);\n          }),\n      })),\n      { name: 'todo-storage' }\n    )\n  )\n);\n\n// Selectors\nconst selectFilteredTodos = (state: TodoState) => {\n  switch (state.filter) {\n    case 'active':\n      return state.todos.filter((t) => !t.completed);\n    case 'completed':\n      return state.todos.filter((t) => t.completed);\n    default:\n      return state.todos;\n  }\n};\n\n// Usage\nfunction TodoList() {\n  const todos = useTodoStore(selectFilteredTodos);\n  const toggleTodo = useTodoStore((state) => state.toggleTodo);\n  const deleteTodo = useTodoStore((state) => state.deleteTodo);\n  \n  return (\n    <ul>\n      {todos.map((todo) => (\n        <li key={todo.id}>\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={() => toggleTodo(todo.id)}\n          />\n          <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n            {todo.text}\n          </span>\n          <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Slices Pattern:**\n```tsx\nimport { create } from 'zustand';\n\ninterface UserSlice {\n  user: User | null;\n  setUser: (user: User | null) => void;\n}\n\ninterface SettingsSlice {\n  theme: 'light' | 'dark';\n  notifications: boolean;\n  setTheme: (theme: 'light' | 'dark') => void;\n  toggleNotifications: () => void;\n}\n\nconst createUserSlice = (set): UserSlice => ({\n  user: null,\n  setUser: (user) => set({ user }),\n});\n\nconst createSettingsSlice = (set): SettingsSlice => ({\n  theme: 'light',\n  notifications: true,\n  setTheme: (theme) => set({ theme }),\n  toggleNotifications: () => set((state) => ({ \n    notifications: !state.notifications \n  })),\n});\n\ntype StoreState = UserSlice & SettingsSlice;\n\nconst useStore = create<StoreState>()((...a) => ({\n  ...createUserSlice(...a),\n  ...createSettingsSlice(...a),\n}));\n```\n\n### 4. React Query (TanStack Query)\n\n**Installation:**\n```bash\nnpm install @tanstack/react-query\n```\n\n**Setup:**\n```tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 60 * 1000, // 1 minute\n      cacheTime: 5 * 60 * 1000, // 5 minutes\n      refetchOnWindowFocus: false,\n      retry: 1,\n    },\n  },\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <YourApp />\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n```\n\n**Basic Query:**\n```tsx\nimport { useQuery } from '@tanstack/react-query';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, isLoading, error } = useQuery({\n    queryKey: ['user', userId],\n    queryFn: async () => {\n      const response = await fetch(`/api/users/${userId}`);\n      if (!response.ok) throw new Error('Failed to fetch user');\n      return response.json() as Promise<User>;\n    },\n  });\n  \n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  \n  return (\n    <div>\n      <h2>{data.name}</h2>\n      <p>{data.email}</p>\n    </div>\n  );\n}\n```\n\n**Mutations:**\n```tsx\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n\nfunction CreateUserForm() {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: async (newUser: Omit<User, 'id'>) => {\n      const response = await fetch('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(newUser),\n      });\n      if (!response.ok) throw new Error('Failed to create user');\n      return response.json();\n    },\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n  });\n  \n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const formData = new FormData(e.currentTarget);\n    mutation.mutate({\n      name: formData.get('name') as string,\n      email: formData.get('email') as string,\n    });\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"name\" required />\n      <input name=\"email\" type=\"email\" required />\n      <button type=\"submit\" disabled={mutation.isPending}>\n        {mutation.isPending ? 'Creating...' : 'Create User'}\n      </button>\n      {mutation.isError && <div>Error: {mutation.error.message}</div>}\n      {mutation.isSuccess && <div>User created successfully!</div>}\n    </form>\n  );\n}\n```\n\n**Optimistic Updates:**\n```tsx\nfunction TodoItem({ todo }: { todo: Todo }) {\n  const queryClient = useQueryClient();\n  \n  const mutation = useMutation({\n    mutationFn: async (id: string) => {\n      const response = await fetch(`/api/todos/${id}/toggle`, {\n        method: 'PATCH',\n      });\n      return response.json();\n    },\n    onMutate: async (id) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n      \n      // Snapshot previous value\n      const previousTodos = queryClient.getQueryData(['todos']);\n      \n      // Optimistically update\n      queryClient.setQueryData(['todos'], (old: Todo[]) =>\n        old.map((t) =>\n          t.id === id ? { ...t, completed: !t.completed } : t\n        )\n      );\n      \n      return { previousTodos };\n    },\n    onError: (err, id, context) => {\n      // Rollback on error\n      queryClient.setQueryData(['todos'], context?.previousTodos);\n    },\n    onSettled: () => {\n      // Refetch after success or error\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n    },\n  });\n  \n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        checked={todo.completed}\n        onChange={() => mutation.mutate(todo.id)}\n      />\n      {todo.text}\n    </div>\n  );\n}\n```\n\n**Infinite Queries:**\n```tsx\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\nfunction InfiniteUsers() {\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery({\n    queryKey: ['users'],\n    queryFn: async ({ pageParam = 1 }) => {\n      const response = await fetch(`/api/users?page=${pageParam}`);\n      return response.json();\n    },\n    getNextPageParam: (lastPage, pages) => {\n      return lastPage.hasMore ? pages.length + 1 : undefined;\n    },\n    initialPageParam: 1,\n  });\n  \n  return (\n    <div>\n      {data?.pages.map((page, i) => (\n        <div key={i}>\n          {page.users.map((user) => (\n            <div key={user.id}>{user.name}</div>\n          ))}\n        </div>\n      ))}\n      \n      <button\n        onClick={() => fetchNextPage()}\n        disabled={!hasNextPage || isFetchingNextPage}\n      >\n        {isFetchingNextPage\n          ? 'Loading more...'\n          : hasNextPage\n          ? 'Load More'\n          : 'Nothing more to load'}\n      </button>\n    </div>\n  );\n}\n```\n\n### 5. State Persistence\n\n**LocalStorage with Zustand:**\n```tsx\nimport { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\n\nconst useStore = create(\n  persist(\n    (set) => ({\n      user: null,\n      setUser: (user) => set({ user }),\n    }),\n    {\n      name: 'user-storage',\n      storage: createJSONStorage(() => localStorage),\n    }\n  )\n);\n```\n\n**Custom Hook for LocalStorage:**\n```tsx\nimport { useState, useEffect } from 'react';\n\nfunction useLocalStorage<T>(key: string, initialValue: T) {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n      return initialValue;\n    }\n  });\n  \n  const setValue = (value: T | ((val: T) => T)) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n  \n  return [storedValue, setValue] as const;\n}\n\n// Usage\nfunction App() {\n  const [theme, setTheme] = useLocalStorage('theme', 'light');\n  \n  return (\n    <div className={theme}>\n      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>\n        Toggle Theme\n      </button>\n    </div>\n  );\n}\n```\n\n### 6. Performance Optimization\n\n**Prevent Unnecessary Re-renders:**\n```tsx\nimport { memo, useMemo, useCallback } from 'react';\n\n// Memoize component\nconst ExpensiveComponent = memo(({ data, onUpdate }) => {\n  return <div>{/* ... */}</div>;\n});\n\n// Memoize values\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [items, setItems] = useState([]);\n  \n  // Only recalculate when items change\n  const expensiveValue = useMemo(() => {\n    return items.reduce((acc, item) => acc + item.value, 0);\n  }, [items]);\n  \n  // Stable callback reference\n  const handleUpdate = useCallback((id) => {\n    setItems(prev => prev.map(item =>\n      item.id === id ? { ...item, updated: true } : item\n    ));\n  }, []);\n  \n  return <ExpensiveComponent data={expensiveValue} onUpdate={handleUpdate} />;\n}\n```\n\n**Zustand Selectors:**\n```tsx\n// ❌ Bad: Component re-renders on any state change\nfunction BadComponent() {\n  const store = useStore();\n  return <div>{store.user.name}</div>;\n}\n\n// ✅ Good: Only re-renders when user.name changes\nfunction GoodComponent() {\n  const userName = useStore((state) => state.user.name);\n  return <div>{userName}</div>;\n}\n\n// ✅ Better: Use shallow comparison for objects\nimport { shallow } from 'zustand/shallow';\n\nfunction BestComponent() {\n  const { name, email } = useStore(\n    (state) => ({ name: state.user.name, email: state.user.email }),\n    shallow\n  );\n  return <div>{name} - {email}</div>;\n}\n```\n\n## Examples\n\n### Example 1: E-commerce Cart\n\n```tsx\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\ninterface CartItem {\n  id: string;\n  name: string;\n  price: number;\n  quantity: number;\n}\n\ninterface CartStore {\n  items: CartItem[];\n  addItem: (item: Omit<CartItem, 'quantity'>) => void;\n  removeItem: (id: string) => void;\n  updateQuantity: (id: string, quantity: number) => void;\n  clearCart: () => void;\n  total: number;\n}\n\nconst useCartStore = create<CartStore>()(  persist(\n    (set, get) => ({\n      items: [],\n      \n      addItem: (item) =>\n        set((state) => {\n          const existingItem = state.items.find((i) => i.id === item.id);\n          if (existingItem) {\n            return {\n              items: state.items.map((i) =>\n                i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i\n              ),\n            };\n          }\n          return { items: [...state.items, { ...item, quantity: 1 }] };\n        }),\n      \n      removeItem: (id) =>\n        set((state) => ({\n          items: state.items.filter((i) => i.id !== id),\n        })),\n      \n      updateQuantity: (id, quantity) =>\n        set((state) => ({\n          items: state.items.map((i) =>\n            i.id === id ? { ...i, quantity } : i\n          ),\n        })),\n      \n      clearCart: () => set({ items: [] }),\n      \n      get total() {\n        return get().items.reduce(\n          (sum, item) => sum + item.price * item.quantity,\n          0\n        );\n      },\n    }),\n    { name: 'cart-storage' }\n  )\n);\n\n// Usage\nfunction Cart() {\n  const items = useCartStore((state) => state.items);\n  const total = useCartStore((state) => state.total);\n  const removeItem = useCartStore((state) => state.removeItem);\n  const updateQuantity = useCartStore((state) => state.updateQuantity);\n  \n  return (\n    <div>\n      <h2>Shopping Cart</h2>\n      {items.map((item) => (\n        <div key={item.id}>\n          <span>{item.name}</span>\n          <span>${item.price}</span>\n          <input\n            type=\"number\"\n            value={item.quantity}\n            onChange={(e) => updateQuantity(item.id, Number(e.target.value))}\n          />\n          <button onClick={() => removeItem(item.id)}>Remove</button>\n        </div>\n      ))}\n      <div>Total: ${total}</div>\n    </div>\n  );\n}\n```\n\n### Example 2: Data Fetching with React Query\n\n```tsx\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\n\nfunction PostsList() {\n  const { data: posts, isLoading } = useQuery({\n    queryKey: ['posts'],\n    queryFn: async () => {\n      const res = await fetch('/api/posts');\n      return res.json();\n    },\n  });\n  \n  if (isLoading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      {posts.map((post) => (\n        <PostItem key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n\nfunction PostItem({ post }) {\n  const queryClient = useQueryClient();\n  \n  const likeMutation = useMutation({\n    mutationFn: async (postId) => {\n      const res = await fetch(`/api/posts/${postId}/like`, {\n        method: 'POST',\n      });\n      return res.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['posts'] });\n    },\n  });\n  \n  return (\n    <div>\n      <h3>{post.title}</h3>\n      <p>{post.content}</p>\n      <button onClick={() => likeMutation.mutate(post.id)}>\n        Like ({post.likes})\n      </button>\n    </div>\n  );\n}\n```\n\n## Best Practices\n\n1. **Choose the right tool**: Local state → useState, Global UI state → Zustand/Context, Server state → React Query\n2. **Use selectors** to prevent unnecessary re-renders\n3. **Normalize state** for complex data structures\n4. **Keep state close** to where it's used\n5. **Use TypeScript** for type safety\n6. **Persist wisely**: Only persist what's necessary\n7. **Optimize with useMemo/useCallback** when needed\n8. **Separate concerns**: UI state vs server state\n9. **Use DevTools** for debugging (Redux DevTools, React Query DevTools)\n10. **Test state logic** independently from components\n",
  "prompt": "A skill that provides comprehensive state management expertise including Zustand, Context API, React Query, local state patterns, performance optimization, and best practices for managing application state in React.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
