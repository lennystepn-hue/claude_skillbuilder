{
  "id": "project-task-breakdown",
  "name": "Task Breakdown",
  "description": "Break down features and user stories into actionable development tasks using work breakdown structure, task dependencies, and resource allocation techniques",
  "category": "Project",
  "content": "---\nname: Task Breakdown\ndescription: Break down features and user stories into actionable development tasks using work breakdown structure, task dependencies, and resource allocation techniques\ncategory: Project\n---\n\n# Task Breakdown\n\n## Overview\n\nThis skill helps break down complex features and user stories into small, manageable development tasks. It provides structured approaches to create work breakdown structures (WBS), identify dependencies, estimate effort at the task level, and allocate resources effectively.\n\n## Activation\n\nThis skill activates when you need to:\n- Break down user stories into development tasks\n- Create a work breakdown structure for a project or feature\n- Decompose epics into stories and tasks\n- Identify task dependencies and critical paths\n- Plan detailed implementation steps\n- Allocate tasks to team members\n- Create detailed sprint execution plans\n\n## Instructions\n\nWhen activated, this skill will:\n\n1. **Story Analysis**\n   - Review user story requirements and acceptance criteria\n   - Identify technical components and layers\n   - Determine cross-cutting concerns\n   - List external dependencies\n\n2. **Task Decomposition**\n   - Break story into atomic development tasks\n   - Ensure tasks are independently testable\n   - Size tasks to 2-8 hours each\n   - Define clear completion criteria\n\n3. **Dependency Mapping**\n   - Identify task prerequisites\n   - Create dependency graph\n   - Determine parallel vs. sequential work\n   - Highlight critical path\n\n4. **Resource Allocation**\n   - Match tasks to team member skills\n   - Balance workload across team\n   - Identify pairing opportunities\n   - Plan knowledge transfer\n\n5. **Estimation & Sequencing**\n   - Estimate hours per task\n   - Sequence tasks optimally\n   - Identify risks and buffers\n   - Create daily execution plan\n\n## Templates\n\n### Task Breakdown Template\n\n```markdown\n# Task Breakdown: [User Story ID] - [Story Title]\n\n## Story Summary\n**Story Points**: [points]\n**Estimated Hours**: [hours]\n**Assignee**: [team member or TBD]\n**Sprint**: [sprint number]\n\n## Technical Components\n- [ ] Frontend/UI\n- [ ] Backend/API\n- [ ] Database\n- [ ] Integration/External Services\n- [ ] Testing\n- [ ] Documentation\n- [ ] DevOps/Deployment\n\n## Task List\n\n### Frontend Tasks\n- [ ] **F1**: [Task description] - [Est: Xh] - [Owner: Name]\n- [ ] **F2**: [Task description] - [Est: Xh] - [Owner: Name]\n\n### Backend Tasks\n- [ ] **B1**: [Task description] - [Est: Xh] - [Owner: Name]\n- [ ] **B2**: [Task description] - [Est: Xh] - [Owner: Name]\n\n### Database Tasks\n- [ ] **D1**: [Task description] - [Est: Xh] - [Owner: Name]\n\n### Testing Tasks\n- [ ] **T1**: [Task description] - [Est: Xh] - [Owner: Name]\n- [ ] **T2**: [Task description] - [Est: Xh] - [Owner: Name]\n\n### Documentation Tasks\n- [ ] **DOC1**: [Task description] - [Est: Xh] - [Owner: Name]\n\n## Task Dependencies\n```mermaid\ngraph TD\n    D1[Database Schema] --> B1[Create API]\n    D1 --> B2[Add Validation]\n    B1 --> F1[UI Component]\n    B2 --> F1\n    F1 --> T1[Integration Tests]\n    B1 --> T2[API Tests]\n```\n\n## Critical Path\n1. D1 (Database) → B1 (API) → F1 (UI) → T1 (Integration Tests)\n   Total: [sum hours]\n\n## Parallel Work Opportunities\n- F2 can be done alongside F1\n- T2 can be done alongside F1\n- DOC1 can be done anytime after B1\n\n## Daily Execution Plan\n\n**Day 1**\n- Morning: D1, B2\n- Afternoon: B1\n\n**Day 2**\n- Morning: F1, T2\n- Afternoon: F2, T1\n\n**Day 3**\n- Morning: Integration, bug fixes\n- Afternoon: DOC1, code review\n\n## Risk Items\n- [ ] [Risk description] - Mitigation: [strategy]\n```\n\n### Work Breakdown Structure Template\n\n```markdown\n# Work Breakdown Structure: [Feature/Epic Name]\n\n## Level 1: Epic\n[Epic ID] - [Epic Title]\n\n## Level 2: User Stories\n\n### 1. [Story ID] - [Story Title]\n**Value**: [High/Medium/Low]\n**Dependencies**: [Story IDs]\n**Estimated**: [points/hours]\n\n#### Level 3: Development Tasks\n\n##### Frontend\n- 1.1: Create component structure [4h]\n- 1.2: Implement form validation [3h]\n- 1.3: Add error handling [2h]\n- 1.4: Style components [3h]\n\n##### Backend\n- 1.5: Create database migration [2h]\n- 1.6: Implement API endpoint [4h]\n- 1.7: Add business logic [4h]\n- 1.8: Implement error handling [2h]\n\n##### Testing\n- 1.9: Unit tests for API [3h]\n- 1.10: Unit tests for UI [3h]\n- 1.11: Integration tests [4h]\n- 1.12: E2E test scenarios [3h]\n\n##### DevOps\n- 1.13: Update CI/CD pipeline [2h]\n- 1.14: Configure environment variables [1h]\n- 1.15: Deploy to staging [1h]\n\n**Subtotal**: [sum hours]\n\n### 2. [Story ID] - [Story Title]\n[Repeat structure]\n\n## Total Estimates\n- Total Tasks: [count]\n- Total Hours: [sum]\n- Total Story Points: [sum]\n- Team Capacity: [hours]\n- Buffer: [percent]\n```\n\n### Task Card Template\n\n```markdown\n# Task: [Task ID] - [Task Title]\n\n## Description\n[Clear, concise description of what needs to be done]\n\n## Acceptance Criteria\n- [ ] [Specific criterion 1]\n- [ ] [Specific criterion 2]\n- [ ] [Specific criterion 3]\n\n## Technical Details\n**Files to Modify**:\n- [file path 1]\n- [file path 2]\n\n**APIs/Endpoints**:\n- [endpoint description]\n\n**Database Changes**:\n- [schema changes]\n\n**Dependencies**:\n- Requires: [Task IDs]\n- Blocks: [Task IDs]\n\n## Implementation Notes\n```\n[Code snippets, pseudocode, or technical guidance]\n```\n\n## Testing Requirements\n- [ ] Unit tests added/updated\n- [ ] Integration tests added/updated\n- [ ] Manual testing steps: [describe]\n\n## Estimation\n**Original Estimate**: [hours]\n**Time Spent**: [hours]\n**Remaining**: [hours]\n\n## Owner\n**Assigned To**: [Name]\n**Status**: [Not Started | In Progress | Code Review | Testing | Done]\n**Priority**: [P0 | P1 | P2 | P3]\n```\n\n## Examples\n\n### Example 1: E-commerce Product Search Feature\n\n**User Story**: US-245 - Advanced Product Search with Filters\n\n```markdown\n# Task Breakdown: US-245 - Advanced Product Search\n\n## Story Summary\n**Story Points**: 8\n**Estimated Hours**: 32\n**Sprint**: Sprint 28\n\n## Technical Components\n- ✓ Frontend (React)\n- ✓ Backend (Node.js/Express)\n- ✓ Database (Elasticsearch)\n- ✓ Testing\n- ✓ Documentation\n\n## Detailed Task Breakdown\n\n### Phase 1: Database & Search Infrastructure (8h)\n\n**D1: Set up Elasticsearch index for products** [3h] - @DevOps_Dave\n- Create product index schema\n- Configure analyzers for text search\n- Set up synonyms dictionary\n- Configure index settings (shards, replicas)\n\nAcceptance:\n- [ ] Index created with proper mappings\n- [ ] Test data indexed successfully\n- [ ] Search queries return results in <100ms\n\n**D2: Create product data sync job** [3h] - @Backend_Bob\n- Build ETL job to sync from PostgreSQL to Elasticsearch\n- Handle incremental updates\n- Add error handling and retry logic\n- Schedule job to run every 5 minutes\n\nAcceptance:\n- [ ] Initial sync completes successfully\n- [ ] Incremental updates work correctly\n- [ ] Failed syncs are retried with exponential backoff\n\n**D3: Add search query builder** [2h] - @Backend_Bob\n- Create query builder for multi-field search\n- Implement filter logic (price, category, brand, rating)\n- Add sorting options (relevance, price, rating, newest)\n- Implement pagination\n\nAcceptance:\n- [ ] Queries handle multiple filters correctly\n- [ ] Sorting works for all options\n- [ ] Pagination returns correct page sizes\n\n### Phase 2: Backend API (10h)\n\n**B1: Create search API endpoint** [4h] - @Backend_Bob\n- POST /api/v1/products/search\n- Accept query, filters, sort, pagination params\n- Call Elasticsearch with built query\n- Transform results to API response format\n- Add response caching (Redis, 5min TTL)\n\nAcceptance:\n- [ ] Endpoint returns results in <200ms\n- [ ] Handles empty results gracefully\n- [ ] Validates input parameters\n- [ ] Cached responses improve performance\n\nFiles:\n- `src/api/routes/products.js`\n- `src/services/searchService.js`\n- `src/utils/queryBuilder.js`\n\n**B2: Implement search analytics tracking** [3h] - @Backend_Bob\n- Log search queries and results count\n- Track filter usage\n- Record click-through rates\n- Store in analytics database\n\nAcceptance:\n- [ ] All searches logged asynchronously\n- [ ] No impact on search response time\n- [ ] Analytics queryable for reports\n\n**B3: Add search suggestions/autocomplete** [3h] - @Backend_Sarah\n- GET /api/v1/products/suggestions?q={query}\n- Use Elasticsearch completion suggester\n- Return top 10 suggestions\n- Cache popular queries\n\nAcceptance:\n- [ ] Suggestions return in <50ms\n- [ ] Relevant suggestions for partial queries\n- [ ] Handles typos with fuzzy matching\n\n### Phase 3: Frontend Implementation (10h)\n\n**F1: Create search input component** [2h] - @Frontend_Fiona\n- Search bar with autocomplete dropdown\n- Debounced input (300ms)\n- Keyboard navigation support\n- Clear button\n\nAcceptance:\n- [ ] Autocomplete shows after 2 characters\n- [ ] Arrow keys navigate suggestions\n- [ ] Enter key submits search\n- [ ] Accessible (ARIA labels, keyboard support)\n\nFiles:\n- `src/components/SearchBar.jsx`\n- `src/components/SearchBar.test.jsx`\n- `src/components/SearchBar.module.css`\n\n**F2: Build filter sidebar component** [3h] - @Frontend_Fiona\n- Category filter (checkboxes, hierarchical)\n- Price range filter (slider)\n- Brand filter (checkboxes with search)\n- Rating filter (star selection)\n- \"Clear All Filters\" button\n\nAcceptance:\n- [ ] Multiple filters can be applied\n- [ ] Filter counts update dynamically\n- [ ] Mobile-responsive (drawer on mobile)\n- [ ] Filter state persists in URL\n\nFiles:\n- `src/components/FilterSidebar.jsx`\n- `src/components/filters/CategoryFilter.jsx`\n- `src/components/filters/PriceRangeFilter.jsx`\n- `src/components/filters/BrandFilter.jsx`\n\n**F3: Create search results component** [3h] - @Frontend_Fred\n- Product grid/list view toggle\n- Result count display\n- Sort dropdown\n- Pagination controls\n- Loading states\n- Empty state\n\nAcceptance:\n- [ ] Results display in grid and list views\n- [ ] Sorting updates results immediately\n- [ ] Pagination works correctly\n- [ ] Loading spinner shows during fetch\n\nFiles:\n- `src/components/SearchResults.jsx`\n- `src/components/ProductCard.jsx`\n- `src/components/Pagination.jsx`\n\n**F4: Integrate search state management** [2h] - @Frontend_Fiona\n- Create Redux slice for search state\n- Actions: updateQuery, updateFilters, updateSort, updatePage\n- Thunks: fetchSearchResults, fetchSuggestions\n- Sync state with URL query params\n\nAcceptance:\n- [ ] State updates trigger new searches\n- [ ] URL reflects current search state\n- [ ] Back/forward browser buttons work\n- [ ] Shareable search URLs\n\nFiles:\n- `src/store/slices/searchSlice.js`\n- `src/store/slices/searchSlice.test.js`\n\n### Phase 4: Testing (8h)\n\n**T1: Backend unit tests** [2h] - @Backend_Bob\n- Test query builder logic\n- Test search service\n- Test API endpoint responses\n- Mock Elasticsearch calls\n\nAcceptance:\n- [ ] >80% code coverage\n- [ ] All edge cases tested\n- [ ] Tests run in <30 seconds\n\n**T2: Frontend unit tests** [2h] - @Frontend_Fiona\n- Test SearchBar component\n- Test FilterSidebar component\n- Test SearchResults component\n- Test Redux slice reducers\n\nAcceptance:\n- [ ] >80% component coverage\n- [ ] User interactions tested\n- [ ] Accessibility tested\n\n**T3: Integration tests** [2h] - @QA_Quinn\n- Test full search flow (query → API → results)\n- Test filter application\n- Test sorting and pagination\n- Test analytics tracking\n\nAcceptance:\n- [ ] All happy paths tested\n- [ ] Error scenarios tested\n- [ ] Performance thresholds validated\n\n**T4: E2E tests** [2h] - @QA_Quinn\n- Cypress tests for search workflows\n- Test autocomplete interaction\n- Test filter combinations\n- Test mobile responsive behavior\n\nAcceptance:\n- [ ] Critical user journeys tested\n- [ ] Tests pass on Chrome, Firefox, Safari\n- [ ] Mobile tests pass on iOS and Android\n\n### Phase 5: Documentation & Deployment (2h)\n\n**DOC1: Update API documentation** [1h] - @Backend_Bob\n- Document search endpoint in Swagger/OpenAPI\n- Add usage examples\n- Document filter parameters\n- Add response schema\n\n**DEV1: Deploy to staging and production** [1h] - @DevOps_Dave\n- Deploy Elasticsearch changes\n- Run database sync\n- Deploy backend changes\n- Deploy frontend changes\n- Verify in staging\n- Production deployment\n\nAcceptance:\n- [ ] Staging deployment successful\n- [ ] Smoke tests pass\n- [ ] Production deployment successful\n- [ ] Monitoring alerts configured\n\n## Task Dependencies\n\n```\nD1 (ES Index) ──> D2 (Sync Job) ──> D3 (Query Builder)\n                                         │\n                                         ├──> B1 (Search API) ──> F3 (Results)\n                                         │         │\n                                         │         └──> T1 (Backend Tests)\n                                         │\n                                         └──> B2 (Analytics)\n\nB3 (Autocomplete) ──> F1 (Search Input)\n                            │\n                            └──> F4 (State Mgmt) ──> T2 (Frontend Tests)\n\nF2 (Filters) ──> F4 (State Mgmt)\n\nT1, T2 ──> T3 (Integration Tests) ──> T4 (E2E Tests)\n\nAll Dev Tasks ──> DOC1, DEV1\n```\n\n## Critical Path (26 hours)\nD1 (3h) → D2 (3h) → D3 (2h) → B1 (4h) → F4 (2h) → F3 (3h) → T3 (2h) → T4 (2h) → DEV1 (1h)\n\n## Parallel Work Schedule\n\n**Day 1** (8h capacity, 2 devs)\n- Dev 1: D1 (3h) → D2 (3h) → start D3 (2h)\n- Dev 2: B3 (3h) → F1 (2h) → start F2 (3h)\n\n**Day 2** (8h capacity, 3 devs)\n- Dev 1: D3 (finish) → B1 (4h) → start B2 (2h)\n- Dev 2: F2 (finish 1h) → F4 (2h) → F3 (3h)\n- Dev 3: T1 (2h) → T2 (2h) → assist with integration\n\n**Day 3** (8h capacity, 2 devs)\n- Dev 1: B2 (finish 1h) → T3 (2h) → code review\n- Dev 2: T4 (2h) → DOC1 (1h) → DEV1 (1h)\n\n**Total**: 32 hours over 3 days with 2-3 developers\n```\n\n### Example 2: Authentication System Refactor\n\n```markdown\n# Work Breakdown Structure: Epic-34 - OAuth 2.0 Migration\n\n## Level 1: Epic\nEPIC-34: Migrate from session-based auth to OAuth 2.0 with JWT\n\n## Level 2: User Stories\n\n### Story 1: US-401 - OAuth Provider Setup\n**Value**: High (blocks other stories)\n**Dependencies**: None\n**Estimated**: 13 points / 26 hours\n\n#### Backend Tasks\n- 1.1: Set up OAuth 2.0 server (Keycloak/Auth0) [8h] - @DevOps\n  - Install and configure auth server\n  - Set up realms and clients\n  - Configure token expiration policies\n  - Set up HTTPS and certificates\n\n- 1.2: Create user migration script [6h] - @Backend\n  - Export users from current database\n  - Transform to OAuth format\n  - Import to auth provider\n  - Validate migration\n\n- 1.3: Implement OAuth client library [4h] - @Backend\n  - Add OAuth SDK to backend\n  - Configure authorization flows\n  - Implement token validation\n  - Add refresh token logic\n\n#### Testing Tasks\n- 1.4: Test OAuth flows [4h] - @QA\n  - Test authorization code flow\n  - Test token refresh\n  - Test logout/revocation\n  - Load test token validation\n\n#### Documentation\n- 1.5: Document OAuth setup [2h] - @TechWriter\n  - Architecture diagram\n  - Configuration guide\n  - Migration runbook\n\n**Subtotal**: 26 hours\n\n### Story 2: US-402 - Update Frontend Auth Flow\n**Value**: High\n**Dependencies**: US-401\n**Estimated**: 8 points / 16 hours\n\n#### Frontend Tasks\n- 2.1: Implement OAuth login flow [4h] - @Frontend\n  - Add OAuth redirect logic\n  - Handle callback with auth code\n  - Store tokens securely\n  - Implement auto-refresh\n\n- 2.2: Update API client to use JWT [3h] - @Frontend\n  - Add Authorization header interceptor\n  - Handle token expiration\n  - Trigger refresh on 401\n  - Update error handling\n\n- 2.3: Add logout functionality [2h] - @Frontend\n  - Clear local tokens\n  - Revoke tokens with auth server\n  - Redirect to login\n\n- 2.4: Update auth guards/routes [2h] - @Frontend\n  - Check token validity\n  - Handle protected routes\n  - Add role-based access\n\n#### Testing Tasks\n- 2.5: Frontend auth tests [3h] - @Frontend\n  - Unit tests for auth service\n  - Integration tests for login flow\n  - Test token refresh logic\n\n- 2.6: E2E auth tests [2h] - @QA\n  - Test complete login flow\n  - Test session persistence\n  - Test logout flow\n\n**Subtotal**: 16 hours\n\n### Story 3: US-403 - Update Backend API Authorization\n**Value**: High\n**Dependencies**: US-401\n**Estimated**: 8 points / 16 hours\n\n#### Backend Tasks\n- 3.1: Create JWT validation middleware [4h] - @Backend\n  - Verify JWT signature\n  - Check expiration\n  - Extract user claims\n  - Handle invalid tokens\n\n- 3.2: Update authorization checks [4h] - @Backend\n  - Replace session checks with JWT claims\n  - Implement role-based access control\n  - Update permission checks\n\n- 3.3: Add API key support for service-to-service [3h] - @Backend\n  - Create API key model\n  - Implement key validation\n  - Add rate limiting\n\n#### Testing Tasks\n- 3.4: Backend auth tests [3h] - @Backend\n  - Test middleware with valid/invalid tokens\n  - Test authorization rules\n  - Test API key auth\n\n- 3.5: Security audit [2h] - @Security\n  - Review token handling\n  - Check for vulnerabilities\n  - Validate HTTPS enforcement\n\n**Subtotal**: 16 hours\n\n### Story 4: US-404 - Backward Compatibility & Migration\n**Value**: Medium\n**Dependencies**: US-402, US-403\n**Estimated**: 5 points / 10 hours\n\n#### Backend Tasks\n- 4.1: Support dual auth (session + JWT) [4h] - @Backend\n  - Check for session OR JWT\n  - Migrate active sessions to JWT\n  - Set deprecation timeline\n\n- 4.2: Create session-to-JWT migration endpoint [2h] - @Backend\n  - Exchange valid session for JWT\n  - Force token refresh\n\n#### Frontend Tasks\n- 4.3: Add migration banner [2h] - @Frontend\n  - Detect old session users\n  - Show migration prompt\n  - Trigger migration flow\n\n#### Documentation\n- 4.4: User migration guide [2h] - @TechWriter\n  - Explain changes to users\n  - Provide migration steps\n  - FAQ section\n\n**Subtotal**: 10 hours\n\n## Epic Totals\n- **Total Tasks**: 21\n- **Total Hours**: 68\n- **Total Story Points**: 34\n- **Team**: 5 developers\n- **Duration**: ~2 sprints (assuming 40pt velocity)\n\n## Epic Dependencies Graph\n```\nUS-401 (OAuth Setup)\n    ├──> US-402 (Frontend)\n    ├──> US-403 (Backend)\n    └──> US-404 (Migration)\n         ^\n         │\n    US-402 + US-403\n```\n```\n\n### Example 3: Mobile App Feature - Offline Mode\n\n```markdown\n# Task Card Example: Offline Data Sync\n\n## Task: MOB-234 - Implement SQLite Local Storage\n\n### Description\nCreate SQLite database schema and data access layer to store user data locally for offline access. This enables the app to function without internet connectivity.\n\n### Acceptance Criteria\n- [ ] SQLite database created with schema matching API models\n- [ ] CRUD operations implemented for all core entities (posts, comments, user profile)\n- [ ] Data automatically syncs to local DB after API fetch\n- [ ] Local data queried when offline\n- [ ] Database migrations handled for schema updates\n\n### Technical Details\n\n**Files to Create/Modify**:\n- `src/database/schema.ts` (new)\n- `src/database/repository.ts` (new)\n- `src/services/apiService.ts` (modify)\n- `src/store/slices/postsSlice.ts` (modify)\n\n**Database Schema**:\n```sql\nCREATE TABLE posts (\n  id INTEGER PRIMARY KEY,\n  title TEXT NOT NULL,\n  content TEXT,\n  author_id INTEGER,\n  created_at DATETIME,\n  updated_at DATETIME,\n  synced_at DATETIME,\n  is_deleted INTEGER DEFAULT 0\n);\n\nCREATE TABLE sync_queue (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  entity_type TEXT,\n  entity_id INTEGER,\n  operation TEXT, -- 'CREATE', 'UPDATE', 'DELETE'\n  payload TEXT, -- JSON\n  created_at DATETIME,\n  retry_count INTEGER DEFAULT 0\n);\n```\n\n**Dependencies**:\n- Requires: MOB-230 (SQLite library integration)\n- Blocks: MOB-235 (Sync queue implementation)\n- Related: MOB-236 (Conflict resolution)\n\n### Implementation Notes\n\n```typescript\n// Repository pattern example\nclass PostRepository {\n  async getAll(): Promise<Post[]> {\n    return db.query('SELECT * FROM posts WHERE is_deleted = 0');\n  }\n  \n  async getById(id: number): Promise<Post | null> {\n    const result = await db.query(\n      'SELECT * FROM posts WHERE id = ? AND is_deleted = 0',\n      [id]\n    );\n    return result[0] || null;\n  }\n  \n  async upsert(post: Post): Promise<void> {\n    await db.run(\n      `INSERT INTO posts (id, title, content, author_id, created_at, updated_at, synced_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?)\n       ON CONFLICT(id) DO UPDATE SET\n         title = excluded.title,\n         content = excluded.content,\n         updated_at = excluded.updated_at,\n         synced_at = excluded.synced_at`,\n      [post.id, post.title, post.content, post.authorId, \n       post.createdAt, post.updatedAt, new Date()]\n    );\n  }\n}\n```\n\n### Testing Requirements\n- [ ] Unit tests for repository methods\n- [ ] Test database migrations\n- [ ] Test upsert logic (insert and update)\n- [ ] Test soft delete functionality\n- [ ] Manual testing: Verify data persists after app restart\n\n### Estimation\n**Original Estimate**: 6 hours\n- Schema design: 1h\n- Repository implementation: 3h\n- Integration with existing code: 1h\n- Testing: 1h\n\n**Time Spent**: [Track actual time]\n**Remaining**: [Update as work progresses]\n\n### Owner\n**Assigned To**: @Mobile_Mike\n**Status**: In Progress\n**Priority**: P0 (Critical path)\n**Started**: 2024-01-15\n**Target Completion**: 2024-01-16\n```\n\n### Example 4: Complex Feature - Multi-tenant SaaS Dashboard\n\n```markdown\n# Task Breakdown: US-567 - Organization Dashboard\n\n## Story Summary\nAs an organization admin, I want a comprehensive dashboard showing team activity, usage metrics, and billing information.\n\n**Story Points**: 13\n**Estimated Hours**: 52\n**Sprint**: Sprint 31-32 (spans 2 sprints)\n\n## Task Breakdown by Layer\n\n### Data Layer (12h)\n\n**D1: Create analytics database schema** [4h]\n- Tables: org_metrics, user_activity, api_usage\n- Partitioning by date for performance\n- Indexes on org_id, date columns\n\n**D2: Build metrics aggregation job** [5h]\n- Scheduled job (runs hourly)\n- Aggregate user activity by organization\n- Calculate API usage and rate limit status\n- Store daily/weekly/monthly rollups\n\n**D3: Create real-time metrics stream** [3h]\n- WebSocket connection for live updates\n- Redis pub/sub for event broadcasting\n- Push notifications for threshold alerts\n\n### Backend Layer (16h)\n\n**B1: Dashboard API - Overview endpoint** [4h]\n- GET /api/v1/organizations/:id/dashboard\n- Return: active users, API calls, storage used\n- Time range filtering (today, 7d, 30d, custom)\n- Cache responses (5min TTL)\n\n**B2: Dashboard API - Team activity endpoint** [4h]\n- GET /api/v1/organizations/:id/activity\n- Return: recent user actions, login history\n- Pagination (50 items per page)\n- Filter by user, action type, date range\n\n**B3: Dashboard API - Billing endpoint** [3h]\n- GET /api/v1/organizations/:id/billing\n- Return: current plan, usage vs limits, next bill\n- Calculate overage charges\n- Include invoice history\n\n**B4: Export functionality** [3h]\n- POST /api/v1/organizations/:id/export\n- Generate CSV/PDF reports\n- Queue long-running exports\n- Email download link when ready\n\n**B5: Admin permissions middleware** [2h]\n- Verify user has admin role for org\n- Check feature flags for org plan\n- Rate limiting for API endpoints\n\n### Frontend Layer (18h)\n\n**F1: Dashboard layout component** [3h]\n- Responsive grid layout\n- Sidebar navigation\n- Header with org selector\n- Loading and error states\n\n**F2: Overview metrics cards** [4h]\n- KPI cards: active users, API calls, storage\n- Trend indicators (up/down from last period)\n- Click to view detailed charts\n- Real-time updates via WebSocket\n\n**F3: Activity timeline component** [4h]\n- Infinite scroll list\n- Filters: user, action type, date\n- Search functionality\n- Export to CSV button\n\n**F4: Usage charts** [4h]\n- Line chart: API calls over time\n- Bar chart: Top API endpoints\n- Pie chart: Storage breakdown\n- Interactive tooltips, zoom, pan\n\n**F5: Billing summary** [3h]\n- Current plan display\n- Usage progress bars\n- Overage warnings\n- Link to upgrade/manage billing\n\n### Testing Layer (6h)\n\n**T1: Backend unit tests** [2h]\n- Test API endpoints with mocked data\n- Test permissions middleware\n- Test export generation\n\n**T2: Frontend component tests** [2h]\n- Test each component renders correctly\n- Test user interactions\n- Test loading and error states\n\n**T3: Integration tests** [2h]\n- Test full dashboard load flow\n- Test real-time updates\n- Test export download\n\n## Daily Sprint Plan\n\n### Sprint 31 - Week 1\n\n**Monday**\n- @Backend_Alice: D1 (4h), start D2 (4h)\n- @Backend_Bob: B5 (2h), start B1 (4h)\n- @Frontend_Carol: F1 (3h), start F2 (4h)\n\n**Tuesday**\n- @Backend_Alice: D2 (finish 1h), D3 (3h), start B2 (4h)\n- @Backend_Bob: B1 (finish), B3 (3h)\n- @Frontend_Carol: F2 (finish 1h), F3 (4h), start F4 (3h)\n\n**Wednesday**\n- @Backend_Alice: B2 (finish), start B4 (3h)\n- @Backend_Bob: B3 (finish), help with B4\n- @Frontend_Carol: F4 (finish 1h), F5 (3h)\n- @QA_Dan: Start T1 (2h)\n\n**Thursday**\n- @Backend_Alice: B4 (finish)\n- @Frontend_Carol: F5 (finish), polish UI\n- @QA_Dan: T2 (2h), start T3 (2h)\n\n**Friday**\n- Team: Integration, bug fixes\n- @QA_Dan: T3 (finish), regression testing\n- Demo to stakeholders\n\n### Sprint 32 - Week 2 (polish & launch)\n- Bug fixes from testing\n- Performance optimization\n- Documentation\n- Production deployment\n\n## Risk Mitigation\n\n**Risk 1**: Real-time updates complex to implement\n- **Mitigation**: Start with polling (30s interval), add WebSocket later if time permits\n- **Fallback**: Ship without real-time, add in next sprint\n\n**Risk 2**: Charts library integration takes longer than expected\n- **Mitigation**: Pre-spike chart library (Chart.js vs Recharts) before sprint\n- **Fallback**: Use simpler table view instead of charts\n\n**Risk 3**: Export generation slow for large datasets\n- **Mitigation**: Implement async export with email notification\n- **Limit**: Cap export to 10,000 rows\n```\n\n## Best Practices\n\n1. **Task Sizing**\n   - Keep tasks under 8 hours\n   - Tasks over 8h should be broken down further\n   - Ideal task size: 2-4 hours\n\n2. **Task Independence**\n   - Tasks should be completable by one person\n   - Minimize dependencies where possible\n   - Clearly document required dependencies\n\n3. **Clear Acceptance Criteria**\n   - Each task needs testable completion criteria\n   - Include both functional and technical requirements\n   - Define \"done\" explicitly\n\n4. **Balanced Breakdown**\n   - Include tasks for all layers (DB, backend, frontend, testing)\n   - Don't forget: documentation, DevOps, testing\n   - Account for code review and bug fixing time\n\n5. **Resource Allocation**\n   - Match tasks to developer skills\n   - Identify pairing opportunities for complex tasks\n   - Balance workload across team members\n\n6. **Dependency Management**\n   - Create dependency graphs for complex stories\n   - Identify critical path\n   - Plan parallel work where possible\n\n7. **Buffer Time**\n   - Add 10-20% buffer for unknowns\n   - Account for meetings, interruptions\n   - Plan time for code review and testing\n\n## Common Pitfalls\n\n- **Too Granular**: Breaking tasks into 30-minute chunks creates overhead\n- **Too Vague**: \"Implement feature\" doesn't give clear direction\n- **Missing Testing**: Forgetting to include testing tasks\n- **Ignoring DevOps**: Not planning for deployment and configuration\n- **No Documentation**: Skipping documentation tasks\n- **Optimistic Estimates**: Not accounting for complexity and unknowns\n- **Sequential Thinking**: Not identifying parallel work opportunities\n\n## Tools\n\n- **Jira/Linear**: Task tracking and management\n- **Miro/Mural**: Visual task breakdown and dependency mapping\n- **Draw.io**: Creating WBS diagrams\n- **GitHub Projects**: Lightweight task tracking\n- **Notion/Confluence**: Documentation and planning\n",
  "prompt": "A skill that helps break down complex features and user stories into small, actionable development tasks using work breakdown structure (WBS) methodology. Includes task decomposition into 2-8 hour chunks, dependency mapping with critical path analysis, resource allocation matching team skills, and detailed execution planning. Provides templates for task cards, WBS diagrams, and daily sprint plans with comprehensive examples for e-commerce search, authentication refactoring, mobile offline mode, and multi-tenant dashboards.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}