{
  "id": "productivity-git-commands",
  "name": "Git Workflows",
  "description": "Master git commands, workflows, branching strategies, and merge/rebase operations with comprehensive examples",
  "category": "Productivity",
  "content": "---\nname: Git Workflows\ndescription: Master git commands, workflows, branching strategies, and merge/rebase operations with comprehensive examples\ncategory: Productivity\n---\n\n# Git Workflows\n\n## Overview\n\nThe Git Workflows skill provides comprehensive guidance on git commands, branching strategies, merge strategies, conflict resolution, and team workflows. From basic operations to advanced techniques like interactive rebasing and cherry-picking, this skill helps you master version control.\n\nThis skill covers:\n- Essential git commands and workflows\n- Branching strategies (Git Flow, GitHub Flow, trunk-based)\n- Merge vs rebase strategies\n- Conflict resolution techniques\n- Undoing changes safely\n- Advanced operations (interactive rebase, cherry-pick, bisect)\n- Team collaboration patterns\n- Git hooks and automation\n\n## Activation\n\nThis skill activates when you:\n- Ask about git commands or workflows\n- Need help with branching strategies\n- Request guidance on merging or rebasing\n- Ask how to undo changes or fix mistakes\n- Need help resolving conflicts\n- Want to understand git best practices\n- Ask about team collaboration workflows\n\n## Instructions\n\nWhen helping with git, I will:\n\n1. **Explain commands clearly** with what they do and when to use them\n\n2. **Show practical examples** with real-world scenarios\n\n3. **Highlight safety considerations** to prevent data loss\n\n4. **Provide workflow diagrams** for complex operations\n\n5. **Include troubleshooting tips** for common issues\n\n6. **Recommend best practices** for team collaboration\n\n7. **Show before/after states** to clarify what changes\n\n## Examples\n\n### Example 1: Essential Git Commands\n\n#### Initial Setup\n\n```bash\n# Configure user information\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Set default branch name\ngit config --global init.defaultBranch main\n\n# Set default editor\ngit config --global core.editor \"code --wait\"  # VS Code\n\n# Enable color output\ngit config --global color.ui auto\n\n# View all configuration\ngit config --list\n\n# View specific config\ngit config user.name\n```\n\n#### Repository Basics\n\n```bash\n# Initialize a new repository\ngit init\n\n# Clone an existing repository\ngit clone https://github.com/user/repo.git\ngit clone https://github.com/user/repo.git my-folder  # Custom folder name\n\n# Clone specific branch\ngit clone -b develop https://github.com/user/repo.git\n\n# Clone with depth (shallow clone)\ngit clone --depth 1 https://github.com/user/repo.git  # Last commit only\n```\n\n#### Making Changes\n\n```bash\n# Check status\ngit status\ngit status -s  # Short format\n\n# View changes\ngit diff              # Unstaged changes\ngit diff --staged     # Staged changes\ngit diff HEAD         # All changes (staged + unstaged)\ngit diff main..develop  # Compare branches\n\n# Stage changes\ngit add file.txt           # Specific file\ngit add *.js              # Pattern\ngit add .                 # All files\ngit add -p                # Interactive staging (patch mode)\n\n# Unstage changes\ngit reset HEAD file.txt   # Unstage specific file\ngit reset HEAD            # Unstage all\n\n# Discard changes\ngit checkout -- file.txt  # Discard changes in working directory\ngit restore file.txt      # New syntax (Git 2.23+)\n\n# Commit changes\ngit commit -m \"Commit message\"\ngit commit -am \"Message\"  # Stage and commit (tracked files only)\ngit commit --amend        # Amend last commit\ngit commit --amend --no-edit  # Amend without changing message\n```\n\n#### Viewing History\n\n```bash\n# View commit history\ngit log\ngit log --oneline         # Compact view\ngit log --graph --oneline --all  # Visual branch structure\ngit log -p                # Show patches (diffs)\ngit log -n 5              # Last 5 commits\ngit log --since=\"2 weeks ago\"\ngit log --author=\"John\"\ngit log --grep=\"bugfix\"   # Search commit messages\n\n# View specific file history\ngit log -- file.txt\ngit log -p -- file.txt    # With changes\n\n# View who changed what\ngit blame file.txt\ngit blame -L 10,20 file.txt  # Specific lines\n\n# Show specific commit\ngit show abc123\ngit show HEAD~2           # 2 commits before HEAD\n```\n\n---\n\n### Example 2: Branching and Merging\n\n#### Branch Operations\n\n```bash\n# List branches\ngit branch               # Local branches\ngit branch -r            # Remote branches\ngit branch -a            # All branches\ngit branch -v            # With last commit\ngit branch -vv           # With tracking info\n\n# Create branch\ngit branch feature-login\ngit branch feature-login abc123  # From specific commit\n\n# Switch branches\ngit checkout feature-login\ngit switch feature-login   # New syntax (Git 2.23+)\n\n# Create and switch in one command\ngit checkout -b feature-login\ngit switch -c feature-login  # New syntax\n\n# Rename branch\ngit branch -m old-name new-name\ngit branch -m new-name       # Rename current branch\n\n# Delete branch\ngit branch -d feature-login   # Safe delete (merged only)\ngit branch -D feature-login   # Force delete\n\n# Delete remote branch\ngit push origin --delete feature-login\n```\n\n#### Merging Strategies\n\n**Fast-Forward Merge** (when no divergence)\n\n```bash\n# Feature branch has no conflicts with main\ngit checkout main\ngit merge feature-login\n\n# Prevent fast-forward (create merge commit)\ngit merge --no-ff feature-login\n```\n\n**Three-Way Merge** (when branches diverged)\n\n```bash\ngit checkout main\ngit merge feature-login\n# Creates a merge commit\n```\n\n**Squash Merge** (combine all commits into one)\n\n```bash\ngit checkout main\ngit merge --squash feature-login\ngit commit -m \"Add login feature\"\n# All feature commits become one commit\n```\n\n**Example Workflow:**\n\n```bash\n# Create feature branch\ngit checkout -b feature/user-auth\n\n# Make changes and commit\ngit add .\ngit commit -m \"Add user authentication\"\n\n# More changes\ngit add .\ngit commit -m \"Add password hashing\"\ngit commit -m \"Add session management\"\n\n# Update feature branch with latest main\ngit checkout main\ngit pull origin main\ngit checkout feature/user-auth\ngit merge main\n# Or: git rebase main (see rebase section)\n\n# Merge feature back to main\ngit checkout main\ngit merge --no-ff feature/user-auth\ngit push origin main\n\n# Clean up\ngit branch -d feature/user-auth\ngit push origin --delete feature/user-auth\n```\n\n---\n\n### Example 3: Rebase vs Merge\n\n#### When to Use Each\n\n**Merge:**\n- ✅ Preserves complete history\n- ✅ Safe for shared branches\n- ✅ Clear feature integration points\n- ❌ Creates merge commits (\"messy\" history)\n\n**Rebase:**\n- ✅ Clean, linear history\n- ✅ Easier to understand\n- ❌ Rewrites history (dangerous on shared branches)\n- ❌ Can lose context of when features were integrated\n\n#### Merge Example\n\n```bash\n# On feature branch\ngit checkout feature-branch\n\n# Get latest main\ngit checkout main\ngit pull origin main\n\n# Merge main into feature\ngit checkout feature-branch\ngit merge main\n\n# Resolve conflicts if any\n# ... edit files ...\ngit add .\ngit commit -m \"Merge main into feature-branch\"\n```\n\n**Result:** Creates a merge commit, preserves both histories\n\n#### Rebase Example\n\n```bash\n# On feature branch\ngit checkout feature-branch\n\n# Get latest main\ngit checkout main\ngit pull origin main\n\n# Rebase feature onto main\ngit checkout feature-branch\ngit rebase main\n\n# Resolve conflicts if any\n# ... edit files ...\ngit add .\ngit rebase --continue\n\n# If you want to abort\ngit rebase --abort\n```\n\n**Result:** Moves feature commits on top of main, linear history\n\n#### Interactive Rebase\n\n```bash\n# Rebase last 3 commits\ngit rebase -i HEAD~3\n\n# Rebase from specific commit\ngit rebase -i abc123\n```\n\n**Interactive rebase editor:**\n```\npick abc123 Add user model\npick def456 Add validation\npick ghi789 Fix typo\n\n# Commands:\n# p, pick = use commit\n# r, reword = use commit, but edit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like squash, but discard commit message\n# d, drop = remove commit\n```\n\n**Example: Squash commits**\n```\npick abc123 Add user model\nsquash def456 Add validation\nsquash ghi789 Fix typo\n\n# Result: One commit with all changes\n```\n\n**Example: Reword and reorder**\n```\npick ghi789 Fix typo\nreword abc123 Add user model\npick def456 Add validation\n\n# Fix typo commit comes first, and you can edit \"Add user model\" message\n```\n\n**Complete Interactive Rebase Workflow:**\n\n```bash\n# Start interactive rebase\ngit rebase -i HEAD~4\n\n# In editor, mark commits:\npick abc123 WIP: user model\nfixup def456 Fix bug\nreword ghi789 Add user model tests\npick jkl012 Update documentation\n\n# Save and close editor\n# Git will:\n# 1. Keep abc123\n# 2. Squash def456 into abc123\n# 3. Stop to let you reword ghi789\n# 4. Keep jkl012\n\n# After rewording, continue\ngit rebase --continue\n\n# Force push (if already pushed)\ngit push --force-with-lease origin feature-branch\n```\n\n---\n\n### Example 4: Conflict Resolution\n\n#### Understanding Conflicts\n\n**Conflict markers:**\n```\n<<<<<<< HEAD (current branch)\nconst message = 'Hello World';\n=======\nconst message = 'Hello Universe';\n>>>>>>> feature-branch (incoming changes)\n```\n\n#### Resolving Conflicts Manually\n\n```bash\n# Start merge or rebase\ngit merge feature-branch\n# Or: git rebase main\n\n# Git shows conflicts:\n# CONFLICT (content): Merge conflict in file.js\n# Automatic merge failed; fix conflicts and then commit the result.\n\n# Check which files have conflicts\ngit status\n\n# Edit conflicted files\n# Remove conflict markers and keep desired changes\nconst message = 'Hello World'; // Final decision\n\n# Stage resolved files\ngit add file.js\n\n# Continue merge/rebase\ngit commit  # For merge\n# Or: git rebase --continue  # For rebase\n```\n\n#### Using Merge Tools\n\n```bash\n# Configure merge tool\ngit config --global merge.tool vimdiff\n# Or: meld, kdiff3, p4merge, etc.\n\n# Launch merge tool\ngit mergetool\n\n# After resolving, clean up backup files\nfind . -name \"*.orig\" -delete\n```\n\n#### Accepting Specific Version\n\n```bash\n# Accept all changes from current branch (ours)\ngit checkout --ours file.js\ngit add file.js\n\n# Accept all changes from incoming branch (theirs)\ngit checkout --theirs file.js\ngit add file.js\n\n# For entire merge:\ngit merge -X ours feature-branch   # Prefer current branch\ngit merge -X theirs feature-branch  # Prefer incoming branch\n```\n\n#### Aborting Merge/Rebase\n\n```bash\n# Abort merge\ngit merge --abort\n\n# Abort rebase\ngit rebase --abort\n\n# Abort cherry-pick\ngit cherry-pick --abort\n```\n\n---\n\n### Example 5: Undoing Changes\n\n#### Undoing Uncommitted Changes\n\n```bash\n# Discard changes in working directory\ngit checkout -- file.txt\ngit restore file.txt  # New syntax\n\n# Discard all changes\ngit checkout -- .\ngit restore .\n\n# Unstage file (keep changes)\ngit reset HEAD file.txt\ngit restore --staged file.txt  # New syntax\n```\n\n#### Undoing Commits (Local)\n\n```bash\n# Undo last commit, keep changes staged\ngit reset --soft HEAD~1\n\n# Undo last commit, keep changes unstaged\ngit reset HEAD~1\n# Or: git reset --mixed HEAD~1\n\n# Undo last commit, discard changes\ngit reset --hard HEAD~1\n\n# Undo multiple commits\ngit reset --hard HEAD~3  # Last 3 commits\ngit reset --hard abc123  # To specific commit\n```\n\n#### Undoing Commits (Published)\n\n**Never use `reset --hard` on published commits!**\n\n```bash\n# Create new commit that undoes changes\ngit revert HEAD         # Revert last commit\ngit revert abc123       # Revert specific commit\ngit revert HEAD~3..HEAD # Revert range\n\n# Revert merge commit\ngit revert -m 1 abc123  # -m 1 specifies parent\n```\n\n#### Recovering Lost Commits\n\n```bash\n# View reflog (local history)\ngit reflog\n\n# Output:\n# abc123 HEAD@{0}: reset: moving to HEAD~3\n# def456 HEAD@{1}: commit: Add feature\n# ...\n\n# Recover lost commit\ngit checkout def456\ngit branch recovered-branch  # Save it\n\n# Or reset to that point\ngit reset --hard def456\n```\n\n#### Fixing Last Commit\n\n```bash\n# Forgot to add file\ngit add forgotten-file.txt\ngit commit --amend --no-edit\n\n# Fix commit message\ngit commit --amend -m \"Corrected message\"\n\n# Add changes and fix message\ngit add fixed-file.txt\ngit commit --amend\n```\n\n---\n\n### Example 6: Remote Operations\n\n#### Working with Remotes\n\n```bash\n# View remotes\ngit remote -v\n\n# Add remote\ngit remote add origin https://github.com/user/repo.git\ngit remote add upstream https://github.com/original/repo.git\n\n# Change remote URL\ngit remote set-url origin https://github.com/user/new-repo.git\n\n# Remove remote\ngit remote remove origin\n\n# Rename remote\ngit remote rename origin upstream\n```\n\n#### Fetching and Pulling\n\n```bash\n# Fetch from remote (doesn't merge)\ngit fetch origin\ngit fetch origin main  # Specific branch\ngit fetch --all        # All remotes\n\n# Pull from remote (fetch + merge)\ngit pull origin main\ngit pull --rebase origin main  # Fetch + rebase\n\n# Pull with fast-forward only\ngit pull --ff-only origin main\n```\n\n#### Pushing\n\n```bash\n# Push to remote\ngit push origin main\ngit push origin feature-branch\n\n# Push all branches\ngit push origin --all\n\n# Push and set upstream\ngit push -u origin feature-branch\n# Now you can use: git push\n\n# Force push (dangerous!)\ngit push --force origin main\n\n# Safer force push\ngit push --force-with-lease origin main\n\n# Delete remote branch\ngit push origin --delete feature-branch\n\n# Push tags\ngit push origin --tags\ngit push origin v1.0.0  # Specific tag\n```\n\n#### Tracking Branches\n\n```bash\n# Create tracking branch\ngit checkout -b feature origin/feature\ngit checkout --track origin/feature  # Short form\n\n# Set upstream for existing branch\ngit branch -u origin/feature\ngit push -u origin feature  # While pushing\n\n# View tracking info\ngit branch -vv\n```\n\n---\n\n### Example 7: Advanced Operations\n\n#### Cherry-Pick\n\n```bash\n# Apply specific commit to current branch\ngit cherry-pick abc123\n\n# Cherry-pick multiple commits\ngit cherry-pick abc123 def456 ghi789\n\n# Cherry-pick range\ngit cherry-pick abc123..def456\n\n# Cherry-pick without committing\ngit cherry-pick -n abc123\ngit cherry-pick --no-commit abc123\n\n# Continue after resolving conflicts\ngit cherry-pick --continue\n\n# Abort cherry-pick\ngit cherry-pick --abort\n```\n\n**Use Case Example:**\n```bash\n# Hotfix applied to main, need it in develop\ngit checkout develop\ngit cherry-pick abc123  # The hotfix commit from main\n```\n\n#### Stash\n\n```bash\n# Stash current changes\ngit stash\ngit stash save \"Work in progress on feature\"\n\n# List stashes\ngit stash list\n\n# Apply most recent stash\ngit stash apply\ngit stash pop  # Apply and remove from stash\n\n# Apply specific stash\ngit stash apply stash@{2}\n\n# Create branch from stash\ngit stash branch feature-branch\n\n# Show stash contents\ngit stash show\ngit stash show -p  # With diff\n\n# Drop stash\ngit stash drop stash@{0}\ngit stash clear  # Remove all stashes\n```\n\n**Workflow Example:**\n```bash\n# Working on feature, need to switch to hotfix\ngit stash save \"Feature work in progress\"\n\n# Switch to main, create hotfix\ngit checkout main\ngit checkout -b hotfix-login\n# ... make changes ...\ngit commit -m \"Fix login bug\"\n\n# Back to feature\ngit checkout feature-branch\ngit stash pop\n```\n\n#### Bisect (Find Bug Introduction)\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current as bad\ngit bisect bad\n\n# Mark known good commit\ngit bisect good abc123\n\n# Git checks out middle commit\n# Test it, then mark:\ngit bisect good  # If working\n# Or:\ngit bisect bad   # If broken\n\n# Repeat until Git finds the commit\n# Git will output: \"abc123 is the first bad commit\"\n\n# End bisect\ngit bisect reset\n```\n\n**Automated Bisect:**\n```bash\n# Use script to test\ngit bisect start HEAD abc123\ngit bisect run npm test\n\n# Git automatically finds first failing commit\n```\n\n#### Submodules\n\n```bash\n# Add submodule\ngit submodule add https://github.com/user/repo.git path/to/submodule\n\n# Clone with submodules\ngit clone --recursive https://github.com/user/repo.git\n\n# Initialize submodules (after normal clone)\ngit submodule init\ngit submodule update\n\n# Update submodules\ngit submodule update --remote\n\n# Update all submodules\ngit submodule foreach git pull origin main\n```\n\n---\n\n### Example 8: Git Workflows\n\n#### Git Flow\n\n**Branches:**\n- `main` - Production code\n- `develop` - Integration branch\n- `feature/*` - New features\n- `release/*` - Release preparation\n- `hotfix/*` - Production fixes\n\n**Workflow:**\n\n```bash\n# Start feature\ngit checkout develop\ngit checkout -b feature/user-profile\n# ... work on feature ...\ngit commit -m \"Add user profile\"\n\n# Finish feature\ngit checkout develop\ngit merge --no-ff feature/user-profile\ngit branch -d feature/user-profile\n\n# Start release\ngit checkout develop\ngit checkout -b release/1.0.0\n# ... bug fixes, version bumps ...\ngit commit -m \"Bump version to 1.0.0\"\n\n# Finish release\ngit checkout main\ngit merge --no-ff release/1.0.0\ngit tag -a v1.0.0 -m \"Release 1.0.0\"\n\ngit checkout develop\ngit merge --no-ff release/1.0.0\ngit branch -d release/1.0.0\n\n# Hotfix\ngit checkout main\ngit checkout -b hotfix/1.0.1\n# ... fix bug ...\ngit commit -m \"Fix critical bug\"\n\ngit checkout main\ngit merge --no-ff hotfix/1.0.1\ngit tag -a v1.0.1 -m \"Hotfix 1.0.1\"\n\ngit checkout develop\ngit merge --no-ff hotfix/1.0.1\ngit branch -d hotfix/1.0.1\n```\n\n#### GitHub Flow (Simpler)\n\n**Branches:**\n- `main` - Always deployable\n- `feature/*` - All work\n\n**Workflow:**\n\n```bash\n# Create feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/add-comments\n\n# Work and commit\ngit add .\ngit commit -m \"Add comment system\"\ngit push -u origin feature/add-comments\n\n# Open Pull Request on GitHub\n# After review and CI passes:\n# Merge PR (on GitHub)\n\n# Clean up local\ngit checkout main\ngit pull origin main\ngit branch -d feature/add-comments\n```\n\n#### Trunk-Based Development\n\n**Single branch (`main`) with short-lived feature branches**\n\n```bash\n# Create short-lived feature branch\ngit checkout -b feature/quick-fix\n\n# Small changes, commit quickly\ngit commit -m \"Fix button alignment\"\n\n# Push and merge same day\ngit push origin feature/quick-fix\n# Create PR, get quick review, merge\n\n# Delete branch immediately\ngit branch -d feature/quick-fix\n```\n\n---\n\n### Example 9: Git Hooks\n\n#### Pre-Commit Hook\n\n**`.git/hooks/pre-commit`**\n\n```bash\n#!/bin/sh\n\n# Run linter\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"Linting failed. Commit aborted.\"\n  exit 1\nfi\n\n# Run tests\nnpm test\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Commit aborted.\"\n  exit 1\nfi\n\n# Check for debugging code\nif git diff --cached | grep -E 'console.log|debugger'; then\n  echo \"Found debugging code. Remove before committing.\"\n  exit 1\nfi\n\nexit 0\n```\n\n#### Commit-Msg Hook\n\n**`.git/hooks/commit-msg`**\n\n```bash\n#!/bin/sh\n\nCOMMIT_MSG_FILE=$1\nCOMMIT_MSG=$(cat \"$COMMIT_MSG_FILE\")\n\n# Enforce conventional commits\nif ! echo \"$COMMIT_MSG\" | grep -qE '^(feat|fix|docs|style|refactor|test|chore)(\\(.+\\))?: .{1,}'; then\n  echo \"Invalid commit message format.\"\n  echo \"Use: type(scope): description\"\n  echo \"Types: feat, fix, docs, style, refactor, test, chore\"\n  exit 1\nfi\n\n# Enforce length\nif [ ${#COMMIT_MSG} -gt 72 ]; then\n  echo \"Commit message too long (max 72 characters)\"\n  exit 1\nfi\n\nexit 0\n```\n\n#### Using Husky (Node.js projects)\n\n```bash\n# Install Husky\nnpm install husky --save-dev\nnpx husky install\n\n# Add pre-commit hook\nnpx husky add .husky/pre-commit \"npm test\"\n\n# Add commit-msg hook\nnpx husky add .husky/commit-msg 'npx --no -- commitlint --edit $1'\n```\n\n**`package.json`:**\n```json\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  \"devDependencies\": {\n    \"husky\": \"^8.0.0\",\n    \"@commitlint/cli\": \"^17.0.0\",\n    \"@commitlint/config-conventional\": \"^17.0.0\"\n  }\n}\n```\n\n---\n\n## Git Aliases\n\nAdd to `~/.gitconfig`:\n\n```ini\n[alias]\n  # Short status\n  st = status -s\n  \n  # Pretty log\n  lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n  \n  # Undo last commit\n  undo = reset HEAD~1 --mixed\n  \n  # Amend without editing message\n  amend = commit --amend --no-edit\n  \n  # Show branches sorted by last modified\n  br = branch --sort=-committerdate\n  \n  # Quick commit\n  cm = commit -m\n  \n  # Quick add and commit\n  ac = !git add -A && git commit -m\n  \n  # Push current branch\n  pushup = push -u origin HEAD\n  \n  # Delete merged branches\n  cleanup = !git branch --merged | grep -v '\\*\\|main\\|develop' | xargs -n 1 git branch -d\n```\n\n## Best Practices\n\n1. **Commit often, push regularly** - Small, focused commits\n2. **Write meaningful commit messages** - Explain why, not what\n3. **Never force push to shared branches** - Use `--force-with-lease` if needed\n4. **Pull before push** - Stay in sync with team\n5. **Use branches** - Keep main/develop stable\n6. **Review before committing** - Use `git diff`\n7. **Don't commit secrets** - Use `.gitignore`\n8. **Tag releases** - Use semantic versioning\n9. **Keep history clean** - Rebase feature branches before merging\n10. **Use `.gitignore`** - Don't commit generated files\n",
  "prompt": "A skill that provides comprehensive git guidance including essential commands, branching strategies (Git Flow, GitHub Flow, trunk-based), merge vs rebase operations, conflict resolution, undoing changes, advanced operations (cherry-pick, stash, bisect), team workflows, and git hooks with practical examples.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
