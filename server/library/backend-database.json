{
  "id": "backend-database",
  "name": "Database Patterns",
  "description": "Complete database patterns with Prisma, TypeORM, migrations, queries, transactions, and optimization strategies",
  "category": "Backend",
  "content": "---\nname: Database Patterns\ndescription: Complete database patterns with Prisma, TypeORM, migrations, queries, transactions, and optimization strategies\ncategory: Backend\n---\n\n# Database Patterns\n\n## Overview\n\nThis skill provides production-ready database patterns using Prisma ORM and TypeORM, including schema design, migrations, complex queries, transactions, relations, indexing, query optimization, and best practices for working with PostgreSQL, MySQL, and SQLite.\n\n## Activation\n\nUse this skill when:\n- Setting up database schema and models\n- Creating and running database migrations\n- Writing complex queries with joins and aggregations\n- Implementing transactions and concurrent operations\n- Optimizing database queries and indexes\n- Setting up database relations (one-to-many, many-to-many)\n- Implementing soft deletes and timestamps\n- Adding full-text search or pagination\n- Managing database connections and pooling\n\n## Instructions\n\n1. **Choose ORM**: Select Prisma (modern, type-safe) or TypeORM (decorator-based)\n2. **Design Schema**: Model your data with proper types and relations\n3. **Create Migrations**: Use migration tools to version control schema changes\n4. **Write Queries**: Implement CRUD operations with type safety\n5. **Add Relations**: Set up one-to-many, many-to-many relationships\n6. **Optimize**: Add indexes, optimize N+1 queries, use query builders\n7. **Handle Transactions**: Implement atomic operations with rollback\n8. **Add Pagination**: Implement cursor or offset pagination\n9. **Implement Search**: Add filtering, sorting, and full-text search\n10. **Monitor Performance**: Use query logging and explain plans\n\n## Examples\n\n### Prisma ORM Setup & Patterns\n\n```typescript\n// prisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n  previewFeatures = [\"fullTextSearch\", \"fullTextIndex\"]\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        String   @id @default(uuid())\n  email     String   @unique\n  name      String\n  password  String\n  role      Role     @default(USER)\n  \n  posts     Post[]\n  profile   Profile?\n  comments  Comment[]\n  \n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  deletedAt DateTime? // Soft delete\n  \n  @@index([email])\n  @@map(\"users\")\n}\n\nmodel Profile {\n  id        String  @id @default(uuid())\n  bio       String?\n  avatar    String?\n  website   String?\n  \n  userId    String  @unique\n  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n  \n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  @@map(\"profiles\")\n}\n\nmodel Post {\n  id          String   @id @default(uuid())\n  title       String\n  content     String   @db.Text\n  published   Boolean  @default(false)\n  slug        String   @unique\n  viewCount   Int      @default(0)\n  \n  authorId    String\n  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)\n  \n  categories  Category[]\n  comments    Comment[]\n  tags        Tag[]\n  \n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  publishedAt DateTime?\n  deletedAt   DateTime?\n  \n  @@index([authorId])\n  @@index([published])\n  @@index([slug])\n  @@fulltext([title, content])\n  @@map(\"posts\")\n}\n\nmodel Comment {\n  id        String   @id @default(uuid())\n  content   String   @db.Text\n  \n  postId    String\n  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)\n  \n  authorId  String\n  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)\n  \n  parentId  String?\n  parent    Comment?  @relation(\"CommentReplies\", fields: [parentId], references: [id])\n  replies   Comment[] @relation(\"CommentReplies\")\n  \n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  deletedAt DateTime?\n  \n  @@index([postId])\n  @@index([authorId])\n  @@map(\"comments\")\n}\n\nmodel Category {\n  id          String  @id @default(uuid())\n  name        String  @unique\n  slug        String  @unique\n  description String?\n  \n  posts       Post[]\n  \n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n  \n  @@map(\"categories\")\n}\n\nmodel Tag {\n  id    String @id @default(uuid())\n  name  String @unique\n  \n  posts Post[]\n  \n  createdAt DateTime @default(now())\n  \n  @@map(\"tags\")\n}\n\nenum Role {\n  USER\n  ADMIN\n  MODERATOR\n}\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"db:migrate\": \"prisma migrate dev\",\n    \"db:push\": \"prisma db push\",\n    \"db:studio\": \"prisma studio\",\n    \"db:seed\": \"tsx prisma/seed.ts\",\n    \"db:reset\": \"prisma migrate reset\"\n  }\n}\n\n// src/config/database.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst prismaClientSingleton = () => {\n  return new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  });\n};\n\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClientSingleton | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? prismaClientSingleton();\n\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n}\n\n// Middleware for soft deletes\nprisma.$use(async (params, next) => {\n  if (params.action === 'delete') {\n    // Change delete to update and set deletedAt\n    params.action = 'update';\n    params.args['data'] = { deletedAt: new Date() };\n  }\n  \n  if (params.action === 'deleteMany') {\n    params.action = 'updateMany';\n    if (params.args.data !== undefined) {\n      params.args.data['deletedAt'] = new Date();\n    } else {\n      params.args['data'] = { deletedAt: new Date() };\n    }\n  }\n  \n  // Filter out soft-deleted records\n  if (params.action === 'findUnique' || params.action === 'findFirst') {\n    params.action = 'findFirst';\n    params.args.where['deletedAt'] = null;\n  }\n  \n  if (params.action === 'findMany') {\n    if (params.args.where) {\n      if (params.args.where.deletedAt === undefined) {\n        params.args.where['deletedAt'] = null;\n      }\n    } else {\n      params.args['where'] = { deletedAt: null };\n    }\n  }\n  \n  return next(params);\n});\n\n// src/repositories/user.repository.ts\nimport { prisma } from '../config/database';\nimport { User, Prisma } from '@prisma/client';\n\nexport class UserRepository {\n  // Create user\n  static async create(data: Prisma.UserCreateInput): Promise<User> {\n    return prisma.user.create({\n      data,\n      include: {\n        profile: true,\n      },\n    });\n  }\n\n  // Find user by ID\n  static async findById(id: string): Promise<User | null> {\n    return prisma.user.findUnique({\n      where: { id },\n      include: {\n        profile: true,\n        posts: {\n          where: { published: true },\n          orderBy: { createdAt: 'desc' },\n          take: 10,\n        },\n      },\n    });\n  }\n\n  // Find user by email\n  static async findByEmail(email: string): Promise<User | null> {\n    return prisma.user.findUnique({\n      where: { email },\n    });\n  }\n\n  // List users with pagination\n  static async list(params: {\n    skip?: number;\n    take?: number;\n    orderBy?: Prisma.UserOrderByWithRelationInput;\n    where?: Prisma.UserWhereInput;\n  }) {\n    const { skip = 0, take = 10, orderBy, where } = params;\n\n    const [users, total] = await prisma.$transaction([\n      prisma.user.findMany({\n        skip,\n        take,\n        orderBy,\n        where,\n        include: {\n          profile: true,\n          _count: {\n            select: {\n              posts: true,\n              comments: true,\n            },\n          },\n        },\n      }),\n      prisma.user.count({ where }),\n    ]);\n\n    return { users, total };\n  }\n\n  // Update user\n  static async update(id: string, data: Prisma.UserUpdateInput): Promise<User> {\n    return prisma.user.update({\n      where: { id },\n      data,\n      include: {\n        profile: true,\n      },\n    });\n  }\n\n  // Delete user (soft delete via middleware)\n  static async delete(id: string): Promise<User> {\n    return prisma.user.delete({\n      where: { id },\n    });\n  }\n\n  // Hard delete user\n  static async hardDelete(id: string): Promise<User> {\n    return prisma.$executeRaw`DELETE FROM users WHERE id = ${id}`;\n  }\n\n  // Search users\n  static async search(query: string) {\n    return prisma.user.findMany({\n      where: {\n        OR: [\n          { name: { contains: query, mode: 'insensitive' } },\n          { email: { contains: query, mode: 'insensitive' } },\n        ],\n      },\n      take: 20,\n    });\n  }\n}\n\n// src/repositories/post.repository.ts\nimport { prisma } from '../config/database';\nimport { Post, Prisma } from '@prisma/client';\n\nexport class PostRepository {\n  // Create post with categories and tags\n  static async create(data: {\n    title: string;\n    content: string;\n    slug: string;\n    authorId: string;\n    categoryIds?: string[];\n    tagNames?: string[];\n  }): Promise<Post> {\n    const { categoryIds = [], tagNames = [], ...postData } = data;\n\n    return prisma.post.create({\n      data: {\n        ...postData,\n        categories: {\n          connect: categoryIds.map(id => ({ id })),\n        },\n        tags: {\n          connectOrCreate: tagNames.map(name => ({\n            where: { name },\n            create: { name },\n          })),\n        },\n      },\n      include: {\n        author: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n        categories: true,\n        tags: true,\n        _count: {\n          select: {\n            comments: true,\n          },\n        },\n      },\n    });\n  }\n\n  // Get post with all relations\n  static async findById(id: string) {\n    return prisma.post.findUnique({\n      where: { id },\n      include: {\n        author: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            profile: true,\n          },\n        },\n        categories: true,\n        tags: true,\n        comments: {\n          where: {\n            parentId: null, // Only top-level comments\n          },\n          include: {\n            author: {\n              select: {\n                id: true,\n                name: true,\n              },\n            },\n            replies: {\n              include: {\n                author: {\n                  select: {\n                    id: true,\n                    name: true,\n                  },\n                },\n              },\n            },\n          },\n          orderBy: {\n            createdAt: 'desc',\n          },\n        },\n      },\n    });\n  }\n\n  // Find post by slug\n  static async findBySlug(slug: string) {\n    return prisma.post.findUnique({\n      where: { slug },\n      include: {\n        author: true,\n        categories: true,\n        tags: true,\n      },\n    });\n  }\n\n  // List posts with advanced filtering\n  static async list(params: {\n    skip?: number;\n    take?: number;\n    published?: boolean;\n    authorId?: string;\n    categoryId?: string;\n    tagName?: string;\n    search?: string;\n    orderBy?: Prisma.PostOrderByWithRelationInput;\n  }) {\n    const {\n      skip = 0,\n      take = 10,\n      published,\n      authorId,\n      categoryId,\n      tagName,\n      search,\n      orderBy = { createdAt: 'desc' },\n    } = params;\n\n    const where: Prisma.PostWhereInput = {\n      AND: [\n        published !== undefined ? { published } : {},\n        authorId ? { authorId } : {},\n        categoryId ? { categories: { some: { id: categoryId } } } : {},\n        tagName ? { tags: { some: { name: tagName } } } : {},\n        search\n          ? {\n              OR: [\n                { title: { contains: search, mode: 'insensitive' } },\n                { content: { contains: search, mode: 'insensitive' } },\n              ],\n            }\n          : {},\n      ],\n    };\n\n    const [posts, total] = await prisma.$transaction([\n      prisma.post.findMany({\n        skip,\n        take,\n        where,\n        orderBy,\n        include: {\n          author: {\n            select: {\n              id: true,\n              name: true,\n            },\n          },\n          categories: true,\n          tags: true,\n          _count: {\n            select: {\n              comments: true,\n            },\n          },\n        },\n      }),\n      prisma.post.count({ where }),\n    ]);\n\n    return { posts, total };\n  }\n\n  // Full-text search\n  static async fullTextSearch(query: string) {\n    return prisma.post.findMany({\n      where: {\n        OR: [\n          {\n            title: {\n              search: query,\n            },\n          },\n          {\n            content: {\n              search: query,\n            },\n          },\n        ],\n      },\n      include: {\n        author: true,\n        categories: true,\n        tags: true,\n      },\n    });\n  }\n\n  // Increment view count\n  static async incrementViews(id: string) {\n    return prisma.post.update({\n      where: { id },\n      data: {\n        viewCount: {\n          increment: 1,\n        },\n      },\n    });\n  }\n\n  // Get popular posts\n  static async getPopular(limit = 10) {\n    return prisma.post.findMany({\n      where: { published: true },\n      orderBy: { viewCount: 'desc' },\n      take: limit,\n      include: {\n        author: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n        _count: {\n          select: {\n            comments: true,\n          },\n        },\n      },\n    });\n  }\n\n  // Get related posts\n  static async getRelated(postId: string, limit = 5) {\n    const post = await prisma.post.findUnique({\n      where: { id: postId },\n      include: {\n        categories: true,\n        tags: true,\n      },\n    });\n\n    if (!post) return [];\n\n    const categoryIds = post.categories.map(c => c.id);\n    const tagIds = post.tags.map(t => t.id);\n\n    return prisma.post.findMany({\n      where: {\n        id: { not: postId },\n        published: true,\n        OR: [\n          { categories: { some: { id: { in: categoryIds } } } },\n          { tags: { some: { id: { in: tagIds } } } },\n        ],\n      },\n      take: limit,\n      orderBy: { createdAt: 'desc' },\n      include: {\n        author: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n    });\n  }\n}\n\n// src/repositories/transaction.examples.ts\nimport { prisma } from '../config/database';\n\nexport class TransactionExamples {\n  // Interactive transaction - Transfer ownership\n  static async transferPostOwnership(postId: string, newOwnerId: string) {\n    return prisma.$transaction(async (tx) => {\n      // Get the post\n      const post = await tx.post.findUnique({\n        where: { id: postId },\n      });\n\n      if (!post) {\n        throw new Error('Post not found');\n      }\n\n      // Verify new owner exists\n      const newOwner = await tx.user.findUnique({\n        where: { id: newOwnerId },\n      });\n\n      if (!newOwner) {\n        throw new Error('New owner not found');\n      }\n\n      // Update post\n      const updatedPost = await tx.post.update({\n        where: { id: postId },\n        data: { authorId: newOwnerId },\n      });\n\n      // Create audit log (example)\n      await tx.$executeRaw`\n        INSERT INTO audit_logs (entity_type, entity_id, action, details)\n        VALUES ('post', ${postId}, 'ownership_transfer', \n                ${JSON.stringify({ from: post.authorId, to: newOwnerId })})\n      `;\n\n      return updatedPost;\n    });\n  }\n\n  // Batch operations in transaction\n  static async createUserWithProfile(userData: {\n    email: string;\n    name: string;\n    password: string;\n    bio?: string;\n  }) {\n    return prisma.$transaction(async (tx) => {\n      const user = await tx.user.create({\n        data: {\n          email: userData.email,\n          name: userData.name,\n          password: userData.password,\n        },\n      });\n\n      const profile = await tx.profile.create({\n        data: {\n          userId: user.id,\n          bio: userData.bio,\n        },\n      });\n\n      return { user, profile };\n    });\n  }\n\n  // Concurrent operations with isolation\n  static async publishPostWithNotifications(postId: string) {\n    return prisma.$transaction(\n      async (tx) => {\n        // Publish post\n        const post = await tx.post.update({\n          where: { id: postId },\n          data: {\n            published: true,\n            publishedAt: new Date(),\n          },\n        });\n\n        // Get followers (example)\n        const followers = await tx.$queryRaw`\n          SELECT user_id FROM followers WHERE following_id = ${post.authorId}\n        `;\n\n        // Create notifications (batch insert)\n        if (Array.isArray(followers) && followers.length > 0) {\n          await tx.$executeRaw`\n            INSERT INTO notifications (user_id, type, post_id)\n            SELECT user_id, 'new_post', ${postId}\n            FROM unnest(${followers.map((f: any) => f.user_id)}::uuid[]) AS user_id\n          `;\n        }\n\n        return post;\n      },\n      {\n        isolationLevel: Prisma.TransactionIsolationLevel.Serializable,\n        timeout: 10000, // 10 seconds\n      }\n    );\n  }\n}\n\n// src/services/database.service.ts\nimport { prisma } from '../config/database';\n\nexport class DatabaseService {\n  // Check database connection\n  static async checkConnection(): Promise<boolean> {\n    try {\n      await prisma.$queryRaw`SELECT 1`;\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Get database statistics\n  static async getStats() {\n    const [userCount, postCount, commentCount] = await prisma.$transaction([\n      prisma.user.count(),\n      prisma.post.count(),\n      prisma.comment.count(),\n    ]);\n\n    return {\n      users: userCount,\n      posts: postCount,\n      comments: commentCount,\n    };\n  }\n\n  // Cleanup old soft-deleted records\n  static async cleanupSoftDeleted(daysOld = 30) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n    const result = await prisma.$transaction([\n      prisma.user.deleteMany({\n        where: {\n          deletedAt: {\n            not: null,\n            lt: cutoffDate,\n          },\n        },\n      }),\n      prisma.post.deleteMany({\n        where: {\n          deletedAt: {\n            not: null,\n            lt: cutoffDate,\n          },\n        },\n      }),\n    ]);\n\n    return result;\n  }\n\n  // Execute raw SQL safely\n  static async executeRawQuery(query: string, params: any[] = []) {\n    return prisma.$queryRawUnsafe(query, ...params);\n  }\n}\n\n// prisma/seed.ts\nimport { PrismaClient } from '@prisma/client';\nimport { hash } from 'bcrypt';\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  console.log('Seeding database...');\n\n  // Create admin user\n  const adminPassword = await hash('admin123', 12);\n  const admin = await prisma.user.upsert({\n    where: { email: 'admin@example.com' },\n    update: {},\n    create: {\n      email: 'admin@example.com',\n      name: 'Admin User',\n      password: adminPassword,\n      role: 'ADMIN',\n      profile: {\n        create: {\n          bio: 'System administrator',\n        },\n      },\n    },\n  });\n\n  // Create categories\n  const categories = await Promise.all([\n    prisma.category.upsert({\n      where: { slug: 'technology' },\n      update: {},\n      create: {\n        name: 'Technology',\n        slug: 'technology',\n        description: 'Tech-related posts',\n      },\n    }),\n    prisma.category.upsert({\n      where: { slug: 'programming' },\n      update: {},\n      create: {\n        name: 'Programming',\n        slug: 'programming',\n        description: 'Programming tutorials and tips',\n      },\n    }),\n  ]);\n\n  // Create sample posts\n  await prisma.post.create({\n    data: {\n      title: 'Getting Started with Prisma',\n      content: 'Learn how to use Prisma ORM...',\n      slug: 'getting-started-with-prisma',\n      published: true,\n      authorId: admin.id,\n      categories: {\n        connect: [{ id: categories[0].id }, { id: categories[1].id }],\n      },\n      tags: {\n        connectOrCreate: [\n          { where: { name: 'prisma' }, create: { name: 'prisma' } },\n          { where: { name: 'database' }, create: { name: 'database' } },\n        ],\n      },\n    },\n  });\n\n  console.log('Seeding completed!');\n}\n\nmain()\n  .catch((e) => {\n    console.error(e);\n    process.exit(1);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n### TypeORM Patterns\n\n```typescript\n// src/config/typeorm.config.ts\nimport { DataSource } from 'typeorm';\nimport { User } from '../entities/User';\nimport { Post } from '../entities/Post';\nimport { Profile } from '../entities/Profile';\n\nexport const AppDataSource = new DataSource({\n  type: 'postgres',\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  username: process.env.DB_USER || 'postgres',\n  password: process.env.DB_PASSWORD || 'postgres',\n  database: process.env.DB_NAME || 'myapp',\n  synchronize: process.env.NODE_ENV === 'development',\n  logging: process.env.NODE_ENV === 'development',\n  entities: [User, Post, Profile],\n  migrations: ['src/migrations/**/*.ts'],\n  subscribers: ['src/subscribers/**/*.ts'],\n  ssl: process.env.NODE_ENV === 'production',\n});\n\n// src/entities/User.ts\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n  DeleteDateColumn,\n  OneToMany,\n  OneToOne,\n  Index,\n} from 'typeorm';\nimport { Post } from './Post';\nimport { Profile } from './Profile';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ unique: true })\n  @Index()\n  email: string;\n\n  @Column()\n  name: string;\n\n  @Column()\n  password: string;\n\n  @Column({ type: 'enum', enum: ['user', 'admin', 'moderator'], default: 'user' })\n  role: string;\n\n  @OneToOne(() => Profile, (profile) => profile.user, { cascade: true })\n  profile: Profile;\n\n  @OneToMany(() => Post, (post) => post.author)\n  posts: Post[];\n\n  @CreateDateColumn()\n  createdAt: Date;\n\n  @UpdateDateColumn()\n  updatedAt: Date;\n\n  @DeleteDateColumn()\n  deletedAt?: Date;\n}\n\n// src/repositories/user.repository.typeorm.ts\nimport { AppDataSource } from '../config/typeorm.config';\nimport { User } from '../entities/User';\nimport { FindManyOptions, Like } from 'typeorm';\n\nexport class UserRepositoryTypeORM {\n  private repository = AppDataSource.getRepository(User);\n\n  async create(data: Partial<User>): Promise<User> {\n    const user = this.repository.create(data);\n    return this.repository.save(user);\n  }\n\n  async findById(id: string): Promise<User | null> {\n    return this.repository.findOne({\n      where: { id },\n      relations: ['profile', 'posts'],\n    });\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return this.repository.findOne({ where: { email } });\n  }\n\n  async list(options: FindManyOptions<User> = {}) {\n    const [users, total] = await this.repository.findAndCount({\n      ...options,\n      relations: ['profile'],\n    });\n    return { users, total };\n  }\n\n  async update(id: string, data: Partial<User>): Promise<User | null> {\n    await this.repository.update(id, data);\n    return this.findById(id);\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const result = await this.repository.softDelete(id);\n    return result.affected ? result.affected > 0 : false;\n  }\n\n  async search(query: string) {\n    return this.repository.find({\n      where: [\n        { name: Like(`%${query}%`) },\n        { email: Like(`%${query}%`) },\n      ],\n      take: 20,\n    });\n  }\n}\n```\n\n## Best Practices\n\n1. **Use migrations**: Never modify schema directly in production\n2. **Index frequently queried fields**: Add indexes to foreign keys and search fields\n3. **Use transactions**: For operations that must succeed or fail together\n4. **Avoid N+1 queries**: Use `include` (Prisma) or `relations` (TypeORM)\n5. **Implement soft deletes**: Keep deleted records for audit trails\n6. **Use connection pooling**: Configure proper pool size for your workload\n7. **Add pagination**: Always paginate list queries\n8. **Type safety**: Leverage ORM type generation\n9. **Monitor queries**: Log slow queries in production\n10. **Seed data**: Maintain seed scripts for development and testing",
  "prompt": "A skill that provides complete database patterns with Prisma and TypeORM, including schema design, migrations, complex queries, transactions, relations, and optimization strategies with production-ready best practices",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
