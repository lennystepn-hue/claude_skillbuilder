{
  "id": "frontend-testing",
  "name": "frontend-testing",
  "description": "Comprehensive React testing with Jest, React Testing Library, component tests, integration tests, and advanced mocking strategies",
  "category": "Frontend",
  "content": "---\nname: frontend-testing\ndescription: Comprehensive React testing with Jest, React Testing Library, component tests, integration tests, and advanced mocking strategies\ncategory: Frontend\n---\n\n# React Testing with Jest & Testing Library\n\n## Overview\n\nThis skill provides comprehensive testing strategies for React applications using Jest and React Testing Library. It covers unit testing components, integration testing, mocking APIs and modules, testing hooks, accessibility testing, and best practices for writing maintainable tests.\n\n## Activation\n\nUse this skill when:\n- Writing tests for React components\n- Setting up test infrastructure for a React project\n- Testing user interactions and component behavior\n- Mocking API calls, modules, or third-party libraries\n- Writing integration tests for React applications\n- Testing custom hooks\n- Implementing accessibility testing\n- Debugging failing tests or improving test coverage\n\n## Instructions\n\n### Test Structure Best Practices\n\n1. **Organize tests by feature/component**\n   - Place tests next to components (`Component.tsx` + `Component.test.tsx`)\n   - Use `__tests__` directories for complex test suites\n   - Group related tests with `describe` blocks\n\n2. **Follow the AAA pattern**\n   - Arrange: Set up test data and render components\n   - Act: Perform user interactions or trigger events\n   - Assert: Verify expected outcomes\n\n3. **Test user behavior, not implementation**\n   - Query by accessible roles and labels\n   - Avoid testing internal state directly\n   - Focus on what users see and do\n\n4. **Write descriptive test names**\n   - Use \"it should...\" or \"it renders...\" format\n   - Be specific about the scenario and expected outcome\n\n### Testing Library Query Priority\n\n1. **Accessible to everyone**: `getByRole`, `getByLabelText`, `getByPlaceholderText`, `getByText`\n2. **Semantic queries**: `getByAltText`, `getByTitle`\n3. **Test IDs (last resort)**: `getByTestId`\n\n## Examples\n\n### Example 1: Basic Component Testing\n\n```typescript\n// Button.tsx\nimport React from 'react';\n\ninterface ButtonProps {\n  onClick: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary';\n  children: React.ReactNode;\n}\n\nexport const Button: React.FC<ButtonProps> = ({ \n  onClick, \n  disabled = false, \n  variant = 'primary',\n  children \n}) => {\n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className={`btn btn-${variant}`}\n      aria-label={typeof children === 'string' ? children : undefined}\n    >\n      {children}\n    </button>\n  );\n};\n\n// Button.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { Button } from './Button';\n\ndescribe('Button Component', () => {\n  it('should render with correct text', () => {\n    render(<Button onClick={() => {}}>Click me</Button>);\n    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();\n  });\n\n  it('should call onClick handler when clicked', async () => {\n    const handleClick = jest.fn();\n    const user = userEvent.setup();\n    \n    render(<Button onClick={handleClick}>Click me</Button>);\n    \n    await user.click(screen.getByRole('button'));\n    expect(handleClick).toHaveBeenCalledTimes(1);\n  });\n\n  it('should not call onClick when disabled', async () => {\n    const handleClick = jest.fn();\n    const user = userEvent.setup();\n    \n    render(<Button onClick={handleClick} disabled>Click me</Button>);\n    \n    const button = screen.getByRole('button');\n    expect(button).toBeDisabled();\n    \n    await user.click(button);\n    expect(handleClick).not.toHaveBeenCalled();\n  });\n\n  it('should apply correct variant class', () => {\n    const { rerender } = render(\n      <Button onClick={() => {}} variant=\"primary\">Primary</Button>\n    );\n    expect(screen.getByRole('button')).toHaveClass('btn-primary');\n    \n    rerender(<Button onClick={() => {}} variant=\"secondary\">Secondary</Button>);\n    expect(screen.getByRole('button')).toHaveClass('btn-secondary');\n  });\n});\n```\n\n### Example 2: Testing Forms and User Input\n\n```typescript\n// LoginForm.tsx\nimport React, { useState } from 'react';\n\ninterface LoginFormProps {\n  onSubmit: (credentials: { username: string; password: string }) => Promise<void>;\n}\n\nexport const LoginForm: React.FC<LoginFormProps> = ({ onSubmit }) => {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setError('');\n    \n    if (!username || !password) {\n      setError('Username and password are required');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      await onSubmit({ username, password });\n    } catch (err) {\n      setError('Login failed. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} aria-label=\"Login form\">\n      <div>\n        <label htmlFor=\"username\">Username</label>\n        <input\n          id=\"username\"\n          type=\"text\"\n          value={username}\n          onChange={(e) => setUsername(e.target.value)}\n          disabled={isLoading}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          value={password}\n          onChange={(e) => setPassword(e.target.value)}\n          disabled={isLoading}\n        />\n      </div>\n      {error && <div role=\"alert\">{error}</div>}\n      <button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Logging in...' : 'Login'}\n      </button>\n    </form>\n  );\n};\n\n// LoginForm.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { LoginForm } from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('should render form fields', () => {\n    render(<LoginForm onSubmit={jest.fn()} />);\n    \n    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();\n  });\n\n  it('should update input values when user types', async () => {\n    const user = userEvent.setup();\n    render(<LoginForm onSubmit={jest.fn()} />);\n    \n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    \n    await user.type(usernameInput, 'testuser');\n    await user.type(passwordInput, 'password123');\n    \n    expect(usernameInput).toHaveValue('testuser');\n    expect(passwordInput).toHaveValue('password123');\n  });\n\n  it('should show error when submitting empty form', async () => {\n    const user = userEvent.setup();\n    const mockSubmit = jest.fn();\n    render(<LoginForm onSubmit={mockSubmit} />);\n    \n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    expect(await screen.findByRole('alert')).toHaveTextContent(\n      /username and password are required/i\n    );\n    expect(mockSubmit).not.toHaveBeenCalled();\n  });\n\n  it('should call onSubmit with credentials when form is valid', async () => {\n    const user = userEvent.setup();\n    const mockSubmit = jest.fn().mockResolvedValue(undefined);\n    render(<LoginForm onSubmit={mockSubmit} />);\n    \n    await user.type(screen.getByLabelText(/username/i), 'testuser');\n    await user.type(screen.getByLabelText(/password/i), 'password123');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    await waitFor(() => {\n      expect(mockSubmit).toHaveBeenCalledWith({\n        username: 'testuser',\n        password: 'password123'\n      });\n    });\n  });\n\n  it('should show loading state during submission', async () => {\n    const user = userEvent.setup();\n    const mockSubmit = jest.fn(\n      () => new Promise(resolve => setTimeout(resolve, 100))\n    );\n    render(<LoginForm onSubmit={mockSubmit} />);\n    \n    await user.type(screen.getByLabelText(/username/i), 'testuser');\n    await user.type(screen.getByLabelText(/password/i), 'password123');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    expect(screen.getByRole('button')).toHaveTextContent(/logging in/i);\n    expect(screen.getByRole('button')).toBeDisabled();\n    \n    await waitFor(() => {\n      expect(screen.getByRole('button')).toHaveTextContent(/^login$/i);\n    });\n  });\n\n  it('should show error message when submission fails', async () => {\n    const user = userEvent.setup();\n    const mockSubmit = jest.fn().mockRejectedValue(new Error('Login failed'));\n    render(<LoginForm onSubmit={mockSubmit} />);\n    \n    await user.type(screen.getByLabelText(/username/i), 'testuser');\n    await user.type(screen.getByLabelText(/password/i), 'wrongpassword');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    \n    expect(await screen.findByRole('alert')).toHaveTextContent(\n      /login failed/i\n    );\n  });\n});\n```\n\n### Example 3: Mocking API Calls with MSW (Mock Service Worker)\n\n```typescript\n// api/users.ts\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport const fetchUsers = async (): Promise<User[]> => {\n  const response = await fetch('/api/users');\n  if (!response.ok) {\n    throw new Error('Failed to fetch users');\n  }\n  return response.json();\n};\n\n// UserList.tsx\nimport React, { useEffect, useState } from 'react';\nimport { fetchUsers, User } from './api/users';\n\nexport const UserList: React.FC = () => {\n  const [users, setUsers] = useState<User[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const loadUsers = async () => {\n      try {\n        setIsLoading(true);\n        const data = await fetchUsers();\n        setUsers(data);\n      } catch (err) {\n        setError('Failed to load users');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    loadUsers();\n  }, []);\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div role=\"alert\">{error}</div>;\n\n  return (\n    <ul aria-label=\"User list\">\n      {users.map(user => (\n        <li key={user.id}>\n          {user.name} - {user.email}\n        </li>\n      ))}\n    </ul>\n  );\n};\n\n// test/mocks/handlers.ts\nimport { rest } from 'msw';\nimport { User } from '../../api/users';\n\nexport const handlers = [\n  rest.get('/api/users', (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json<User[]>([\n        { id: '1', name: 'John Doe', email: 'john@example.com' },\n        { id: '2', name: 'Jane Smith', email: 'jane@example.com' }\n      ])\n    );\n  })\n];\n\n// test/mocks/server.ts\nimport { setupServer } from 'msw/node';\nimport { handlers } from './handlers';\n\nexport const server = setupServer(...handlers);\n\n// test/setup.ts\nimport '@testing-library/jest-dom';\nimport { server } from './mocks/server';\n\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }));\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\n// UserList.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { rest } from 'msw';\nimport { server } from './test/mocks/server';\nimport { UserList } from './UserList';\n\ndescribe('UserList', () => {\n  it('should show loading state initially', () => {\n    render(<UserList />);\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  });\n\n  it('should display users after loading', async () => {\n    render(<UserList />);\n    \n    await waitFor(() => {\n      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n    });\n    \n    expect(screen.getByText(/john doe/i)).toBeInTheDocument();\n    expect(screen.getByText(/john@example.com/i)).toBeInTheDocument();\n    expect(screen.getByText(/jane smith/i)).toBeInTheDocument();\n  });\n\n  it('should show error message when API call fails', async () => {\n    server.use(\n      rest.get('/api/users', (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ message: 'Server error' }));\n      })\n    );\n    \n    render(<UserList />);\n    \n    expect(await screen.findByRole('alert')).toHaveTextContent(\n      /failed to load users/i\n    );\n  });\n\n  it('should render empty list when no users exist', async () => {\n    server.use(\n      rest.get('/api/users', (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json([]));\n      })\n    );\n    \n    render(<UserList />);\n    \n    await waitFor(() => {\n      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n    });\n    \n    const list = screen.getByRole('list', { name: /user list/i });\n    expect(list).toBeInTheDocument();\n    expect(list.children).toHaveLength(0);\n  });\n});\n```\n\n### Example 4: Testing Custom Hooks\n\n```typescript\n// useCounter.ts\nimport { useState, useCallback } from 'react';\n\nexport const useCounter = (initialValue = 0, step = 1) => {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => {\n    setCount(c => c + step);\n  }, [step]);\n\n  const decrement = useCallback(() => {\n    setCount(c => c - step);\n  }, [step]);\n\n  const reset = useCallback(() => {\n    setCount(initialValue);\n  }, [initialValue]);\n\n  return { count, increment, decrement, reset };\n};\n\n// useCounter.test.ts\nimport { renderHook, act } from '@testing-library/react';\nimport { useCounter } from './useCounter';\n\ndescribe('useCounter', () => {\n  it('should initialize with default value', () => {\n    const { result } = renderHook(() => useCounter());\n    expect(result.current.count).toBe(0);\n  });\n\n  it('should initialize with custom value', () => {\n    const { result } = renderHook(() => useCounter(10));\n    expect(result.current.count).toBe(10);\n  });\n\n  it('should increment by step value', () => {\n    const { result } = renderHook(() => useCounter(0, 5));\n    \n    act(() => {\n      result.current.increment();\n    });\n    \n    expect(result.current.count).toBe(5);\n  });\n\n  it('should decrement by step value', () => {\n    const { result } = renderHook(() => useCounter(10, 3));\n    \n    act(() => {\n      result.current.decrement();\n    });\n    \n    expect(result.current.count).toBe(7);\n  });\n\n  it('should reset to initial value', () => {\n    const { result } = renderHook(() => useCounter(5));\n    \n    act(() => {\n      result.current.increment();\n      result.current.increment();\n    });\n    \n    expect(result.current.count).toBe(7);\n    \n    act(() => {\n      result.current.reset();\n    });\n    \n    expect(result.current.count).toBe(5);\n  });\n\n  it('should handle multiple operations', () => {\n    const { result } = renderHook(() => useCounter(0, 2));\n    \n    act(() => {\n      result.current.increment();\n      result.current.increment();\n      result.current.decrement();\n    });\n    \n    expect(result.current.count).toBe(2);\n  });\n});\n```\n\n### Example 5: Integration Testing with React Router\n\n```typescript\n// App.tsx\nimport { BrowserRouter, Routes, Route, Link } from 'react-router-dom';\nimport { Home } from './pages/Home';\nimport { About } from './pages/About';\nimport { UserProfile } from './pages/UserProfile';\n\nexport const App = () => {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/user/123\">Profile</Link>\n      </nav>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/user/:id\" element={<UserProfile />} />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n\n// App.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { App } from './App';\n\ndescribe('App Navigation', () => {\n  it('should render home page by default', () => {\n    render(<App />);\n    expect(screen.getByText(/welcome to home/i)).toBeInTheDocument();\n  });\n\n  it('should navigate to about page when link is clicked', async () => {\n    const user = userEvent.setup();\n    render(<App />);\n    \n    await user.click(screen.getByRole('link', { name: /about/i }));\n    \n    expect(await screen.findByText(/about us/i)).toBeInTheDocument();\n  });\n\n  it('should navigate to user profile with correct ID', async () => {\n    const user = userEvent.setup();\n    render(<App />);\n    \n    await user.click(screen.getByRole('link', { name: /profile/i }));\n    \n    expect(await screen.findByText(/user id: 123/i)).toBeInTheDocument();\n  });\n});\n\n// Alternative: Testing with MemoryRouter for more control\nimport { MemoryRouter } from 'react-router-dom';\n\nconst renderWithRouter = (initialRoute = '/') => {\n  return render(\n    <MemoryRouter initialEntries={[initialRoute]}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/about\" element={<About />} />\n        <Route path=\"/user/:id\" element={<UserProfile />} />\n      </Routes>\n    </MemoryRouter>\n  );\n};\n\ndescribe('Routing with MemoryRouter', () => {\n  it('should render user profile for specific route', () => {\n    renderWithRouter('/user/456');\n    expect(screen.getByText(/user id: 456/i)).toBeInTheDocument();\n  });\n});\n```\n\n### Example 6: Testing Context and Providers\n\n```typescript\n// ThemeContext.tsx\nimport React, { createContext, useContext, useState } from 'react';\n\ntype Theme = 'light' | 'dark';\n\ninterface ThemeContextValue {\n  theme: Theme;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextValue | undefined>(undefined);\n\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [theme, setTheme] = useState<Theme>('light');\n\n  const toggleTheme = () => {\n    setTheme(t => t === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n};\n\n// ThemedButton.tsx\nimport { useTheme } from './ThemeContext';\n\nexport const ThemedButton: React.FC = () => {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <button \n      onClick={toggleTheme}\n      style={{ background: theme === 'light' ? '#fff' : '#333' }}\n    >\n      Current theme: {theme}\n    </button>\n  );\n};\n\n// ThemedButton.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ThemeProvider } from './ThemeContext';\nimport { ThemedButton } from './ThemedButton';\n\nconst renderWithTheme = (component: React.ReactElement) => {\n  return render(\n    <ThemeProvider>\n      {component}\n    </ThemeProvider>\n  );\n};\n\ndescribe('ThemedButton', () => {\n  it('should render with light theme by default', () => {\n    renderWithTheme(<ThemedButton />);\n    expect(screen.getByText(/current theme: light/i)).toBeInTheDocument();\n  });\n\n  it('should toggle to dark theme when clicked', async () => {\n    const user = userEvent.setup();\n    renderWithTheme(<ThemedButton />);\n    \n    await user.click(screen.getByRole('button'));\n    \n    expect(screen.getByText(/current theme: dark/i)).toBeInTheDocument();\n  });\n\n  it('should toggle back to light theme', async () => {\n    const user = userEvent.setup();\n    renderWithTheme(<ThemedButton />);\n    \n    const button = screen.getByRole('button');\n    await user.click(button);\n    await user.click(button);\n    \n    expect(screen.getByText(/current theme: light/i)).toBeInTheDocument();\n  });\n\n  it('should throw error when used outside provider', () => {\n    // Suppress console.error for this test\n    const spy = jest.spyOn(console, 'error').mockImplementation();\n    \n    expect(() => render(<ThemedButton />)).toThrow(\n      /useTheme must be used within ThemeProvider/i\n    );\n    \n    spy.mockRestore();\n  });\n});\n```\n\n### Example 7: Snapshot Testing and Accessibility\n\n```typescript\n// Card.tsx\nimport React from 'react';\n\ninterface CardProps {\n  title: string;\n  description: string;\n  imageUrl?: string;\n  onAction?: () => void;\n}\n\nexport const Card: React.FC<CardProps> = ({ \n  title, \n  description, \n  imageUrl,\n  onAction \n}) => {\n  return (\n    <article className=\"card\">\n      {imageUrl && (\n        <img src={imageUrl} alt={title} />\n      )}\n      <h2>{title}</h2>\n      <p>{description}</p>\n      {onAction && (\n        <button onClick={onAction}>Learn More</button>\n      )}\n    </article>\n  );\n};\n\n// Card.test.tsx\nimport { render } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport { Card } from './Card';\n\nexpect.extend(toHaveNoViolations);\n\ndescribe('Card', () => {\n  const defaultProps = {\n    title: 'Test Card',\n    description: 'This is a test description'\n  };\n\n  it('should match snapshot', () => {\n    const { container } = render(<Card {...defaultProps} />);\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  it('should match snapshot with image', () => {\n    const { container } = render(\n      <Card {...defaultProps} imageUrl=\"/test.jpg\" />\n    );\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  it('should match snapshot with action button', () => {\n    const { container } = render(\n      <Card {...defaultProps} onAction={() => {}} />\n    );\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  it('should have no accessibility violations', async () => {\n    const { container } = render(<Card {...defaultProps} />);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n\n  it('should have no accessibility violations with all props', async () => {\n    const { container } = render(\n      <Card \n        {...defaultProps} \n        imageUrl=\"/test.jpg\"\n        onAction={() => {}}\n      />\n    );\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n});\n```\n\n## Best Practices\n\n1. **Use userEvent over fireEvent**: More realistic user interactions\n2. **Avoid implementation details**: Don't test state or props directly\n3. **Test accessibility**: Use jest-axe and query by accessible roles\n4. **Mock external dependencies**: Use MSW for API calls, jest.mock for modules\n5. **Write integration tests**: Test components working together\n6. **Keep tests isolated**: Each test should be independent\n7. **Use waitFor for async**: Handle loading states and async updates properly\n8. **Test error states**: Don't just test the happy path\n9. **Clean up after tests**: Use cleanup utilities and reset mocks\n10. **Use descriptive test names**: Make failures easy to understand\n\n## Common Patterns\n\n### Custom Render Function\n```typescript\nimport { render, RenderOptions } from '@testing-library/react';\nimport { ThemeProvider } from './ThemeContext';\nimport { QueryClient, QueryClientProvider } from 'react-query';\n\nconst AllProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n    },\n  });\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ThemeProvider>\n        {children}\n      </ThemeProvider>\n    </QueryClientProvider>\n  );\n};\n\nconst customRender = (\n  ui: React.ReactElement,\n  options?: Omit<RenderOptions, 'wrapper'>\n) => render(ui, { wrapper: AllProviders, ...options });\n\nexport * from '@testing-library/react';\nexport { customRender as render };\n```\n\n### Testing Timers and Debounce\n```typescript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\njest.useFakeTimers();\n\nit('should debounce search input', async () => {\n  const onSearch = jest.fn();\n  const user = userEvent.setup({ delay: null });\n  \n  render(<SearchInput onSearch={onSearch} />);\n  \n  await user.type(screen.getByRole('textbox'), 'test query');\n  \n  expect(onSearch).not.toHaveBeenCalled();\n  \n  jest.runAllTimers();\n  \n  await waitFor(() => {\n    expect(onSearch).toHaveBeenCalledWith('test query');\n    expect(onSearch).toHaveBeenCalledTimes(1);\n  });\n});\n```\n\nThis skill provides production-ready patterns for comprehensive React testing.",
  "prompt": "A skill that provides comprehensive React testing strategies using Jest and React Testing Library, including component tests, integration tests, custom hooks testing, API mocking with MSW, accessibility testing, and best practices for writing maintainable and robust test suites.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
