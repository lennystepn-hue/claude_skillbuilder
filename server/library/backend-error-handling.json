{
  "id": "backend-error-handling",
  "name": "Error Handling and Custom Errors",
  "description": "Implement comprehensive error handling with custom error classes, error middleware, validation, and graceful error recovery patterns",
  "category": "Backend",
  "content": "---\nname: Error Handling and Custom Errors\ndescription: Implement comprehensive error handling with custom error classes, error middleware, validation, and graceful error recovery patterns\ncategory: Backend\n---\n\n# Error Handling and Custom Errors\n\n## Overview\n\nThis skill provides production-ready patterns for implementing comprehensive error handling in backend applications. It covers custom error classes, error middleware, validation errors, async error handling, error recovery strategies, and monitoring integration.\n\n## Activation\n\nUse this skill when:\n- Setting up error handling architecture for an application\n- Creating custom error classes\n- Implementing error middleware for Express/Fastify\n- Handling validation errors\n- Implementing async error handling\n- Setting up error monitoring and alerting\n- Building error recovery mechanisms\n- User mentions \"error handling\", \"custom errors\", \"exceptions\", or \"error middleware\"\n\n## Instructions\n\n1. **Create a Clear Error Hierarchy**\n   - Extend base Error class for custom errors\n   - Use descriptive error names and messages\n   - Include error codes for API responses\n   - Add metadata for debugging\n\n2. **Implement Proper Error Classification**\n   - Operational errors (expected, recoverable)\n   - Programmer errors (bugs, should crash)\n   - Validation errors (user input)\n   - External errors (third-party services)\n\n3. **Use Error Middleware**\n   - Centralize error handling logic\n   - Format errors consistently\n   - Log errors appropriately\n   - Send proper HTTP status codes\n\n4. **Handle Async Errors Properly**\n   - Use try-catch in async functions\n   - Implement error handling wrappers\n   - Handle promise rejections\n   - Catch unhandled rejections globally\n\n5. **Provide Useful Error Information**\n   - Include context in error messages\n   - Add stack traces in development\n   - Sanitize errors in production\n   - Include correlation IDs\n\n6. **Implement Error Recovery**\n   - Retry failed operations when appropriate\n   - Use circuit breakers for external services\n   - Implement graceful degradation\n   - Clean up resources on errors\n\n7. **Monitor and Alert**\n   - Track error rates and patterns\n   - Set up alerting for critical errors\n   - Integrate with error tracking services\n   - Log errors with proper context\n\n## Examples\n\n### Example 1: Custom Error Classes\n\n```javascript\n// errors/base-error.js - Base error class with common functionality\nclass BaseError extends Error {\n  constructor(message, statusCode, errorCode, isOperational = true) {\n    super(message);\n    \n    this.name = this.constructor.name;\n    this.statusCode = statusCode;\n    this.errorCode = errorCode;\n    this.isOperational = isOperational;\n    this.timestamp = new Date();\n    \n    // Capture stack trace\n    Error.captureStackTrace(this, this.constructor);\n  }\n  \n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      statusCode: this.statusCode,\n      errorCode: this.errorCode,\n      timestamp: this.timestamp,\n      ...(process.env.NODE_ENV !== 'production' && { stack: this.stack })\n    };\n  }\n}\n\n// errors/application-errors.js - Application-specific error classes\nclass ValidationError extends BaseError {\n  constructor(message, errors = []) {\n    super(message, 400, 'VALIDATION_ERROR');\n    this.errors = errors;\n  }\n  \n  toJSON() {\n    return {\n      ...super.toJSON(),\n      errors: this.errors\n    };\n  }\n}\n\nclass NotFoundError extends BaseError {\n  constructor(resource, identifier) {\n    super(\n      `${resource} with identifier '${identifier}' not found`,\n      404,\n      'NOT_FOUND'\n    );\n    this.resource = resource;\n    this.identifier = identifier;\n  }\n}\n\nclass UnauthorizedError extends BaseError {\n  constructor(message = 'Authentication required') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nclass ForbiddenError extends BaseError {\n  constructor(message = 'Access denied') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nclass ConflictError extends BaseError {\n  constructor(message, conflictingField) {\n    super(message, 409, 'CONFLICT');\n    this.conflictingField = conflictingField;\n  }\n}\n\nclass BadRequestError extends BaseError {\n  constructor(message) {\n    super(message, 400, 'BAD_REQUEST');\n  }\n}\n\nclass InternalServerError extends BaseError {\n  constructor(message = 'Internal server error', originalError) {\n    super(message, 500, 'INTERNAL_SERVER_ERROR');\n    this.originalError = originalError;\n  }\n}\n\nclass ServiceUnavailableError extends BaseError {\n  constructor(service, message = 'Service temporarily unavailable') {\n    super(message, 503, 'SERVICE_UNAVAILABLE');\n    this.service = service;\n  }\n}\n\nclass TooManyRequestsError extends BaseError {\n  constructor(retryAfter) {\n    super('Too many requests', 429, 'RATE_LIMIT_EXCEEDED');\n    this.retryAfter = retryAfter;\n  }\n}\n\nclass DatabaseError extends BaseError {\n  constructor(message, query, originalError) {\n    super(message, 500, 'DATABASE_ERROR');\n    this.query = query;\n    this.originalError = originalError;\n  }\n}\n\nclass ExternalServiceError extends BaseError {\n  constructor(service, message, statusCode) {\n    super(message, 502, 'EXTERNAL_SERVICE_ERROR');\n    this.service = service;\n    this.externalStatusCode = statusCode;\n  }\n}\n\nmodule.exports = {\n  BaseError,\n  ValidationError,\n  NotFoundError,\n  UnauthorizedError,\n  ForbiddenError,\n  ConflictError,\n  BadRequestError,\n  InternalServerError,\n  ServiceUnavailableError,\n  TooManyRequestsError,\n  DatabaseError,\n  ExternalServiceError\n};\n```\n\n### Example 2: Error Handling Middleware\n\n```javascript\n// middleware/error-handler.js - Comprehensive error handling middleware\nconst logger = require('../logger');\nconst { BaseError } = require('../errors/base-error');\n\n// Async error wrapper to catch promise rejections\nfunction asyncHandler(fn) {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n}\n\n// Main error handler middleware\nfunction errorHandler(err, req, res, next) {\n  // Add correlation ID if available\n  const correlationId = req.correlationId || 'unknown';\n  \n  // Default to 500 internal server error\n  let statusCode = 500;\n  let errorResponse = {\n    error: {\n      message: 'Internal server error',\n      code: 'INTERNAL_SERVER_ERROR',\n      correlationId\n    }\n  };\n  \n  // Handle custom application errors\n  if (err instanceof BaseError) {\n    statusCode = err.statusCode;\n    errorResponse = {\n      error: {\n        message: err.message,\n        code: err.errorCode,\n        correlationId,\n        ...err.toJSON()\n      }\n    };\n    \n    // Log operational errors as warnings\n    if (err.isOperational) {\n      logger.warn('Operational Error', {\n        error: err.message,\n        code: err.errorCode,\n        statusCode: err.statusCode,\n        correlationId,\n        url: req.url,\n        method: req.method\n      });\n    } else {\n      // Log programmer errors as errors\n      logger.error('Programmer Error', {\n        error: err.message,\n        stack: err.stack,\n        correlationId,\n        url: req.url,\n        method: req.method\n      });\n    }\n  }\n  // Handle validation errors from express-validator\n  else if (err.name === 'ValidationError') {\n    statusCode = 400;\n    errorResponse = {\n      error: {\n        message: 'Validation failed',\n        code: 'VALIDATION_ERROR',\n        errors: err.errors || err.details,\n        correlationId\n      }\n    };\n    \n    logger.warn('Validation Error', {\n      errors: err.errors,\n      correlationId\n    });\n  }\n  // Handle JWT errors\n  else if (err.name === 'JsonWebTokenError') {\n    statusCode = 401;\n    errorResponse = {\n      error: {\n        message: 'Invalid token',\n        code: 'INVALID_TOKEN',\n        correlationId\n      }\n    };\n    \n    logger.warn('JWT Error', { error: err.message, correlationId });\n  }\n  else if (err.name === 'TokenExpiredError') {\n    statusCode = 401;\n    errorResponse = {\n      error: {\n        message: 'Token expired',\n        code: 'TOKEN_EXPIRED',\n        correlationId\n      }\n    };\n    \n    logger.warn('Token Expired', { correlationId });\n  }\n  // Handle Mongoose validation errors\n  else if (err.name === 'MongooseValidationError') {\n    statusCode = 400;\n    const errors = Object.values(err.errors).map(e => ({\n      field: e.path,\n      message: e.message\n    }));\n    \n    errorResponse = {\n      error: {\n        message: 'Validation failed',\n        code: 'VALIDATION_ERROR',\n        errors,\n        correlationId\n      }\n    };\n    \n    logger.warn('Mongoose Validation Error', { errors, correlationId });\n  }\n  // Handle Mongoose duplicate key errors\n  else if (err.code === 11000) {\n    statusCode = 409;\n    const field = Object.keys(err.keyPattern)[0];\n    \n    errorResponse = {\n      error: {\n        message: `Duplicate value for field: ${field}`,\n        code: 'DUPLICATE_KEY',\n        field,\n        correlationId\n      }\n    };\n    \n    logger.warn('Duplicate Key Error', { field, correlationId });\n  }\n  // Handle multer file upload errors\n  else if (err.name === 'MulterError') {\n    statusCode = 400;\n    errorResponse = {\n      error: {\n        message: err.message,\n        code: `UPLOAD_ERROR_${err.code}`,\n        correlationId\n      }\n    };\n    \n    logger.warn('File Upload Error', { error: err.message, correlationId });\n  }\n  // Handle all other errors\n  else {\n    logger.error('Unhandled Error', {\n      error: err.message,\n      stack: err.stack,\n      correlationId,\n      url: req.url,\n      method: req.method,\n      body: req.body\n    });\n    \n    // Don't expose internal error details in production\n    if (process.env.NODE_ENV !== 'production') {\n      errorResponse.error.message = err.message;\n      errorResponse.error.stack = err.stack;\n    }\n  }\n  \n  // Send error response\n  res.status(statusCode).json(errorResponse);\n}\n\n// 404 handler for undefined routes\nfunction notFoundHandler(req, res, next) {\n  const error = new NotFoundError('Route', req.originalUrl);\n  next(error);\n}\n\n// Global unhandled rejection handler\nfunction setupGlobalErrorHandlers() {\n  process.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection', {\n      reason: reason instanceof Error ? reason.message : reason,\n      stack: reason instanceof Error ? reason.stack : undefined,\n      promise\n    });\n    \n    // Exit the process in production for safety\n    if (process.env.NODE_ENV === 'production') {\n      process.exit(1);\n    }\n  });\n  \n  process.on('uncaughtException', (error) => {\n    logger.error('Uncaught Exception', {\n      error: error.message,\n      stack: error.stack\n    });\n    \n    // Always exit on uncaught exceptions\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  asyncHandler,\n  errorHandler,\n  notFoundHandler,\n  setupGlobalErrorHandlers\n};\n```\n\n### Example 3: Input Validation with Error Handling\n\n```javascript\n// validators/user-validator.js - Input validation with custom errors\nconst { body, param, query, validationResult } = require('express-validator');\nconst { ValidationError } = require('../errors/application-errors');\n\n// Validation middleware wrapper\nfunction validate(validations) {\n  return async (req, res, next) => {\n    // Run all validations\n    await Promise.all(validations.map(validation => validation.run(req)));\n    \n    // Check for errors\n    const errors = validationResult(req);\n    \n    if (errors.isEmpty()) {\n      return next();\n    }\n    \n    // Format errors\n    const formattedErrors = errors.array().map(err => ({\n      field: err.param,\n      message: err.msg,\n      value: err.value,\n      location: err.location\n    }));\n    \n    // Throw validation error\n    next(new ValidationError('Validation failed', formattedErrors));\n  };\n}\n\n// User creation validation\nconst createUserValidation = validate([\n  body('email')\n    .isEmail()\n    .withMessage('Must be a valid email address')\n    .normalizeEmail(),\n  \n  body('password')\n    .isLength({ min: 8 })\n    .withMessage('Password must be at least 8 characters')\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])/)\n    .withMessage('Password must contain uppercase, lowercase, number, and special character'),\n  \n  body('username')\n    .isLength({ min: 3, max: 30 })\n    .withMessage('Username must be between 3 and 30 characters')\n    .matches(/^[a-zA-Z0-9_]+$/)\n    .withMessage('Username can only contain letters, numbers, and underscores'),\n  \n  body('age')\n    .optional()\n    .isInt({ min: 13, max: 120 })\n    .withMessage('Age must be between 13 and 120'),\n  \n  body('role')\n    .optional()\n    .isIn(['user', 'admin', 'moderator'])\n    .withMessage('Invalid role')\n]);\n\n// User update validation\nconst updateUserValidation = validate([\n  param('id')\n    .isMongoId()\n    .withMessage('Invalid user ID'),\n  \n  body('email')\n    .optional()\n    .isEmail()\n    .withMessage('Must be a valid email address')\n    .normalizeEmail(),\n  \n  body('username')\n    .optional()\n    .isLength({ min: 3, max: 30 })\n    .withMessage('Username must be between 3 and 30 characters')\n]);\n\n// Query validation\nconst getUsersValidation = validate([\n  query('page')\n    .optional()\n    .isInt({ min: 1 })\n    .withMessage('Page must be a positive integer'),\n  \n  query('limit')\n    .optional()\n    .isInt({ min: 1, max: 100 })\n    .withMessage('Limit must be between 1 and 100'),\n  \n  query('sortBy')\n    .optional()\n    .isIn(['createdAt', 'email', 'username'])\n    .withMessage('Invalid sort field'),\n  \n  query('order')\n    .optional()\n    .isIn(['asc', 'desc'])\n    .withMessage('Order must be asc or desc')\n]);\n\n// Custom validator for business logic\nconst customValidator = {\n  isUniqueEmail: async (email) => {\n    const user = await User.findOne({ email });\n    if (user) {\n      throw new Error('Email already in use');\n    }\n    return true;\n  },\n  \n  isStrongPassword: (password) => {\n    const minLength = 8;\n    const hasUpperCase = /[A-Z]/.test(password);\n    const hasLowerCase = /[a-z]/.test(password);\n    const hasNumbers = /\\d/.test(password);\n    const hasSpecialChar = /[@$!%*?&]/.test(password);\n    \n    if (password.length < minLength) {\n      throw new Error(`Password must be at least ${minLength} characters`);\n    }\n    if (!hasUpperCase) {\n      throw new Error('Password must contain at least one uppercase letter');\n    }\n    if (!hasLowerCase) {\n      throw new Error('Password must contain at least one lowercase letter');\n    }\n    if (!hasNumbers) {\n      throw new Error('Password must contain at least one number');\n    }\n    if (!hasSpecialChar) {\n      throw new Error('Password must contain at least one special character');\n    }\n    \n    return true;\n  }\n};\n\nmodule.exports = {\n  validate,\n  createUserValidation,\n  updateUserValidation,\n  getUsersValidation,\n  customValidator\n};\n```\n\n### Example 4: Error Recovery and Retry Logic\n\n```javascript\n// utils/retry.js - Retry logic with exponential backoff\nconst logger = require('../logger');\nconst { ExternalServiceError } = require('../errors/application-errors');\n\nclass RetryStrategy {\n  constructor(options = {}) {\n    this.maxRetries = options.maxRetries || 3;\n    this.initialDelay = options.initialDelay || 1000;\n    this.maxDelay = options.maxDelay || 10000;\n    this.backoffMultiplier = options.backoffMultiplier || 2;\n    this.retryableErrors = options.retryableErrors || [500, 502, 503, 504];\n  }\n  \n  async execute(fn, context = {}) {\n    let lastError;\n    \n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        const result = await fn();\n        \n        if (attempt > 0) {\n          logger.info('Retry succeeded', {\n            operation: context.operation,\n            attempt,\n            totalAttempts: this.maxRetries + 1\n          });\n        }\n        \n        return result;\n      } catch (error) {\n        lastError = error;\n        \n        // Check if error is retryable\n        const isRetryable = this.isRetryableError(error);\n        const isLastAttempt = attempt === this.maxRetries;\n        \n        if (!isRetryable || isLastAttempt) {\n          logger.error('Retry failed', {\n            operation: context.operation,\n            attempt,\n            error: error.message,\n            isRetryable,\n            isLastAttempt\n          });\n          \n          throw error;\n        }\n        \n        // Calculate delay with exponential backoff\n        const delay = Math.min(\n          this.initialDelay * Math.pow(this.backoffMultiplier, attempt),\n          this.maxDelay\n        );\n        \n        logger.warn('Retrying operation', {\n          operation: context.operation,\n          attempt: attempt + 1,\n          maxRetries: this.maxRetries,\n          delay: `${delay}ms`,\n          error: error.message\n        });\n        \n        await this.sleep(delay);\n      }\n    }\n    \n    throw lastError;\n  }\n  \n  isRetryableError(error) {\n    // Check HTTP status codes\n    if (error.statusCode) {\n      return this.retryableErrors.includes(error.statusCode);\n    }\n    \n    // Check for network errors\n    if (error.code === 'ECONNRESET' || \n        error.code === 'ETIMEDOUT' || \n        error.code === 'ENOTFOUND') {\n      return true;\n    }\n    \n    return false;\n  }\n  \n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Circuit breaker pattern\nclass CircuitBreaker {\n  constructor(options = {}) {\n    this.failureThreshold = options.failureThreshold || 5;\n    this.successThreshold = options.successThreshold || 2;\n    this.timeout = options.timeout || 60000;\n    this.resetTimeout = options.resetTimeout || 30000;\n    \n    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.nextAttempt = Date.now();\n  }\n  \n  async execute(fn, context = {}) {\n    if (this.state === 'OPEN') {\n      if (Date.now() < this.nextAttempt) {\n        throw new ServiceUnavailableError(\n          context.service,\n          'Circuit breaker is OPEN'\n        );\n      }\n      \n      // Try half-open state\n      this.state = 'HALF_OPEN';\n      logger.info('Circuit breaker entering HALF_OPEN state', context);\n    }\n    \n    try {\n      const result = await this.executeWithTimeout(fn);\n      this.onSuccess(context);\n      return result;\n    } catch (error) {\n      this.onFailure(error, context);\n      throw error;\n    }\n  }\n  \n  async executeWithTimeout(fn) {\n    return Promise.race([\n      fn(),\n      new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Operation timeout')), this.timeout)\n      )\n    ]);\n  }\n  \n  onSuccess(context) {\n    this.failureCount = 0;\n    \n    if (this.state === 'HALF_OPEN') {\n      this.successCount++;\n      \n      if (this.successCount >= this.successThreshold) {\n        this.state = 'CLOSED';\n        this.successCount = 0;\n        logger.info('Circuit breaker CLOSED', context);\n      }\n    }\n  }\n  \n  onFailure(error, context) {\n    this.failureCount++;\n    this.successCount = 0;\n    \n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n      this.nextAttempt = Date.now() + this.resetTimeout;\n      \n      logger.error('Circuit breaker OPEN', {\n        ...context,\n        failureCount: this.failureCount,\n        resetTimeout: this.resetTimeout,\n        error: error.message\n      });\n    }\n  }\n  \n  getState() {\n    return {\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n      nextAttempt: this.nextAttempt\n    };\n  }\n}\n\nmodule.exports = {\n  RetryStrategy,\n  CircuitBreaker\n};\n```\n\n### Example 5: Error Monitoring Integration\n\n```javascript\n// monitoring/error-tracker.js - Error tracking integration\nconst Sentry = require('@sentry/node');\nconst logger = require('../logger');\n\nclass ErrorTracker {\n  constructor() {\n    this.initialized = false;\n  }\n  \n  initialize() {\n    if (process.env.SENTRY_DSN) {\n      Sentry.init({\n        dsn: process.env.SENTRY_DSN,\n        environment: process.env.NODE_ENV,\n        release: process.env.APP_VERSION,\n        tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,\n        \n        beforeSend(event, hint) {\n          // Filter out operational errors in production\n          const error = hint.originalException;\n          if (error && error.isOperational && process.env.NODE_ENV === 'production') {\n            return null;\n          }\n          \n          // Add custom context\n          event.tags = {\n            ...event.tags,\n            service: process.env.SERVICE_NAME\n          };\n          \n          return event;\n        }\n      });\n      \n      this.initialized = true;\n      logger.info('Error tracking initialized', { service: 'Sentry' });\n    }\n  }\n  \n  captureError(error, context = {}) {\n    if (!this.initialized) return;\n    \n    Sentry.withScope(scope => {\n      // Add user context\n      if (context.user) {\n        scope.setUser({\n          id: context.user.id,\n          email: context.user.email,\n          username: context.user.username\n        });\n      }\n      \n      // Add request context\n      if (context.request) {\n        scope.setContext('request', {\n          method: context.request.method,\n          url: context.request.url,\n          headers: context.request.headers,\n          query: context.request.query,\n          body: context.request.body\n        });\n      }\n      \n      // Add custom context\n      if (context.extra) {\n        scope.setExtras(context.extra);\n      }\n      \n      // Add tags\n      if (context.tags) {\n        scope.setTags(context.tags);\n      }\n      \n      // Set severity\n      const level = this.mapErrorLevel(error);\n      scope.setLevel(level);\n      \n      // Capture the error\n      Sentry.captureException(error);\n    });\n  }\n  \n  captureMessage(message, level = 'info', context = {}) {\n    if (!this.initialized) return;\n    \n    Sentry.withScope(scope => {\n      if (context.extra) {\n        scope.setExtras(context.extra);\n      }\n      \n      if (context.tags) {\n        scope.setTags(context.tags);\n      }\n      \n      Sentry.captureMessage(message, level);\n    });\n  }\n  \n  mapErrorLevel(error) {\n    if (error.statusCode && error.statusCode < 500) {\n      return 'warning';\n    }\n    if (error.isOperational) {\n      return 'error';\n    }\n    return 'fatal';\n  }\n  \n  // Express middleware\n  requestHandler() {\n    return Sentry.Handlers.requestHandler();\n  }\n  \n  errorHandler() {\n    return Sentry.Handlers.errorHandler();\n  }\n}\n\nconst errorTracker = new ErrorTracker();\nerrorTracker.initialize();\n\nmodule.exports = errorTracker;\n```",
  "prompt": "A skill that implements comprehensive error handling patterns including custom error classes, error middleware, validation, async error handling, retry logic with exponential backoff, circuit breaker pattern, and integration with error monitoring services like Sentry.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
