{
  "id": "backend-rest-api",
  "name": "REST API Design",
  "description": "Comprehensive REST API design patterns with Express.js and FastAPI, including routing, middleware, validation, error handling, and best practices",
  "category": "Backend",
  "content": "---\nname: REST API Design\ndescription: Comprehensive REST API design patterns with Express.js and FastAPI, including routing, middleware, validation, error handling, and best practices\ncategory: Backend\n---\n\n# REST API Design\n\n## Overview\n\nThis skill provides production-ready patterns for building RESTful APIs using Express.js (Node.js) and FastAPI (Python). It covers routing, middleware chains, request validation, error handling, response formatting, versioning, and API documentation.\n\n## Activation\n\nUse this skill when:\n- Building RESTful APIs from scratch\n- Implementing CRUD operations with proper HTTP methods\n- Setting up routing, middleware, and request validation\n- Designing API endpoints with proper resource modeling\n- Implementing error handling and response formatting\n- Adding API versioning or documentation\n- Migrating between API frameworks\n\n## Instructions\n\n1. **Choose Framework**: Select Express.js for Node.js or FastAPI for Python based on ecosystem\n2. **Design Resources**: Model your API resources following REST conventions\n3. **Implement Routing**: Set up routes with proper HTTP methods (GET, POST, PUT, PATCH, DELETE)\n4. **Add Middleware**: Implement logging, authentication, validation, and error handling\n5. **Validate Input**: Use validation libraries (Zod, Joi, Pydantic) for request validation\n6. **Handle Errors**: Implement centralized error handling with proper HTTP status codes\n7. **Format Responses**: Use consistent response formats across all endpoints\n8. **Document API**: Generate OpenAPI/Swagger documentation\n9. **Version API**: Implement versioning strategy (URL, header, or content negotiation)\n\n## Examples\n\n### Express.js REST API (Complete)\n\n```typescript\n// src/types/index.ts\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateUserDTO {\n  email: string;\n  name: string;\n  password: string;\n}\n\nexport interface UpdateUserDTO {\n  email?: string;\n  name?: string;\n}\n\nexport interface ApiError {\n  message: string;\n  code: string;\n  statusCode: number;\n  details?: any;\n}\n\n// src/middleware/validation.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { z, ZodSchema } from 'zod';\n\nexport const validate = (schema: ZodSchema) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      await schema.parseAsync({\n        body: req.body,\n        query: req.query,\n        params: req.params,\n      });\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({\n          message: 'Validation failed',\n          code: 'VALIDATION_ERROR',\n          statusCode: 400,\n          details: error.errors,\n        });\n      } else {\n        next(error);\n      }\n    }\n  };\n};\n\n// src/middleware/errorHandler.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { ApiError } from '../types';\n\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_ERROR',\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\nexport const errorHandler = (\n  err: Error | AppError,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  console.error('Error:', err);\n\n  if (err instanceof AppError) {\n    const errorResponse: ApiError = {\n      message: err.message,\n      code: err.code,\n      statusCode: err.statusCode,\n      details: err.details,\n    };\n    return res.status(err.statusCode).json(errorResponse);\n  }\n\n  // Handle unexpected errors\n  const errorResponse: ApiError = {\n    message: 'Internal server error',\n    code: 'INTERNAL_ERROR',\n    statusCode: 500,\n  };\n  res.status(500).json(errorResponse);\n};\n\n// src/middleware/requestLogger.ts\nimport { Request, Response, NextFunction } from 'express';\nimport morgan from 'morgan';\n\nexport const requestLogger = morgan(\n  ':method :url :status :res[content-length] - :response-time ms'\n);\n\n// Custom logger for specific routes\nexport const logRequest = (req: Request, res: Response, next: NextFunction) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log({\n      method: req.method,\n      url: req.url,\n      status: res.statusCode,\n      duration: `${duration}ms`,\n      userAgent: req.get('user-agent'),\n    });\n  });\n  \n  next();\n};\n\n// src/schemas/user.schemas.ts\nimport { z } from 'zod';\n\nexport const createUserSchema = z.object({\n  body: z.object({\n    email: z.string().email('Invalid email format'),\n    name: z.string().min(2, 'Name must be at least 2 characters'),\n    password: z.string().min(8, 'Password must be at least 8 characters'),\n  }),\n});\n\nexport const updateUserSchema = z.object({\n  params: z.object({\n    id: z.string().uuid('Invalid user ID'),\n  }),\n  body: z.object({\n    email: z.string().email('Invalid email format').optional(),\n    name: z.string().min(2, 'Name must be at least 2 characters').optional(),\n  }),\n});\n\nexport const getUserSchema = z.object({\n  params: z.object({\n    id: z.string().uuid('Invalid user ID'),\n  }),\n});\n\nexport const listUsersSchema = z.object({\n  query: z.object({\n    page: z.string().transform(Number).default('1'),\n    limit: z.string().transform(Number).default('10'),\n    sortBy: z.enum(['createdAt', 'name', 'email']).default('createdAt'),\n    order: z.enum(['asc', 'desc']).default('desc'),\n  }),\n});\n\n// src/controllers/user.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../middleware/errorHandler';\nimport { CreateUserDTO, UpdateUserDTO, User } from '../types';\nimport * as userService from '../services/user.service';\n\nexport const createUser = async (\n  req: Request<{}, {}, CreateUserDTO>,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const user = await userService.createUser(req.body);\n    res.status(201).json({\n      success: true,\n      data: user,\n    });\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const getUser = async (\n  req: Request<{ id: string }>,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const user = await userService.getUserById(req.params.id);\n    \n    if (!user) {\n      throw new AppError('User not found', 404, 'USER_NOT_FOUND');\n    }\n    \n    res.json({\n      success: true,\n      data: user,\n    });\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const listUsers = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const { page, limit, sortBy, order } = req.query;\n    \n    const result = await userService.listUsers({\n      page: Number(page) || 1,\n      limit: Number(limit) || 10,\n      sortBy: sortBy as string,\n      order: order as 'asc' | 'desc',\n    });\n    \n    res.json({\n      success: true,\n      data: result.users,\n      meta: {\n        page: result.page,\n        limit: result.limit,\n        total: result.total,\n        totalPages: result.totalPages,\n      },\n    });\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const updateUser = async (\n  req: Request<{ id: string }, {}, UpdateUserDTO>,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const user = await userService.updateUser(req.params.id, req.body);\n    \n    if (!user) {\n      throw new AppError('User not found', 404, 'USER_NOT_FOUND');\n    }\n    \n    res.json({\n      success: true,\n      data: user,\n    });\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const deleteUser = async (\n  req: Request<{ id: string }>,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    await userService.deleteUser(req.params.id);\n    \n    res.status(204).send();\n  } catch (error) {\n    next(error);\n  }\n};\n\n// src/routes/user.routes.ts\nimport { Router } from 'express';\nimport * as userController from '../controllers/user.controller';\nimport { validate } from '../middleware/validation';\nimport {\n  createUserSchema,\n  updateUserSchema,\n  getUserSchema,\n  listUsersSchema,\n} from '../schemas/user.schemas';\n\nconst router = Router();\n\nrouter.post(\n  '/',\n  validate(createUserSchema),\n  userController.createUser\n);\n\nrouter.get(\n  '/',\n  validate(listUsersSchema),\n  userController.listUsers\n);\n\nrouter.get(\n  '/:id',\n  validate(getUserSchema),\n  userController.getUser\n);\n\nrouter.patch(\n  '/:id',\n  validate(updateUserSchema),\n  userController.updateUser\n);\n\nrouter.delete(\n  '/:id',\n  validate(getUserSchema),\n  userController.deleteUser\n);\n\nexport default router;\n\n// src/routes/index.ts\nimport { Router } from 'express';\nimport userRoutes from './user.routes';\n\nconst router = Router();\n\n// API versioning\nrouter.use('/v1/users', userRoutes);\n\n// Health check\nrouter.get('/health', (req, res) => {\n  res.json({ status: 'ok', timestamp: new Date().toISOString() });\n});\n\nexport default router;\n\n// src/app.ts\nimport express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport rateLimit from 'express-rate-limit';\nimport { requestLogger } from './middleware/requestLogger';\nimport { errorHandler } from './middleware/errorHandler';\nimport routes from './routes';\n\nconst app: Application = express();\n\n// Security middleware\napp.use(helmet());\napp.use(cors());\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP, please try again later.',\n});\napp.use('/api', limiter);\n\n// Body parsing\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Compression\napp.use(compression());\n\n// Logging\napp.use(requestLogger);\n\n// API routes\napp.use('/api', routes);\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    message: 'Route not found',\n    code: 'NOT_FOUND',\n    statusCode: 404,\n  });\n});\n\n// Error handling\napp.use(errorHandler);\n\nexport default app;\n\n// src/server.ts\nimport app from './app';\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n### FastAPI REST API (Complete)\n\n```python\n# app/models.py\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel, EmailStr, Field, ConfigDict\nfrom uuid import UUID, uuid4\n\nclass UserBase(BaseModel):\n    email: EmailStr\n    name: str = Field(..., min_length=2, max_length=100)\n\nclass UserCreate(UserBase):\n    password: str = Field(..., min_length=8, max_length=100)\n\nclass UserUpdate(BaseModel):\n    email: Optional[EmailStr] = None\n    name: Optional[str] = Field(None, min_length=2, max_length=100)\n\nclass UserInDB(UserBase):\n    id: UUID\n    created_at: datetime\n    updated_at: datetime\n    \n    model_config = ConfigDict(from_attributes=True)\n\nclass UserResponse(BaseModel):\n    success: bool = True\n    data: UserInDB\n\nclass UsersListResponse(BaseModel):\n    success: bool = True\n    data: list[UserInDB]\n    meta: dict\n\nclass ErrorResponse(BaseModel):\n    message: str\n    code: str\n    status_code: int\n    details: Optional[dict] = None\n\n# app/exceptions.py\nfrom fastapi import HTTPException, status\n\nclass AppException(HTTPException):\n    def __init__(\n        self,\n        message: str,\n        status_code: int = status.HTTP_500_INTERNAL_SERVER_ERROR,\n        code: str = \"INTERNAL_ERROR\",\n        details: dict = None,\n    ):\n        super().__init__(status_code=status_code, detail=message)\n        self.code = code\n        self.details = details\n\nclass NotFoundException(AppException):\n    def __init__(self, message: str = \"Resource not found\", details: dict = None):\n        super().__init__(\n            message=message,\n            status_code=status.HTTP_404_NOT_FOUND,\n            code=\"NOT_FOUND\",\n            details=details,\n        )\n\nclass ValidationException(AppException):\n    def __init__(self, message: str = \"Validation failed\", details: dict = None):\n        super().__init__(\n            message=message,\n            status_code=status.HTTP_400_BAD_REQUEST,\n            code=\"VALIDATION_ERROR\",\n            details=details,\n        )\n\nclass ConflictException(AppException):\n    def __init__(self, message: str = \"Resource conflict\", details: dict = None):\n        super().__init__(\n            message=message,\n            status_code=status.HTTP_409_CONFLICT,\n            code=\"CONFLICT\",\n            details=details,\n        )\n\n# app/middleware.py\nimport time\nimport logging\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom uuid import uuid4\n\nlogger = logging.getLogger(__name__)\n\nclass RequestLoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        request_id = str(uuid4())\n        request.state.request_id = request_id\n        \n        start_time = time.time()\n        \n        logger.info(f\"Request started: {request.method} {request.url.path}\")\n        \n        response = await call_next(request)\n        \n        process_time = time.time() - start_time\n        \n        logger.info(\n            f\"Request completed: {request.method} {request.url.path} \"\n            f\"status={response.status_code} duration={process_time:.3f}s\"\n        )\n        \n        response.headers[\"X-Request-ID\"] = request_id\n        response.headers[\"X-Process-Time\"] = str(process_time)\n        \n        return response\n\nclass ErrorHandlingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        try:\n            response = await call_next(request)\n            return response\n        except Exception as exc:\n            logger.exception(\"Unhandled exception\")\n            return Response(\n                content=str(exc),\n                status_code=500,\n            )\n\n# app/dependencies.py\nfrom fastapi import Query\nfrom typing import Optional\n\nclass PaginationParams:\n    def __init__(\n        self,\n        page: int = Query(1, ge=1, description=\"Page number\"),\n        limit: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    ):\n        self.page = page\n        self.limit = limit\n        self.skip = (page - 1) * limit\n\nclass SortParams:\n    def __init__(\n        self,\n        sort_by: str = Query(\"created_at\", description=\"Field to sort by\"),\n        order: str = Query(\"desc\", regex=\"^(asc|desc)$\", description=\"Sort order\"),\n    ):\n        self.sort_by = sort_by\n        self.order = order\n\n# app/services/user_service.py\nfrom uuid import UUID, uuid4\nfrom datetime import datetime\nfrom typing import Optional, List\nfrom app.models import UserCreate, UserUpdate, UserInDB\nfrom app.exceptions import NotFoundException, ConflictException\n\n# Mock database (replace with real database)\nusers_db: dict[UUID, dict] = {}\n\nclass UserService:\n    @staticmethod\n    async def create_user(user_data: UserCreate) -> UserInDB:\n        # Check if email already exists\n        existing_user = next(\n            (u for u in users_db.values() if u[\"email\"] == user_data.email),\n            None,\n        )\n        if existing_user:\n            raise ConflictException(\"Email already registered\")\n        \n        user_id = uuid4()\n        now = datetime.utcnow()\n        \n        user_dict = {\n            \"id\": user_id,\n            \"email\": user_data.email,\n            \"name\": user_data.name,\n            \"created_at\": now,\n            \"updated_at\": now,\n        }\n        \n        users_db[user_id] = user_dict\n        return UserInDB(**user_dict)\n    \n    @staticmethod\n    async def get_user(user_id: UUID) -> Optional[UserInDB]:\n        user = users_db.get(user_id)\n        if not user:\n            return None\n        return UserInDB(**user)\n    \n    @staticmethod\n    async def list_users(\n        skip: int = 0,\n        limit: int = 10,\n        sort_by: str = \"created_at\",\n        order: str = \"desc\",\n    ) -> tuple[List[UserInDB], int]:\n        users_list = list(users_db.values())\n        \n        # Sort\n        reverse = order == \"desc\"\n        users_list.sort(key=lambda x: x.get(sort_by, \"\"), reverse=reverse)\n        \n        # Paginate\n        total = len(users_list)\n        users_page = users_list[skip : skip + limit]\n        \n        return [UserInDB(**u) for u in users_page], total\n    \n    @staticmethod\n    async def update_user(user_id: UUID, user_data: UserUpdate) -> Optional[UserInDB]:\n        user = users_db.get(user_id)\n        if not user:\n            return None\n        \n        # Check email conflict\n        if user_data.email:\n            existing = next(\n                (u for uid, u in users_db.items() \n                 if u[\"email\"] == user_data.email and uid != user_id),\n                None,\n            )\n            if existing:\n                raise ConflictException(\"Email already in use\")\n        \n        update_dict = user_data.model_dump(exclude_unset=True)\n        user.update(update_dict)\n        user[\"updated_at\"] = datetime.utcnow()\n        \n        return UserInDB(**user)\n    \n    @staticmethod\n    async def delete_user(user_id: UUID) -> bool:\n        if user_id in users_db:\n            del users_db[user_id]\n            return True\n        return False\n\n# app/routers/users.py\nfrom fastapi import APIRouter, Depends, status, Response\nfrom uuid import UUID\nfrom typing import Annotated\nfrom app.models import UserCreate, UserUpdate, UserResponse, UsersListResponse\nfrom app.services.user_service import UserService\nfrom app.dependencies import PaginationParams, SortParams\nfrom app.exceptions import NotFoundException\nimport math\n\nrouter = APIRouter(prefix=\"/users\", tags=[\"users\"])\nuser_service = UserService()\n\n@router.post(\n    \"/\",\n    response_model=UserResponse,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create a new user\",\n)\nasync def create_user(user_data: UserCreate):\n    \"\"\"Create a new user with email, name, and password.\"\"\"\n    user = await user_service.create_user(user_data)\n    return UserResponse(data=user)\n\n@router.get(\n    \"/\",\n    response_model=UsersListResponse,\n    summary=\"List all users\",\n)\nasync def list_users(\n    pagination: Annotated[PaginationParams, Depends()],\n    sort: Annotated[SortParams, Depends()],\n):\n    \"\"\"Get a paginated list of users with sorting.\"\"\"\n    users, total = await user_service.list_users(\n        skip=pagination.skip,\n        limit=pagination.limit,\n        sort_by=sort.sort_by,\n        order=sort.order,\n    )\n    \n    total_pages = math.ceil(total / pagination.limit)\n    \n    return UsersListResponse(\n        data=users,\n        meta={\n            \"page\": pagination.page,\n            \"limit\": pagination.limit,\n            \"total\": total,\n            \"total_pages\": total_pages,\n        },\n    )\n\n@router.get(\n    \"/{user_id}\",\n    response_model=UserResponse,\n    summary=\"Get user by ID\",\n)\nasync def get_user(user_id: UUID):\n    \"\"\"Get a specific user by their ID.\"\"\"\n    user = await user_service.get_user(user_id)\n    if not user:\n        raise NotFoundException(f\"User with ID {user_id} not found\")\n    return UserResponse(data=user)\n\n@router.patch(\n    \"/{user_id}\",\n    response_model=UserResponse,\n    summary=\"Update user\",\n)\nasync def update_user(user_id: UUID, user_data: UserUpdate):\n    \"\"\"Update user information.\"\"\"\n    user = await user_service.update_user(user_id, user_data)\n    if not user:\n        raise NotFoundException(f\"User with ID {user_id} not found\")\n    return UserResponse(data=user)\n\n@router.delete(\n    \"/{user_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete user\",\n)\nasync def delete_user(user_id: UUID):\n    \"\"\"Delete a user by their ID.\"\"\"\n    deleted = await user_service.delete_user(user_id)\n    if not deleted:\n        raise NotFoundException(f\"User with ID {user_id} not found\")\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n\n# app/main.py\nfrom fastapi import FastAPI, Request, status\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.gzip import GZipMiddleware\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\nfrom app.middleware import RequestLoggingMiddleware\nfrom app.exceptions import AppException\nfrom app.routers import users\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\napp = FastAPI(\n    title=\"User API\",\n    description=\"Production-ready REST API for user management\",\n    version=\"1.0.0\",\n    docs_url=\"/api/docs\",\n    redoc_url=\"/api/redoc\",\n)\n\n# Add rate limiting\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Compression\napp.add_middleware(GZipMiddleware, minimum_size=1000)\n\n# Custom middleware\napp.add_middleware(RequestLoggingMiddleware)\n\n# Exception handlers\n@app.exception_handler(AppException)\nasync def app_exception_handler(request: Request, exc: AppException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"message\": exc.detail,\n            \"code\": exc.code,\n            \"status_code\": exc.status_code,\n            \"details\": exc.details,\n        },\n    )\n\n@app.exception_handler(Exception)\nasync def general_exception_handler(request: Request, exc: Exception):\n    logger.exception(\"Unhandled exception\")\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\n            \"message\": \"Internal server error\",\n            \"code\": \"INTERNAL_ERROR\",\n            \"status_code\": 500,\n        },\n    )\n\n# Health check\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"ok\", \"timestamp\": datetime.utcnow().isoformat()}\n\n# API routes\napp.include_router(users.router, prefix=\"/api/v1\")\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n## Best Practices\n\n1. **Use proper HTTP methods**: GET (read), POST (create), PUT/PATCH (update), DELETE (delete)\n2. **Return appropriate status codes**: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 404 (Not Found), 500 (Server Error)\n3. **Validate all inputs**: Use schema validation libraries\n4. **Handle errors centrally**: Use error handling middleware\n5. **Version your API**: Use URL versioning (/v1/, /v2/) or header-based versioning\n6. **Document your API**: Generate OpenAPI/Swagger docs\n7. **Implement rate limiting**: Protect against abuse\n8. **Use pagination**: For list endpoints, always paginate results\n9. **Log requests**: Track all API calls for debugging and monitoring\n10. **Secure your API**: Use CORS, helmet, rate limiting, and input validation",
  "prompt": "A skill that provides comprehensive REST API design patterns with Express.js and FastAPI, including routing, middleware, validation, error handling, and production-ready best practices",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
