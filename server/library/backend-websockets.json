{
  "id": "backend-websockets",
  "name": "Real-time Communication with WebSockets",
  "description": "Implement real-time bidirectional communication using WebSockets, Socket.io, event handling, rooms, and namespaces",
  "category": "Backend",
  "content": "---\nname: Real-time Communication with WebSockets\ndescription: Implement real-time bidirectional communication using WebSockets, Socket.io, event handling, rooms, and namespaces\ncategory: Backend\n---\n\n# Real-time Communication with WebSockets\n\n## Overview\n\nThis skill provides comprehensive patterns for implementing real-time bidirectional communication in backend applications using native WebSockets and Socket.io. It covers connection management, event handling, rooms, namespaces, authentication, scaling strategies, and production-ready implementations.\n\n## Activation\n\nUse this skill when:\n- Building real-time chat applications\n- Implementing live notifications or updates\n- Creating collaborative editing tools\n- Developing real-time dashboards or monitoring systems\n- Building multiplayer games or interactive features\n- Implementing presence detection (online/offline status)\n- Creating live data feeds or streaming updates\n- User mentions \"websocket\", \"socket.io\", \"real-time\", or \"bidirectional communication\"\n\n## Instructions\n\n1. **Choose the Right Technology**\n   - Use native WebSockets for simple, lightweight implementations\n   - Use Socket.io for automatic fallbacks, rooms, and advanced features\n   - Consider server-sent events (SSE) for one-way server-to-client updates\n\n2. **Implement Connection Management**\n   - Handle connection lifecycle (connect, disconnect, reconnect)\n   - Implement authentication and authorization\n   - Track connected clients and manage state\n   - Handle errors and edge cases gracefully\n\n3. **Design Event Architecture**\n   - Use clear, descriptive event names\n   - Implement proper event validation and sanitization\n   - Handle acknowledgments for critical events\n   - Use namespaces to separate concerns\n\n4. **Use Rooms for Group Communication**\n   - Organize clients into logical groups\n   - Implement join/leave mechanics\n   - Broadcast to specific rooms\n   - Track room membership\n\n5. **Scale Horizontally**\n   - Use Redis adapter for multi-server deployments\n   - Implement sticky sessions if needed\n   - Consider message queues for reliability\n   - Monitor connection counts and performance\n\n6. **Security Best Practices**\n   - Always authenticate WebSocket connections\n   - Validate and sanitize all incoming messages\n   - Implement rate limiting per connection\n   - Use CORS and origin checks\n   - Encrypt sensitive data\n\n## Examples\n\n### Example 1: Basic Socket.io Server Setup\n\n```javascript\n// server.js - Complete Socket.io server with Express\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst cors = require('cors');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server, {\n  cors: {\n    origin: process.env.CLIENT_URL || 'http://localhost:3000',\n    methods: ['GET', 'POST'],\n    credentials: true\n  },\n  pingTimeout: 60000,\n  pingInterval: 25000,\n  transports: ['websocket', 'polling']\n});\n\napp.use(cors());\napp.use(express.json());\n\n// Middleware for authentication\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  \n  if (!token) {\n    return next(new Error('Authentication error'));\n  }\n  \n  try {\n    // Verify JWT token\n    const decoded = verifyToken(token);\n    socket.userId = decoded.userId;\n    socket.username = decoded.username;\n    next();\n  } catch (err) {\n    next(new Error('Invalid token'));\n  }\n});\n\n// Connection tracking\nconst activeUsers = new Map();\n\nio.on('connection', (socket) => {\n  console.log(`User connected: ${socket.username} (${socket.id})`);\n  \n  // Add user to active users\n  activeUsers.set(socket.userId, {\n    socketId: socket.id,\n    username: socket.username,\n    connectedAt: new Date()\n  });\n  \n  // Broadcast user list update\n  io.emit('users:online', Array.from(activeUsers.values()));\n  \n  // Handle custom events\n  socket.on('message:send', (data, callback) => {\n    try {\n      // Validate message\n      if (!data.content || data.content.length > 1000) {\n        return callback({ error: 'Invalid message' });\n      }\n      \n      const message = {\n        id: generateId(),\n        userId: socket.userId,\n        username: socket.username,\n        content: sanitize(data.content),\n        timestamp: new Date()\n      };\n      \n      // Broadcast to all clients\n      io.emit('message:new', message);\n      \n      // Acknowledge receipt\n      callback({ success: true, messageId: message.id });\n    } catch (err) {\n      callback({ error: 'Failed to send message' });\n    }\n  });\n  \n  socket.on('disconnect', (reason) => {\n    console.log(`User disconnected: ${socket.username} - ${reason}`);\n    activeUsers.delete(socket.userId);\n    io.emit('users:online', Array.from(activeUsers.values()));\n  });\n  \n  socket.on('error', (error) => {\n    console.error('Socket error:', error);\n  });\n});\n\nconst PORT = process.env.PORT || 3001;\nserver.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n\nfunction verifyToken(token) {\n  const jwt = require('jsonwebtoken');\n  return jwt.verify(token, process.env.JWT_SECRET);\n}\n\nfunction sanitize(text) {\n  return text.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nfunction generateId() {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\n}\n```\n\n### Example 2: Real-time Chat with Rooms\n\n```javascript\n// chat-server.js - Complete chat application with rooms\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\nconst Redis = require('ioredis');\nconst { createAdapter } = require('@socket.io/redis-adapter');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\n// Redis adapter for horizontal scaling\nconst pubClient = new Redis(process.env.REDIS_URL);\nconst subClient = pubClient.duplicate();\nio.adapter(createAdapter(pubClient, subClient));\n\n// Room management\nclass RoomManager {\n  constructor() {\n    this.rooms = new Map();\n  }\n  \n  createRoom(roomId, metadata = {}) {\n    this.rooms.set(roomId, {\n      id: roomId,\n      users: new Set(),\n      messages: [],\n      createdAt: new Date(),\n      ...metadata\n    });\n    return this.rooms.get(roomId);\n  }\n  \n  getRoom(roomId) {\n    return this.rooms.get(roomId);\n  }\n  \n  addUserToRoom(roomId, userId, userData) {\n    const room = this.getRoom(roomId);\n    if (room) {\n      room.users.add(userId);\n      return true;\n    }\n    return false;\n  }\n  \n  removeUserFromRoom(roomId, userId) {\n    const room = this.getRoom(roomId);\n    if (room) {\n      room.users.delete(userId);\n      if (room.users.size === 0) {\n        this.rooms.delete(roomId);\n      }\n      return true;\n    }\n    return false;\n  }\n  \n  addMessage(roomId, message) {\n    const room = this.getRoom(roomId);\n    if (room) {\n      room.messages.push(message);\n      // Keep only last 100 messages in memory\n      if (room.messages.length > 100) {\n        room.messages.shift();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nconst roomManager = new RoomManager();\n\nio.on('connection', (socket) => {\n  console.log('Client connected:', socket.id);\n  \n  // Join a room\n  socket.on('room:join', (data, callback) => {\n    const { roomId, username } = data;\n    \n    if (!roomId || !username) {\n      return callback({ error: 'Room ID and username required' });\n    }\n    \n    // Create room if it doesn't exist\n    if (!roomManager.getRoom(roomId)) {\n      roomManager.createRoom(roomId, { name: data.roomName || roomId });\n    }\n    \n    // Join the Socket.io room\n    socket.join(roomId);\n    \n    // Add user to room manager\n    roomManager.addUserToRoom(roomId, socket.id, { username });\n    \n    // Store user data on socket\n    socket.roomId = roomId;\n    socket.username = username;\n    \n    const room = roomManager.getRoom(roomId);\n    \n    // Send room history to the joining user\n    socket.emit('room:history', {\n      messages: room.messages,\n      users: Array.from(room.users).length\n    });\n    \n    // Notify others in the room\n    socket.to(roomId).emit('user:joined', {\n      userId: socket.id,\n      username,\n      timestamp: new Date()\n    });\n    \n    callback({ \n      success: true, \n      room: {\n        id: roomId,\n        userCount: room.users.size\n      }\n    });\n  });\n  \n  // Send message to room\n  socket.on('message:send', (data, callback) => {\n    const { content } = data;\n    const { roomId, username } = socket;\n    \n    if (!roomId) {\n      return callback({ error: 'Not in a room' });\n    }\n    \n    if (!content || content.trim().length === 0) {\n      return callback({ error: 'Message cannot be empty' });\n    }\n    \n    if (content.length > 2000) {\n      return callback({ error: 'Message too long' });\n    }\n    \n    const message = {\n      id: generateMessageId(),\n      userId: socket.id,\n      username,\n      content: content.trim(),\n      timestamp: new Date(),\n      roomId\n    };\n    \n    // Save message to room\n    roomManager.addMessage(roomId, message);\n    \n    // Broadcast to all users in the room (including sender)\n    io.to(roomId).emit('message:new', message);\n    \n    callback({ success: true, message });\n  });\n  \n  // Typing indicator\n  socket.on('typing:start', () => {\n    if (socket.roomId) {\n      socket.to(socket.roomId).emit('user:typing', {\n        userId: socket.id,\n        username: socket.username\n      });\n    }\n  });\n  \n  socket.on('typing:stop', () => {\n    if (socket.roomId) {\n      socket.to(socket.roomId).emit('user:stopped-typing', {\n        userId: socket.id\n      });\n    }\n  });\n  \n  // Leave room\n  socket.on('room:leave', (callback) => {\n    if (socket.roomId) {\n      leaveRoom(socket);\n      callback({ success: true });\n    }\n  });\n  \n  // Handle disconnect\n  socket.on('disconnect', () => {\n    console.log('Client disconnected:', socket.id);\n    if (socket.roomId) {\n      leaveRoom(socket);\n    }\n  });\n});\n\nfunction leaveRoom(socket) {\n  const { roomId, username } = socket;\n  \n  // Remove from Socket.io room\n  socket.leave(roomId);\n  \n  // Remove from room manager\n  roomManager.removeUserFromRoom(roomId, socket.id);\n  \n  // Notify others\n  socket.to(roomId).emit('user:left', {\n    userId: socket.id,\n    username,\n    timestamp: new Date()\n  });\n  \n  // Clear socket data\n  delete socket.roomId;\n  delete socket.username;\n}\n\nfunction generateMessageId() {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\nserver.listen(3001, () => {\n  console.log('Chat server running on port 3001');\n});\n```\n\n### Example 3: React Client Integration\n\n```javascript\n// hooks/useSocket.js - React hook for Socket.io\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { io } from 'socket.io-client';\n\nexport function useSocket(url, options = {}) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState(null);\n  const socketRef = useRef(null);\n  \n  useEffect(() => {\n    // Create socket connection\n    const socket = io(url, {\n      autoConnect: false,\n      reconnection: true,\n      reconnectionAttempts: 5,\n      reconnectionDelay: 1000,\n      ...options\n    });\n    \n    socketRef.current = socket;\n    \n    // Connection event handlers\n    socket.on('connect', () => {\n      console.log('Socket connected');\n      setIsConnected(true);\n      setError(null);\n    });\n    \n    socket.on('disconnect', (reason) => {\n      console.log('Socket disconnected:', reason);\n      setIsConnected(false);\n    });\n    \n    socket.on('connect_error', (err) => {\n      console.error('Connection error:', err);\n      setError(err.message);\n      setIsConnected(false);\n    });\n    \n    // Connect\n    socket.connect();\n    \n    // Cleanup\n    return () => {\n      socket.disconnect();\n    };\n  }, [url]);\n  \n  const emit = useCallback((event, data, callback) => {\n    if (socketRef.current) {\n      socketRef.current.emit(event, data, callback);\n    }\n  }, []);\n  \n  const on = useCallback((event, handler) => {\n    if (socketRef.current) {\n      socketRef.current.on(event, handler);\n      \n      // Return cleanup function\n      return () => {\n        socketRef.current?.off(event, handler);\n      };\n    }\n  }, []);\n  \n  const off = useCallback((event, handler) => {\n    if (socketRef.current) {\n      socketRef.current.off(event, handler);\n    }\n  }, []);\n  \n  return {\n    socket: socketRef.current,\n    isConnected,\n    error,\n    emit,\n    on,\n    off\n  };\n}\n\n// components/Chat.js - Chat component using the hook\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useSocket } from '../hooks/useSocket';\n\nexport function Chat({ roomId, username, token }) {\n  const [messages, setMessages] = useState([]);\n  const [inputValue, setInputValue] = useState('');\n  const [isTyping, setIsTyping] = useState(false);\n  const [typingUsers, setTypingUsers] = useState(new Set());\n  const messagesEndRef = useRef(null);\n  const typingTimeoutRef = useRef(null);\n  \n  const { isConnected, emit, on } = useSocket('http://localhost:3001', {\n    auth: { token }\n  });\n  \n  // Join room on mount\n  useEffect(() => {\n    if (!isConnected) return;\n    \n    emit('room:join', { roomId, username }, (response) => {\n      if (response.error) {\n        console.error('Failed to join room:', response.error);\n      }\n    });\n    \n    return () => {\n      emit('room:leave', () => {});\n    };\n  }, [isConnected, roomId, username, emit]);\n  \n  // Listen for messages\n  useEffect(() => {\n    if (!isConnected) return;\n    \n    const cleanupHandlers = [];\n    \n    // New message\n    cleanupHandlers.push(\n      on('message:new', (message) => {\n        setMessages(prev => [...prev, message]);\n      })\n    );\n    \n    // Room history\n    cleanupHandlers.push(\n      on('room:history', (data) => {\n        setMessages(data.messages);\n      })\n    );\n    \n    // User joined\n    cleanupHandlers.push(\n      on('user:joined', (data) => {\n        setMessages(prev => [...prev, {\n          id: `system-${Date.now()}`,\n          type: 'system',\n          content: `${data.username} joined the chat`,\n          timestamp: data.timestamp\n        }]);\n      })\n    );\n    \n    // User left\n    cleanupHandlers.push(\n      on('user:left', (data) => {\n        setMessages(prev => [...prev, {\n          id: `system-${Date.now()}`,\n          type: 'system',\n          content: `${data.username} left the chat`,\n          timestamp: data.timestamp\n        }]);\n      })\n    );\n    \n    // Typing indicators\n    cleanupHandlers.push(\n      on('user:typing', (data) => {\n        setTypingUsers(prev => new Set([...prev, data.username]));\n      })\n    );\n    \n    cleanupHandlers.push(\n      on('user:stopped-typing', (data) => {\n        setTypingUsers(prev => {\n          const next = new Set(prev);\n          next.delete(data.username);\n          return next;\n        });\n      })\n    );\n    \n    return () => {\n      cleanupHandlers.forEach(cleanup => cleanup?.());\n    };\n  }, [isConnected, on]);\n  \n  // Auto-scroll to bottom\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  const handleInputChange = (e) => {\n    setInputValue(e.target.value);\n    \n    // Send typing indicator\n    if (!isTyping) {\n      setIsTyping(true);\n      emit('typing:start');\n    }\n    \n    // Clear previous timeout\n    if (typingTimeoutRef.current) {\n      clearTimeout(typingTimeoutRef.current);\n    }\n    \n    // Stop typing after 1 second of inactivity\n    typingTimeoutRef.current = setTimeout(() => {\n      setIsTyping(false);\n      emit('typing:stop');\n    }, 1000);\n  };\n  \n  const handleSendMessage = (e) => {\n    e.preventDefault();\n    \n    if (!inputValue.trim()) return;\n    \n    emit('message:send', { content: inputValue }, (response) => {\n      if (response.error) {\n        console.error('Failed to send message:', response.error);\n      } else {\n        setInputValue('');\n        if (isTyping) {\n          setIsTyping(false);\n          emit('typing:stop');\n        }\n      }\n    });\n  };\n  \n  return (\n    <div className=\"chat-container\">\n      <div className=\"chat-header\">\n        <h2>Room: {roomId}</h2>\n        <span className={`status ${isConnected ? 'connected' : 'disconnected'}`}>\n          {isConnected ? 'Connected' : 'Disconnected'}\n        </span>\n      </div>\n      \n      <div className=\"messages\">\n        {messages.map((msg) => (\n          <div \n            key={msg.id} \n            className={`message ${msg.type === 'system' ? 'system' : ''} ${msg.username === username ? 'own' : ''}`}\n          >\n            {msg.type !== 'system' && (\n              <strong>{msg.username}: </strong>\n            )}\n            <span>{msg.content}</span>\n            <span className=\"timestamp\">\n              {new Date(msg.timestamp).toLocaleTimeString()}\n            </span>\n          </div>\n        ))}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {typingUsers.size > 0 && (\n        <div className=\"typing-indicator\">\n          {Array.from(typingUsers).join(', ')} {typingUsers.size === 1 ? 'is' : 'are'} typing...\n        </div>\n      )}\n      \n      <form onSubmit={handleSendMessage} className=\"message-input\">\n        <input\n          type=\"text\"\n          value={inputValue}\n          onChange={handleInputChange}\n          placeholder=\"Type a message...\"\n          disabled={!isConnected}\n        />\n        <button type=\"submit\" disabled={!isConnected || !inputValue.trim()}>\n          Send\n        </button>\n      </form>\n    </div>\n  );\n}\n```\n\n### Example 4: Native WebSocket Server\n\n```javascript\n// websocket-server.js - Native WebSocket implementation\nconst WebSocket = require('ws');\nconst http = require('http');\nconst url = require('url');\nconst jwt = require('jsonwebtoken');\n\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ noServer: true });\n\n// Connection store\nconst connections = new Map();\n\n// Heartbeat mechanism to detect dead connections\nfunction heartbeat() {\n  this.isAlive = true;\n}\n\nconst heartbeatInterval = setInterval(() => {\n  wss.clients.forEach((ws) => {\n    if (ws.isAlive === false) {\n      return ws.terminate();\n    }\n    \n    ws.isAlive = false;\n    ws.ping();\n  });\n}, 30000);\n\nwss.on('close', () => {\n  clearInterval(heartbeatInterval);\n});\n\n// Handle upgrade request\nserver.on('upgrade', (request, socket, head) => {\n  const pathname = url.parse(request.url).pathname;\n  \n  if (pathname === '/ws') {\n    // Authenticate\n    const token = url.parse(request.url, true).query.token;\n    \n    try {\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      request.user = decoded;\n      \n      wss.handleUpgrade(request, socket, head, (ws) => {\n        wss.emit('connection', ws, request);\n      });\n    } catch (err) {\n      socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n      socket.destroy();\n    }\n  } else {\n    socket.destroy();\n  }\n});\n\nwss.on('connection', (ws, request) => {\n  const user = request.user;\n  const connectionId = generateId();\n  \n  console.log(`Client connected: ${user.username} (${connectionId})`);\n  \n  // Setup connection\n  ws.isAlive = true;\n  ws.on('pong', heartbeat);\n  \n  // Store connection\n  connections.set(connectionId, {\n    ws,\n    user,\n    connectedAt: new Date(),\n    subscriptions: new Set()\n  });\n  \n  // Send welcome message\n  ws.send(JSON.stringify({\n    type: 'connected',\n    connectionId,\n    user: {\n      id: user.userId,\n      username: user.username\n    }\n  }));\n  \n  // Handle messages\n  ws.on('message', (data) => {\n    try {\n      const message = JSON.parse(data);\n      handleMessage(connectionId, message);\n    } catch (err) {\n      console.error('Invalid message format:', err);\n      ws.send(JSON.stringify({\n        type: 'error',\n        message: 'Invalid message format'\n      }));\n    }\n  });\n  \n  // Handle errors\n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n  \n  // Handle disconnect\n  ws.on('close', () => {\n    console.log(`Client disconnected: ${user.username}`);\n    connections.delete(connectionId);\n    \n    // Notify others\n    broadcast({\n      type: 'user:offline',\n      userId: user.userId,\n      username: user.username\n    }, connectionId);\n  });\n});\n\nfunction handleMessage(connectionId, message) {\n  const connection = connections.get(connectionId);\n  if (!connection) return;\n  \n  const { ws, user } = connection;\n  \n  switch (message.type) {\n    case 'subscribe':\n      connection.subscriptions.add(message.channel);\n      ws.send(JSON.stringify({\n        type: 'subscribed',\n        channel: message.channel\n      }));\n      break;\n      \n    case 'unsubscribe':\n      connection.subscriptions.delete(message.channel);\n      ws.send(JSON.stringify({\n        type: 'unsubscribed',\n        channel: message.channel\n      }));\n      break;\n      \n    case 'message':\n      // Broadcast message to all subscribers of the channel\n      broadcastToChannel(message.channel, {\n        type: 'message',\n        channel: message.channel,\n        user: {\n          id: user.userId,\n          username: user.username\n        },\n        content: message.content,\n        timestamp: new Date()\n      }, connectionId);\n      break;\n      \n    case 'ping':\n      ws.send(JSON.stringify({ type: 'pong' }));\n      break;\n      \n    default:\n      ws.send(JSON.stringify({\n        type: 'error',\n        message: 'Unknown message type'\n      }));\n  }\n}\n\nfunction broadcast(message, excludeConnectionId = null) {\n  const data = JSON.stringify(message);\n  \n  connections.forEach((connection, connectionId) => {\n    if (connectionId !== excludeConnectionId && connection.ws.readyState === WebSocket.OPEN) {\n      connection.ws.send(data);\n    }\n  });\n}\n\nfunction broadcastToChannel(channel, message, excludeConnectionId = null) {\n  const data = JSON.stringify(message);\n  \n  connections.forEach((connection, connectionId) => {\n    if (\n      connectionId !== excludeConnectionId &&\n      connection.subscriptions.has(channel) &&\n      connection.ws.readyState === WebSocket.OPEN\n    ) {\n      connection.ws.send(data);\n    }\n  });\n}\n\nfunction generateId() {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2);\n}\n\nconst PORT = process.env.PORT || 3001;\nserver.listen(PORT, () => {\n  console.log(`WebSocket server running on port ${PORT}`);\n});\n```\n\n### Example 5: Namespaces and Middleware\n\n```javascript\n// namespaced-server.js - Advanced Socket.io with namespaces\nconst { Server } = require('socket.io');\nconst rateLimit = require('express-rate-limit');\n\nconst io = new Server(3001, {\n  cors: { origin: '*' }\n});\n\n// Middleware for rate limiting\nconst createRateLimiter = (maxEvents = 10, windowMs = 1000) => {\n  const clients = new Map();\n  \n  return (socket, next) => {\n    const now = Date.now();\n    const clientData = clients.get(socket.id) || { count: 0, resetTime: now + windowMs };\n    \n    if (now > clientData.resetTime) {\n      clientData.count = 0;\n      clientData.resetTime = now + windowMs;\n    }\n    \n    clientData.count++;\n    clients.set(socket.id, clientData);\n    \n    if (clientData.count > maxEvents) {\n      return next(new Error('Rate limit exceeded'));\n    }\n    \n    next();\n  };\n};\n\n// Admin namespace\nconst adminNamespace = io.of('/admin');\n\nadminNamespace.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  \n  // Verify admin token\n  if (verifyAdminToken(token)) {\n    socket.isAdmin = true;\n    next();\n  } else {\n    next(new Error('Unauthorized'));\n  }\n});\n\nadminNamespace.on('connection', (socket) => {\n  console.log('Admin connected:', socket.id);\n  \n  // Send admin-only data\n  socket.emit('stats', getServerStats());\n  \n  socket.on('broadcast:all', (message) => {\n    // Broadcast to all namespaces\n    io.emit('admin:announcement', message);\n  });\n  \n  socket.on('kick:user', (userId) => {\n    // Find and disconnect user\n    const userSocket = findUserSocket(userId);\n    if (userSocket) {\n      userSocket.disconnect(true);\n    }\n  });\n});\n\n// Chat namespace\nconst chatNamespace = io.of('/chat');\n\nchatNamespace.use(createRateLimiter(20, 1000));\n\nchatNamespace.on('connection', (socket) => {\n  console.log('User connected to chat:', socket.id);\n  \n  socket.on('message', (data) => {\n    chatNamespace.emit('message', {\n      ...data,\n      socketId: socket.id,\n      timestamp: new Date()\n    });\n  });\n});\n\n// Notifications namespace\nconst notificationsNamespace = io.of('/notifications');\n\nnotificationsNamespace.on('connection', (socket) => {\n  const userId = socket.handshake.auth.userId;\n  \n  // Join user-specific room\n  socket.join(`user:${userId}`);\n  \n  // Send pending notifications\n  getPendingNotifications(userId).then(notifications => {\n    socket.emit('notifications:pending', notifications);\n  });\n});\n\n// Helper function to send notification to specific user\nfunction sendNotification(userId, notification) {\n  notificationsNamespace.to(`user:${userId}`).emit('notification', notification);\n}\n\nfunction verifyAdminToken(token) {\n  // Implement admin verification\n  return token === process.env.ADMIN_SECRET;\n}\n\nfunction getServerStats() {\n  return {\n    totalConnections: io.engine.clientsCount,\n    namespaces: {\n      admin: adminNamespace.sockets.size,\n      chat: chatNamespace.sockets.size,\n      notifications: notificationsNamespace.sockets.size\n    },\n    uptime: process.uptime()\n  };\n}\n\nfunction findUserSocket(userId) {\n  // Implementation to find socket by user ID\n  return null;\n}\n\nasync function getPendingNotifications(userId) {\n  // Implementation to fetch notifications\n  return [];\n}\n```",
  "prompt": "A skill that implements real-time bidirectional communication using WebSockets and Socket.io, covering connection management, event handling, rooms, namespaces, authentication, scaling strategies, and production-ready client/server implementations.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
