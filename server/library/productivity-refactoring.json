{
  "id": "productivity-refactoring",
  "name": "Code Refactoring & Clean Code",
  "description": "Refactoring patterns, clean code principles, and code quality improvement techniques",
  "category": "Productivity",
  "content": "---\nname: Code Refactoring & Clean Code\ndescription: Refactoring patterns, clean code principles, and code quality improvement techniques\ncategory: Productivity\n---\n\n# Code Refactoring & Clean Code\n\n## Overview\n\nThis skill provides comprehensive guidance on code refactoring techniques, clean code principles, and systematic approaches to improving code quality. It covers refactoring patterns, SOLID principles, code smells detection, and practical strategies for maintaining a healthy codebase.\n\n## Activation\n\nUse this skill when:\n- Refactoring legacy code\n- Improving code readability and maintainability\n- Reducing technical debt\n- Applying SOLID principles\n- Detecting and fixing code smells\n- Extracting reusable functions or components\n- Simplifying complex logic\n- Preparing code for new features\n\n## Instructions\n\n### Common Code Smells and Solutions\n\n#### 1. Long Functions\n\n```javascript\n// BEFORE: Long function doing too much\nfunction processOrder(order) {\n  // Validate order\n  if (!order.items || order.items.length === 0) {\n    throw new Error('Order must have items');\n  }\n  if (!order.customer || !order.customer.email) {\n    throw new Error('Customer email is required');\n  }\n  \n  // Calculate total\n  let total = 0;\n  for (const item of order.items) {\n    total += item.price * item.quantity;\n  }\n  \n  // Apply discount\n  if (order.couponCode) {\n    const coupon = getCoupon(order.couponCode);\n    if (coupon && coupon.isValid) {\n      total = total * (1 - coupon.discount);\n    }\n  }\n  \n  // Calculate tax\n  const taxRate = getTaxRate(order.customer.state);\n  const tax = total * taxRate;\n  total += tax;\n  \n  // Process payment\n  const payment = {\n    amount: total,\n    customerId: order.customer.id,\n    method: order.paymentMethod\n  };\n  const paymentResult = processPayment(payment);\n  \n  // Send confirmation\n  sendEmail(order.customer.email, {\n    subject: 'Order Confirmation',\n    total: total,\n    items: order.items\n  });\n  \n  return { orderId: paymentResult.orderId, total };\n}\n\n// AFTER: Refactored into smaller, focused functions\nfunction validateOrder(order) {\n  if (!order.items || order.items.length === 0) {\n    throw new Error('Order must have items');\n  }\n  if (!order.customer?.email) {\n    throw new Error('Customer email is required');\n  }\n}\n\nfunction calculateSubtotal(items) {\n  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n}\n\nfunction applyDiscount(subtotal, couponCode) {\n  if (!couponCode) return subtotal;\n  \n  const coupon = getCoupon(couponCode);\n  return coupon?.isValid ? subtotal * (1 - coupon.discount) : subtotal;\n}\n\nfunction calculateTax(amount, state) {\n  const taxRate = getTaxRate(state);\n  return amount * taxRate;\n}\n\nfunction calculateTotal(order) {\n  const subtotal = calculateSubtotal(order.items);\n  const discounted = applyDiscount(subtotal, order.couponCode);\n  const tax = calculateTax(discounted, order.customer.state);\n  return discounted + tax;\n}\n\nfunction createPayment(order, total) {\n  return {\n    amount: total,\n    customerId: order.customer.id,\n    method: order.paymentMethod\n  };\n}\n\nfunction sendOrderConfirmation(customer, items, total) {\n  return sendEmail(customer.email, {\n    subject: 'Order Confirmation',\n    total,\n    items\n  });\n}\n\nfunction processOrder(order) {\n  validateOrder(order);\n  \n  const total = calculateTotal(order);\n  const payment = createPayment(order, total);\n  const paymentResult = processPayment(payment);\n  \n  sendOrderConfirmation(order.customer, order.items, total);\n  \n  return { orderId: paymentResult.orderId, total };\n}\n```\n\n#### 2. Duplicate Code\n\n```javascript\n// BEFORE: Duplicated logic\nfunction getUserPosts(userId) {\n  const user = users.find(u => u.id === userId);\n  if (!user) {\n    throw new Error('User not found');\n  }\n  return db.query('SELECT * FROM posts WHERE user_id = ?', [userId]);\n}\n\nfunction getUserComments(userId) {\n  const user = users.find(u => u.id === userId);\n  if (!user) {\n    throw new Error('User not found');\n  }\n  return db.query('SELECT * FROM comments WHERE user_id = ?', [userId]);\n}\n\nfunction getUserLikes(userId) {\n  const user = users.find(u => u.id === userId);\n  if (!user) {\n    throw new Error('User not found');\n  }\n  return db.query('SELECT * FROM likes WHERE user_id = ?', [userId]);\n}\n\n// AFTER: Extract common logic\nfunction validateUserExists(userId) {\n  const user = users.find(u => u.id === userId);\n  if (!user) {\n    throw new Error('User not found');\n  }\n  return user;\n}\n\nfunction getUserData(userId, table) {\n  validateUserExists(userId);\n  return db.query(`SELECT * FROM ${table} WHERE user_id = ?`, [userId]);\n}\n\nconst getUserPosts = (userId) => getUserData(userId, 'posts');\nconst getUserComments = (userId) => getUserData(userId, 'comments');\nconst getUserLikes = (userId) => getUserData(userId, 'likes');\n```\n\n#### 3. Large Classes / God Objects\n\n```javascript\n// BEFORE: Class doing too much\nclass UserManager {\n  createUser(data) { /* ... */ }\n  updateUser(id, data) { /* ... */ }\n  deleteUser(id) { /* ... */ }\n  \n  authenticateUser(email, password) { /* ... */ }\n  generateToken(user) { /* ... */ }\n  validateToken(token) { /* ... */ }\n  \n  sendWelcomeEmail(user) { /* ... */ }\n  sendPasswordResetEmail(user) { /* ... */ }\n  \n  uploadAvatar(userId, file) { /* ... */ }\n  resizeImage(image) { /* ... */ }\n}\n\n// AFTER: Split into focused classes (Single Responsibility Principle)\nclass UserRepository {\n  create(data) { /* ... */ }\n  update(id, data) { /* ... */ }\n  delete(id) { /* ... */ }\n  findById(id) { /* ... */ }\n  findByEmail(email) { /* ... */ }\n}\n\nclass AuthService {\n  constructor(userRepository) {\n    this.userRepository = userRepository;\n  }\n  \n  authenticate(email, password) { /* ... */ }\n  generateToken(user) { /* ... */ }\n  validateToken(token) { /* ... */ }\n  refreshToken(token) { /* ... */ }\n}\n\nclass EmailService {\n  sendWelcome(user) { /* ... */ }\n  sendPasswordReset(user) { /* ... */ }\n  sendVerification(user) { /* ... */ }\n}\n\nclass ImageService {\n  upload(file) { /* ... */ }\n  resize(image, dimensions) { /* ... */ }\n  optimize(image) { /* ... */ }\n}\n\nclass UserService {\n  constructor(userRepository, authService, emailService, imageService) {\n    this.users = userRepository;\n    this.auth = authService;\n    this.email = emailService;\n    this.images = imageService;\n  }\n  \n  async register(data) {\n    const user = await this.users.create(data);\n    await this.email.sendWelcome(user);\n    return user;\n  }\n  \n  async updateAvatar(userId, file) {\n    const imageUrl = await this.images.upload(file);\n    return this.users.update(userId, { avatar: imageUrl });\n  }\n}\n```\n\n### SOLID Principles\n\n#### 1. Single Responsibility Principle\n\n```javascript\n// BEFORE: Multiple responsibilities\nclass Invoice {\n  constructor(items) {\n    this.items = items;\n  }\n  \n  calculateTotal() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n  \n  generatePDF() {\n    // PDF generation logic\n  }\n  \n  sendEmail(recipient) {\n    // Email sending logic\n  }\n  \n  saveToDatabase() {\n    // Database logic\n  }\n}\n\n// AFTER: Each class has one responsibility\nclass Invoice {\n  constructor(items) {\n    this.items = items;\n  }\n  \n  calculateTotal() {\n    return this.items.reduce((sum, item) => sum + item.price, 0);\n  }\n  \n  toJSON() {\n    return {\n      items: this.items,\n      total: this.calculateTotal(),\n      createdAt: new Date()\n    };\n  }\n}\n\nclass InvoicePDFGenerator {\n  generate(invoice) {\n    // PDF generation logic using invoice data\n  }\n}\n\nclass InvoiceEmailer {\n  constructor(emailService) {\n    this.emailService = emailService;\n  }\n  \n  send(invoice, recipient) {\n    const pdf = new InvoicePDFGenerator().generate(invoice);\n    return this.emailService.send(recipient, 'Invoice', pdf);\n  }\n}\n\nclass InvoiceRepository {\n  save(invoice) {\n    return db.insert('invoices', invoice.toJSON());\n  }\n  \n  findById(id) {\n    const data = db.findOne('invoices', { id });\n    return new Invoice(data.items);\n  }\n}\n```\n\n#### 2. Open/Closed Principle\n\n```javascript\n// BEFORE: Modifying class for each new payment method\nclass PaymentProcessor {\n  process(payment) {\n    if (payment.type === 'credit-card') {\n      // Process credit card\n    } else if (payment.type === 'paypal') {\n      // Process PayPal\n    } else if (payment.type === 'crypto') {\n      // Process cryptocurrency\n    }\n  }\n}\n\n// AFTER: Open for extension, closed for modification\nclass PaymentProcessor {\n  constructor() {\n    this.handlers = new Map();\n  }\n  \n  register(type, handler) {\n    this.handlers.set(type, handler);\n  }\n  \n  process(payment) {\n    const handler = this.handlers.get(payment.type);\n    if (!handler) {\n      throw new Error(`No handler for payment type: ${payment.type}`);\n    }\n    return handler.process(payment);\n  }\n}\n\nclass CreditCardHandler {\n  process(payment) {\n    // Credit card processing logic\n  }\n}\n\nclass PayPalHandler {\n  process(payment) {\n    // PayPal processing logic\n  }\n}\n\nclass CryptoHandler {\n  process(payment) {\n    // Cryptocurrency processing logic\n  }\n}\n\n// Usage\nconst processor = new PaymentProcessor();\nprocessor.register('credit-card', new CreditCardHandler());\nprocessor.register('paypal', new PayPalHandler());\nprocessor.register('crypto', new CryptoHandler());\n```\n\n#### 3. Dependency Inversion Principle\n\n```javascript\n// BEFORE: High-level module depends on low-level module\nclass UserService {\n  constructor() {\n    this.database = new MySQLDatabase(); // Direct dependency\n  }\n  \n  getUser(id) {\n    return this.database.query('SELECT * FROM users WHERE id = ?', [id]);\n  }\n}\n\n// AFTER: Both depend on abstraction\nclass UserService {\n  constructor(database) { // Inject dependency\n    this.database = database;\n  }\n  \n  getUser(id) {\n    return this.database.findOne('users', { id });\n  }\n}\n\n// Database interface/abstraction\nclass MySQLDatabase {\n  findOne(table, conditions) {\n    // MySQL implementation\n  }\n}\n\nclass MongoDatabase {\n  findOne(collection, conditions) {\n    // MongoDB implementation\n  }\n}\n\n// Usage - easy to swap implementations\nconst userService = new UserService(new MySQLDatabase());\n// or\nconst userService = new UserService(new MongoDatabase());\n```\n\n### Refactoring Patterns\n\n#### 1. Extract Method/Function\n\n```javascript\n// BEFORE: Complex conditional logic inline\nfunction getDiscountedPrice(product, customer) {\n  let price = product.price;\n  \n  if (customer.loyaltyPoints > 1000 && product.category === 'electronics') {\n    price = price * 0.85;\n  } else if (customer.isPremium && product.price > 100) {\n    price = price * 0.9;\n  } else if (customer.orders.length > 10) {\n    price = price * 0.95;\n  }\n  \n  return price;\n}\n\n// AFTER: Extract conditions into named functions\nfunction isEligibleForElectronicsDiscount(product, customer) {\n  return customer.loyaltyPoints > 1000 && product.category === 'electronics';\n}\n\nfunction isEligibleForPremiumDiscount(product, customer) {\n  return customer.isPremium && product.price > 100;\n}\n\nfunction isEligibleForLoyaltyDiscount(customer) {\n  return customer.orders.length > 10;\n}\n\nfunction getDiscountedPrice(product, customer) {\n  let price = product.price;\n  \n  if (isEligibleForElectronicsDiscount(product, customer)) {\n    price *= 0.85;\n  } else if (isEligibleForPremiumDiscount(product, customer)) {\n    price *= 0.9;\n  } else if (isEligibleForLoyaltyDiscount(customer)) {\n    price *= 0.95;\n  }\n  \n  return price;\n}\n```\n\n#### 2. Replace Conditional with Polymorphism\n\n```javascript\n// BEFORE: Type checking with conditionals\nclass Bird {\n  constructor(type) {\n    this.type = type;\n  }\n  \n  fly() {\n    if (this.type === 'penguin') {\n      return 'Cannot fly';\n    } else if (this.type === 'eagle') {\n      return 'Soaring high';\n    } else if (this.type === 'sparrow') {\n      return 'Flying low';\n    }\n  }\n}\n\n// AFTER: Use polymorphism\nclass Bird {\n  fly() {\n    throw new Error('Subclass must implement fly()');\n  }\n}\n\nclass Penguin extends Bird {\n  fly() {\n    return 'Cannot fly';\n  }\n}\n\nclass Eagle extends Bird {\n  fly() {\n    return 'Soaring high';\n  }\n}\n\nclass Sparrow extends Bird {\n  fly() {\n    return 'Flying low';\n  }\n}\n```\n\n#### 3. Replace Magic Numbers with Named Constants\n\n```javascript\n// BEFORE: Magic numbers\nfunction calculateShipping(weight, distance) {\n  let cost = weight * 0.5;\n  \n  if (distance > 100) {\n    cost += distance * 0.1;\n  }\n  \n  if (cost < 5) {\n    cost = 5;\n  }\n  \n  if (weight > 50) {\n    cost *= 1.2;\n  }\n  \n  return cost;\n}\n\n// AFTER: Named constants\nconst SHIPPING_CONFIG = {\n  BASE_RATE_PER_KG: 0.5,\n  LONG_DISTANCE_THRESHOLD: 100,\n  LONG_DISTANCE_RATE: 0.1,\n  MINIMUM_COST: 5,\n  HEAVY_WEIGHT_THRESHOLD: 50,\n  HEAVY_WEIGHT_MULTIPLIER: 1.2\n};\n\nfunction calculateShipping(weight, distance) {\n  let cost = weight * SHIPPING_CONFIG.BASE_RATE_PER_KG;\n  \n  if (distance > SHIPPING_CONFIG.LONG_DISTANCE_THRESHOLD) {\n    cost += distance * SHIPPING_CONFIG.LONG_DISTANCE_RATE;\n  }\n  \n  if (cost < SHIPPING_CONFIG.MINIMUM_COST) {\n    cost = SHIPPING_CONFIG.MINIMUM_COST;\n  }\n  \n  if (weight > SHIPPING_CONFIG.HEAVY_WEIGHT_THRESHOLD) {\n    cost *= SHIPPING_CONFIG.HEAVY_WEIGHT_MULTIPLIER;\n  }\n  \n  return cost;\n}\n```\n\n#### 4. Introduce Parameter Object\n\n```javascript\n// BEFORE: Too many parameters\nfunction createUser(\n  firstName,\n  lastName,\n  email,\n  phone,\n  address,\n  city,\n  state,\n  zipCode,\n  country\n) {\n  // Implementation\n}\n\n// AFTER: Group related parameters\nclass UserData {\n  constructor({ firstName, lastName, email, phone, address }) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.email = email;\n    this.phone = phone;\n    this.address = address;\n  }\n}\n\nclass Address {\n  constructor({ street, city, state, zipCode, country }) {\n    this.street = street;\n    this.city = city;\n    this.state = state;\n    this.zipCode = zipCode;\n    this.country = country;\n  }\n}\n\nfunction createUser(userData) {\n  // Implementation with userData.firstName, userData.email, etc.\n}\n\n// Usage\nconst user = createUser(\n  new UserData({\n    firstName: 'John',\n    lastName: 'Doe',\n    email: 'john@example.com',\n    phone: '555-1234',\n    address: new Address({\n      street: '123 Main St',\n      city: 'New York',\n      state: 'NY',\n      zipCode: '10001',\n      country: 'USA'\n    })\n  })\n);\n```\n\n### Clean Code Practices\n\n#### 1. Meaningful Names\n\n```javascript\n// BEFORE: Unclear names\nconst d = 86400;\nfunction calc(a, b) {\n  return a * b * d;\n}\nconst temp = getData();\n\n// AFTER: Descriptive names\nconst SECONDS_PER_DAY = 86400;\nfunction calculateDailyCost(pricePerUnit, quantity) {\n  return pricePerUnit * quantity * SECONDS_PER_DAY;\n}\nconst userProfile = getUserProfile();\n```\n\n#### 2. Small Functions\n\n```javascript\n// BEFORE: Function doing multiple things\nfunction handleFormSubmit(formData) {\n  // Validate\n  const errors = [];\n  if (!formData.email) errors.push('Email required');\n  if (!formData.password) errors.push('Password required');\n  if (errors.length > 0) return { success: false, errors };\n  \n  // Transform\n  const userData = {\n    email: formData.email.toLowerCase(),\n    password: hashPassword(formData.password),\n    createdAt: new Date()\n  };\n  \n  // Save\n  const user = db.insert('users', userData);\n  \n  // Send email\n  sendWelcomeEmail(user.email);\n  \n  // Return\n  return { success: true, user };\n}\n\n// AFTER: Each function does one thing\nfunction validateFormData(formData) {\n  const errors = [];\n  if (!formData.email) errors.push('Email required');\n  if (!formData.password) errors.push('Password required');\n  return errors;\n}\n\nfunction transformFormData(formData) {\n  return {\n    email: formData.email.toLowerCase(),\n    password: hashPassword(formData.password),\n    createdAt: new Date()\n  };\n}\n\nfunction createUser(userData) {\n  return db.insert('users', userData);\n}\n\nfunction handleFormSubmit(formData) {\n  const errors = validateFormData(formData);\n  if (errors.length > 0) {\n    return { success: false, errors };\n  }\n  \n  const userData = transformFormData(formData);\n  const user = createUser(userData);\n  \n  sendWelcomeEmail(user.email);\n  \n  return { success: true, user };\n}\n```\n\n#### 3. Error Handling\n\n```javascript\n// BEFORE: Inconsistent error handling\nfunction getUser(id) {\n  try {\n    const user = db.findOne('users', { id });\n    if (!user) return null;\n    return user;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\n// AFTER: Consistent, predictable error handling\nclass UserNotFoundError extends Error {\n  constructor(id) {\n    super(`User with id ${id} not found`);\n    this.name = 'UserNotFoundError';\n    this.userId = id;\n  }\n}\n\nfunction getUser(id) {\n  const user = db.findOne('users', { id });\n  \n  if (!user) {\n    throw new UserNotFoundError(id);\n  }\n  \n  return user;\n}\n\n// Caller handles errors appropriately\ntry {\n  const user = getUser(123);\n  // Use user\n} catch (error) {\n  if (error instanceof UserNotFoundError) {\n    // Handle not found case\n  } else {\n    // Handle other errors\n  }\n}\n```\n\n## Examples\n\n### Example 1: Refactoring React Component\n\n```javascript\n// BEFORE: Large component with multiple responsibilities\nimport React, { useState, useEffect } from 'react';\n\nfunction UserDashboard() {\n  const [user, setUser] = useState(null);\n  const [posts, setPosts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    async function fetchData() {\n      try {\n        const userResponse = await fetch('/api/user');\n        const userData = await userResponse.json();\n        setUser(userData);\n        \n        const postsResponse = await fetch(`/api/users/${userData.id}/posts`);\n        const postsData = await postsResponse.json();\n        setPosts(postsData);\n        \n        setLoading(false);\n      } catch (err) {\n        setError(err.message);\n        setLoading(false);\n      }\n    }\n    fetchData();\n  }, []);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <div>\n      <div className=\"user-header\">\n        <img src={user.avatar} alt={user.name} />\n        <h1>{user.name}</h1>\n        <p>{user.email}</p>\n      </div>\n      <div className=\"posts\">\n        <h2>Recent Posts</h2>\n        {posts.map(post => (\n          <div key={post.id} className=\"post\">\n            <h3>{post.title}</h3>\n            <p>{post.content}</p>\n            <span>{new Date(post.createdAt).toLocaleDateString()}</span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// AFTER: Refactored into smaller, focused components and hooks\n\n// Custom hooks\nfunction useUser() {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    async function fetchUser() {\n      try {\n        const response = await fetch('/api/user');\n        const data = await response.json();\n        setUser(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n    fetchUser();\n  }, []);\n  \n  return { user, loading, error };\n}\n\nfunction useUserPosts(userId) {\n  const [posts, setPosts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    if (!userId) return;\n    \n    async function fetchPosts() {\n      try {\n        const response = await fetch(`/api/users/${userId}/posts`);\n        const data = await response.json();\n        setPosts(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n    fetchPosts();\n  }, [userId]);\n  \n  return { posts, loading, error };\n}\n\n// Separate components\nfunction UserHeader({ user }) {\n  return (\n    <div className=\"user-header\">\n      <img src={user.avatar} alt={user.name} />\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\nfunction PostCard({ post }) {\n  const formattedDate = new Date(post.createdAt).toLocaleDateString();\n  \n  return (\n    <div className=\"post\">\n      <h3>{post.title}</h3>\n      <p>{post.content}</p>\n      <span>{formattedDate}</span>\n    </div>\n  );\n}\n\nfunction PostList({ posts }) {\n  return (\n    <div className=\"posts\">\n      <h2>Recent Posts</h2>\n      {posts.map(post => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n\nfunction LoadingState() {\n  return <div>Loading...</div>;\n}\n\nfunction ErrorState({ message }) {\n  return <div>Error: {message}</div>;\n}\n\n// Main component - simplified and focused\nfunction UserDashboard() {\n  const { user, loading: userLoading, error: userError } = useUser();\n  const { posts, loading: postsLoading, error: postsError } = useUserPosts(user?.id);\n  \n  if (userLoading || postsLoading) return <LoadingState />;\n  if (userError) return <ErrorState message={userError} />;\n  if (postsError) return <ErrorState message={postsError} />;\n  \n  return (\n    <div>\n      <UserHeader user={user} />\n      <PostList posts={posts} />\n    </div>\n  );\n}\n```\n\n### Example 2: Refactoring Express Route Handler\n\n```javascript\n// BEFORE: Fat route handler\napp.post('/api/users', async (req, res) => {\n  try {\n    // Validation\n    if (!req.body.email || !req.body.password) {\n      return res.status(400).json({ error: 'Email and password required' });\n    }\n    \n    if (req.body.password.length < 8) {\n      return res.status(400).json({ error: 'Password must be at least 8 characters' });\n    }\n    \n    // Check if user exists\n    const existing = await db.query(\n      'SELECT * FROM users WHERE email = ?',\n      [req.body.email]\n    );\n    if (existing.length > 0) {\n      return res.status(409).json({ error: 'User already exists' });\n    }\n    \n    // Hash password\n    const hashedPassword = await bcrypt.hash(req.body.password, 10);\n    \n    // Create user\n    const result = await db.query(\n      'INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n      [req.body.email, hashedPassword, req.body.name]\n    );\n    \n    // Send welcome email\n    await sendEmail({\n      to: req.body.email,\n      subject: 'Welcome!',\n      body: `Welcome ${req.body.name}!`\n    });\n    \n    res.status(201).json({ id: result.insertId, email: req.body.email });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// AFTER: Layered architecture with separation of concerns\n\n// validators/user.validator.js\nconst Joi = require('joi');\n\nconst createUserSchema = Joi.object({\n  email: Joi.string().email().required(),\n  password: Joi.string().min(8).required(),\n  name: Joi.string().required()\n});\n\nfunction validateCreateUser(data) {\n  const { error, value } = createUserSchema.validate(data);\n  if (error) {\n    throw new ValidationError(error.details[0].message);\n  }\n  return value;\n}\n\n// repositories/user.repository.js\nclass UserRepository {\n  async findByEmail(email) {\n    const [user] = await db.query(\n      'SELECT * FROM users WHERE email = ?',\n      [email]\n    );\n    return user;\n  }\n  \n  async create(userData) {\n    const result = await db.query(\n      'INSERT INTO users (email, password, name) VALUES (?, ?, ?)',\n      [userData.email, userData.password, userData.name]\n    );\n    return { id: result.insertId, ...userData };\n  }\n}\n\n// services/user.service.js\nclass UserService {\n  constructor(userRepository, emailService, passwordService) {\n    this.users = userRepository;\n    this.email = emailService;\n    this.password = passwordService;\n  }\n  \n  async createUser(userData) {\n    // Check if exists\n    const existing = await this.users.findByEmail(userData.email);\n    if (existing) {\n      throw new ConflictError('User already exists');\n    }\n    \n    // Hash password\n    const hashedPassword = await this.password.hash(userData.password);\n    \n    // Create user\n    const user = await this.users.create({\n      ...userData,\n      password: hashedPassword\n    });\n    \n    // Send welcome email\n    await this.email.sendWelcome(user);\n    \n    return user;\n  }\n}\n\n// controllers/user.controller.js\nclass UserController {\n  constructor(userService) {\n    this.userService = userService;\n  }\n  \n  async createUser(req, res, next) {\n    try {\n      const validatedData = validateCreateUser(req.body);\n      const user = await this.userService.createUser(validatedData);\n      \n      res.status(201).json({\n        id: user.id,\n        email: user.email\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\n// routes/user.routes.js\nconst express = require('express');\nconst router = express.Router();\n\nconst userController = new UserController(userService);\n\nrouter.post('/users', (req, res, next) => \n  userController.createUser(req, res, next)\n);\n\nmodule.exports = router;\n```\n\nThese examples demonstrate systematic refactoring techniques for improving code quality, maintainability, and testability.",
  "prompt": "A skill that provides comprehensive guidance on code refactoring techniques, clean code principles, SOLID principles, code smell detection, and systematic approaches to improving code quality and maintainability.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
