{
  "id": "frontend-typescript",
  "name": "frontend-typescript",
  "description": "Advanced TypeScript patterns for React including generics, utility types, strict typing, type guards, and best practices for type-safe React applications",
  "category": "Frontend",
  "content": "---\nname: frontend-typescript\ndescription: Advanced TypeScript patterns for React including generics, utility types, strict typing, type guards, and best practices for type-safe React applications\ncategory: Frontend\n---\n\n# TypeScript Patterns for React\n\n## Overview\n\nThis skill provides comprehensive TypeScript patterns and best practices for React applications. It covers advanced typing techniques, generic components, utility types, type guards, discriminated unions, and strategies for building fully type-safe React applications with excellent developer experience.\n\n## Activation\n\nUse this skill when:\n- Setting up TypeScript in a React project\n- Typing React components, hooks, and props\n- Creating reusable generic components\n- Working with complex type inference\n- Implementing type-safe APIs and state management\n- Using advanced TypeScript features (generics, conditional types, mapped types)\n- Migrating JavaScript React code to TypeScript\n- Improving type safety and developer experience\n\n## Instructions\n\n### TypeScript Configuration for React\n\n1. **Use strict mode**: Enable strict type checking in tsconfig.json\n2. **Type everything**: Props, state, events, and return values\n3. **Avoid `any`**: Use `unknown` or proper types instead\n4. **Use utility types**: Leverage TypeScript's built-in utilities\n5. **Generic components**: Create reusable, type-safe components\n\n### Best Practices\n\n1. Define interfaces for all component props\n2. Use discriminated unions for complex state\n3. Leverage type inference where possible\n4. Create custom utility types for common patterns\n5. Use const assertions for literal types\n6. Type all event handlers properly\n\n## Examples\n\n### Example 1: Component Props Typing\n\n```typescript\n// Basic props typing\nimport React from 'react';\n\n// Simple interface\ninterface ButtonProps {\n  text: string;\n  onClick: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary' | 'danger';\n}\n\nexport const Button: React.FC<ButtonProps> = ({ \n  text, \n  onClick, \n  disabled = false,\n  variant = 'primary' \n}) => {\n  return (\n    <button \n      onClick={onClick} \n      disabled={disabled}\n      className={`btn btn-${variant}`}\n    >\n      {text}\n    </button>\n  );\n};\n\n// Extending HTML attributes\ninterface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  label: string;\n  error?: string;\n}\n\nexport const Input: React.FC<InputProps> = ({ \n  label, \n  error, \n  ...inputProps \n}) => {\n  return (\n    <div className=\"input-group\">\n      <label>{label}</label>\n      <input {...inputProps} />\n      {error && <span className=\"error\">{error}</span>}\n    </div>\n  );\n};\n\n// Children typing options\ninterface ContainerProps {\n  children: React.ReactNode; // Most flexible - any valid React child\n}\n\ninterface StrictContainerProps {\n  children: React.ReactElement; // Single React element only\n}\n\ninterface MultipleChildrenProps {\n  children: React.ReactElement[]; // Array of React elements\n}\n\ninterface FunctionChildrenProps {\n  children: (data: string) => React.ReactNode; // Render prop pattern\n}\n\n// Discriminated union for props\ntype ButtonBaseProps = {\n  text: string;\n  disabled?: boolean;\n};\n\ntype LinkButton = ButtonBaseProps & {\n  variant: 'link';\n  href: string;\n  target?: string;\n};\n\ntype NormalButton = ButtonBaseProps & {\n  variant: 'primary' | 'secondary';\n  onClick: () => void;\n};\n\ntype SmartButtonProps = LinkButton | NormalButton;\n\nexport const SmartButton: React.FC<SmartButtonProps> = (props) => {\n  if (props.variant === 'link') {\n    return (\n      <a href={props.href} target={props.target}>\n        {props.text}\n      </a>\n    );\n  }\n\n  return (\n    <button onClick={props.onClick} disabled={props.disabled}>\n      {props.text}\n    </button>\n  );\n};\n```\n\n### Example 2: Generic Components\n\n```typescript\n// Generic List Component\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T, index: number) => React.ReactNode;\n  keyExtractor: (item: T, index: number) => string | number;\n  emptyMessage?: string;\n  loading?: boolean;\n}\n\nexport const List = <T,>({\n  items,\n  renderItem,\n  keyExtractor,\n  emptyMessage = 'No items found',\n  loading = false\n}: ListProps<T>): React.ReactElement => {\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (items.length === 0) {\n    return <div>{emptyMessage}</div>;\n  }\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={keyExtractor(item, index)}>\n          {renderItem(item, index)}\n        </li>\n      ))}\n    </ul>\n  );\n};\n\n// Usage with type inference\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserList = ({ users }: { users: User[] }) => {\n  return (\n    <List\n      items={users}\n      keyExtractor={(user) => user.id}\n      renderItem={(user) => (\n        <div>\n          <strong>{user.name}</strong>\n          <span>{user.email}</span>\n        </div>\n      )}\n    />\n  );\n};\n\n// Generic Table Component with constraints\ninterface Column<T> {\n  key: keyof T;\n  header: string;\n  render?: (value: T[keyof T], item: T) => React.ReactNode;\n  sortable?: boolean;\n}\n\ninterface TableProps<T extends Record<string, any>> {\n  data: T[];\n  columns: Column<T>[];\n  onRowClick?: (item: T) => void;\n}\n\nexport const Table = <T extends Record<string, any>>({\n  data,\n  columns,\n  onRowClick\n}: TableProps<T>): React.ReactElement => {\n  return (\n    <table>\n      <thead>\n        <tr>\n          {columns.map((col) => (\n            <th key={String(col.key)}>{col.header}</th>\n          ))}\n        </tr>\n      </thead>\n      <tbody>\n        {data.map((item, index) => (\n          <tr\n            key={index}\n            onClick={() => onRowClick?.(item)}\n            style={{ cursor: onRowClick ? 'pointer' : 'default' }}\n          >\n            {columns.map((col) => (\n              <td key={String(col.key)}>\n                {col.render \n                  ? col.render(item[col.key], item)\n                  : String(item[col.key])\n                }\n              </td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};\n\n// Usage\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  inStock: boolean;\n}\n\nconst ProductTable = ({ products }: { products: Product[] }) => {\n  return (\n    <Table\n      data={products}\n      columns={[\n        { key: 'name', header: 'Product Name' },\n        { \n          key: 'price', \n          header: 'Price',\n          render: (price) => `$${price.toFixed(2)}`\n        },\n        { \n          key: 'inStock', \n          header: 'Status',\n          render: (inStock) => inStock ? 'In Stock' : 'Out of Stock'\n        }\n      ]}\n      onRowClick={(product) => console.log('Clicked:', product.name)}\n    />\n  );\n};\n```\n\n### Example 3: Event Handlers and Forms\n\n```typescript\n// Properly typed event handlers\nimport React, { useState, ChangeEvent, FormEvent, MouseEvent } from 'react';\n\ninterface FormData {\n  username: string;\n  email: string;\n  age: number;\n  terms: boolean;\n}\n\nexport const RegistrationForm: React.FC = () => {\n  const [formData, setFormData] = useState<FormData>({\n    username: '',\n    email: '',\n    age: 0,\n    terms: false\n  });\n\n  // Input change handler\n  const handleInputChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const { name, value, type, checked } = e.target;\n    \n    setFormData(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  };\n\n  // Select change handler\n  const handleSelectChange = (e: ChangeEvent<HTMLSelectElement>) => {\n    setFormData(prev => ({ ...prev, [e.target.name]: e.target.value }));\n  };\n\n  // Form submit handler\n  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    console.log('Form submitted:', formData);\n  };\n\n  // Button click handler with specific element type\n  const handleButtonClick = (e: MouseEvent<HTMLButtonElement>) => {\n    e.preventDefault();\n    console.log('Button clicked');\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"username\"\n        value={formData.username}\n        onChange={handleInputChange}\n      />\n      <input\n        name=\"email\"\n        type=\"email\"\n        value={formData.email}\n        onChange={handleInputChange}\n      />\n      <input\n        name=\"age\"\n        type=\"number\"\n        value={formData.age}\n        onChange={handleInputChange}\n      />\n      <label>\n        <input\n          name=\"terms\"\n          type=\"checkbox\"\n          checked={formData.terms}\n          onChange={handleInputChange}\n        />\n        Accept Terms\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n\n// Reusable typed event handler factory\ntype InputChangeHandler = (e: ChangeEvent<HTMLInputElement>) => void;\ntype SelectChangeHandler = (e: ChangeEvent<HTMLSelectElement>) => void;\n\nconst createChangeHandler = <T extends Record<string, any>>(\n  setState: React.Dispatch<React.SetStateAction<T>>\n): InputChangeHandler => {\n  return (e: ChangeEvent<HTMLInputElement>) => {\n    const { name, value, type, checked } = e.target;\n    setState(prev => ({\n      ...prev,\n      [name]: type === 'checkbox' ? checked : type === 'number' ? Number(value) : value\n    }));\n  };\n};\n```\n\n### Example 4: Custom Hooks with TypeScript\n\n```typescript\n// Generic state hook with type inference\nimport { useState, useCallback } from 'react';\n\ntype SetState<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseStateWithHistoryReturn<T> {\n  state: T;\n  setState: SetState<T>;\n  history: T[];\n  goBack: () => void;\n  goForward: () => void;\n  canGoBack: boolean;\n  canGoForward: boolean;\n}\n\nexport const useStateWithHistory = <T>(\n  initialState: T\n): UseStateWithHistoryReturn<T> => {\n  const [state, setState] = useState<T>(initialState);\n  const [history, setHistory] = useState<T[]>([initialState]);\n  const [currentIndex, setCurrentIndex] = useState(0);\n\n  const goBack = useCallback(() => {\n    if (currentIndex > 0) {\n      const newIndex = currentIndex - 1;\n      setCurrentIndex(newIndex);\n      setState(history[newIndex]);\n    }\n  }, [currentIndex, history]);\n\n  const goForward = useCallback(() => {\n    if (currentIndex < history.length - 1) {\n      const newIndex = currentIndex + 1;\n      setCurrentIndex(newIndex);\n      setState(history[newIndex]);\n    }\n  }, [currentIndex, history]);\n\n  const customSetState: SetState<T> = useCallback((value) => {\n    const newState = value instanceof Function ? value(state) : value;\n    const newHistory = history.slice(0, currentIndex + 1);\n    newHistory.push(newState);\n    setHistory(newHistory);\n    setCurrentIndex(newHistory.length - 1);\n    setState(newState);\n  }, [currentIndex, history, state]);\n\n  return {\n    state,\n    setState: customSetState,\n    history,\n    goBack,\n    goForward,\n    canGoBack: currentIndex > 0,\n    canGoForward: currentIndex < history.length - 1\n  };\n};\n\n// Typed async hook\ninterface AsyncState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype AsyncFunction<T, Args extends any[]> = (...args: Args) => Promise<T>;\n\ninterface UseAsyncReturn<T, Args extends any[]> extends AsyncState<T> {\n  execute: (...args: Args) => Promise<void>;\n  reset: () => void;\n}\n\nexport const useAsync = <T, Args extends any[] = []>(\n  asyncFunction: AsyncFunction<T, Args>,\n  immediate = false,\n  ...initialArgs: Args\n): UseAsyncReturn<T, Args> => {\n  const [state, setState] = useState<AsyncState<T>>({\n    data: null,\n    loading: immediate,\n    error: null\n  });\n\n  const execute = useCallback(\n    async (...args: Args) => {\n      setState({ data: null, loading: true, error: null });\n      try {\n        const data = await asyncFunction(...args);\n        setState({ data, loading: false, error: null });\n      } catch (error) {\n        setState({ data: null, loading: false, error: error as Error });\n      }\n    },\n    [asyncFunction]\n  );\n\n  const reset = useCallback(() => {\n    setState({ data: null, loading: false, error: null });\n  }, []);\n\n  React.useEffect(() => {\n    if (immediate) {\n      execute(...initialArgs);\n    }\n  }, []);\n\n  return { ...state, execute, reset };\n};\n\n// Usage with full type inference\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst fetchUser = async (id: number): Promise<User> => {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n};\n\nconst UserComponent = ({ userId }: { userId: number }) => {\n  const { data, loading, error, execute } = useAsync(fetchUser, true, userId);\n\n  // TypeScript knows:\n  // - data is User | null\n  // - execute expects a number argument\n  // - error is Error | null\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data) return null;\n\n  return <div>{data.name}</div>;\n};\n```\n\n### Example 5: Utility Types for React\n\n```typescript\n// Extract prop types from a component\nimport React from 'react';\n\nconst MyComponent = (props: { name: string; age: number }) => {\n  return <div>{props.name}</div>;\n};\n\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n// Result: { name: string; age: number }\n\n// Make all props optional\ntype PartialComponentProps = Partial<MyComponentProps>;\n\n// Make specific props required\ntype RequiredNameProps = Required<Pick<MyComponentProps, 'name'>> & \n  Partial<Omit<MyComponentProps, 'name'>>;\n\n// Extract return type of a function\nconst fetchData = async (): Promise<{ id: number; name: string }> => {\n  return { id: 1, name: 'Test' };\n};\n\ntype FetchDataReturn = Awaited<ReturnType<typeof fetchData>>;\n// Result: { id: number; name: string }\n\n// Custom utility types for React\ntype PropsWithChildren<P = unknown> = P & { children?: React.ReactNode };\n\ntype ElementType<T> = T extends (infer E)[] ? E : never;\ntype ArrayElement = ElementType<string[]>; // string\n\n// Deep partial type\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\ninterface Config {\n  api: {\n    url: string;\n    timeout: number;\n  };\n  features: {\n    auth: boolean;\n    analytics: boolean;\n  };\n}\n\ntype PartialConfig = DeepPartial<Config>;\n// All nested properties are optional\n\n// Type-safe object keys\nconst getObjectKeys = <T extends Record<string, any>>(obj: T): (keyof T)[] => {\n  return Object.keys(obj) as (keyof T)[];\n};\n\n// Discriminated unions helper\ntype Action =\n  | { type: 'SET_USER'; payload: { id: number; name: string } }\n  | { type: 'CLEAR_USER' }\n  | { type: 'SET_LOADING'; payload: boolean };\n\ntype ActionType = Action['type'];\ntype ActionPayload<T extends ActionType> = Extract<Action, { type: T }> extends { payload: infer P }\n  ? P\n  : never;\n\n// Usage\ntype SetUserPayload = ActionPayload<'SET_USER'>; // { id: number; name: string }\ntype ClearUserPayload = ActionPayload<'CLEAR_USER'>; // never\n\n// Props with discriminated variant\ntype BaseProps = {\n  className?: string;\n};\n\ntype VariantProps<T extends string> = BaseProps & {\n  variant: T;\n};\n\ntype ButtonVariantProps = \n  | (VariantProps<'primary'> & { primary: true })\n  | (VariantProps<'secondary'> & { secondary?: boolean })\n  | (VariantProps<'danger'> & { danger: true });\n```\n\n### Example 6: Context API with TypeScript\n\n```typescript\n// Type-safe Context\nimport React, { createContext, useContext, useState, ReactNode } from 'react';\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\ninterface AuthContextValue {\n  user: User | null;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  isAuthenticated: boolean;\n  isAdmin: boolean;\n}\n\nconst AuthContext = createContext<AuthContextValue | undefined>(undefined);\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n\n  const login = async (email: string, password: string) => {\n    // API call\n    const response = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password })\n    });\n    const userData = await response.json();\n    setUser(userData);\n  };\n\n  const logout = () => {\n    setUser(null);\n  };\n\n  const value: AuthContextValue = {\n    user,\n    login,\n    logout,\n    isAuthenticated: !!user,\n    isAdmin: user?.role === 'admin'\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n};\n\n// Custom hook with type safety\nexport const useAuth = (): AuthContextValue => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n};\n\n// Generic context factory\nconst createContextFactory = <T extends Record<string, any>>() => {\n  const Context = createContext<T | undefined>(undefined);\n\n  const Provider = ({ children, value }: { children: ReactNode; value: T }) => {\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  const useContextHook = (): T => {\n    const context = useContext(Context);\n    if (context === undefined) {\n      throw new Error('Context must be used within Provider');\n    }\n    return context;\n  };\n\n  return { Provider, useContext: useContextHook };\n};\n\n// Usage\ninterface ThemeContextValue {\n  theme: 'light' | 'dark';\n  toggleTheme: () => void;\n}\n\nconst { Provider: ThemeProvider, useContext: useTheme } = \n  createContextFactory<ThemeContextValue>();\n```\n\n### Example 7: Advanced Type Patterns\n\n```typescript\n// Conditional types for component props\ntype ConditionalProps<T extends boolean> = T extends true\n  ? { value: string; onChange: (value: string) => void }\n  : { value?: never; onChange?: never };\n\ninterface ControlledInputProps<T extends boolean = boolean> {\n  controlled: T;\n  defaultValue?: string;\n}\n\ntype InputProps<T extends boolean> = ControlledInputProps<T> & ConditionalProps<T>;\n\n// This enforces that if controlled=true, value and onChange are required\nconst Input = <T extends boolean>(props: InputProps<T>) => {\n  return <input />;\n};\n\n// Usage\n<Input controlled={true} value=\"test\" onChange={(v) => {}} /> // ✓ Valid\n<Input controlled={false} /> // ✓ Valid\n// <Input controlled={true} /> // ✗ Error: value and onChange required\n\n// Mapped types for form state\ntype FormState<T> = {\n  [K in keyof T]: {\n    value: T[K];\n    error?: string;\n    touched: boolean;\n  };\n};\n\ninterface LoginForm {\n  email: string;\n  password: string;\n}\n\ntype LoginFormState = FormState<LoginForm>;\n// Result:\n// {\n//   email: { value: string; error?: string; touched: boolean };\n//   password: { value: string; error?: string; touched: boolean };\n// }\n\n// Type guard functions\nconst isUser = (value: unknown): value is User => {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'name' in value &&\n    'email' in value\n  );\n};\n\n// Assertion functions\nfunction assertIsUser(value: unknown): asserts value is User {\n  if (!isUser(value)) {\n    throw new Error('Value is not a User');\n  }\n}\n\n// Usage\nconst data: unknown = await fetchData();\nassertIsUser(data);\n// TypeScript now knows data is User\nconsole.log(data.name);\n\n// Template literal types\ntype EventName = 'click' | 'focus' | 'blur';\ntype EventHandler = `on${Capitalize<EventName>}`;\n// Result: 'onClick' | 'onFocus' | 'onBlur'\n\ntype PropEventHandler<T extends string> = `on${Capitalize<T>}` extends keyof React.DOMAttributes<any>\n  ? React.DOMAttributes<any>[`on${Capitalize<T>}`]\n  : never;\n\n// Recursive types\ninterface NestedNavItem {\n  label: string;\n  href?: string;\n  children?: NestedNavItem[];\n}\n\nconst NavItem: React.FC<{ item: NestedNavItem }> = ({ item }) => {\n  return (\n    <li>\n      {item.href ? <a href={item.href}>{item.label}</a> : <span>{item.label}</span>}\n      {item.children && (\n        <ul>\n          {item.children.map((child, i) => (\n            <NavItem key={i} item={child} />\n          ))}\n        </ul>\n      )}\n    </li>\n  );\n};\n```\n\n### Example 8: TypeScript Configuration\n\n```json\n// tsconfig.json - Strict React configuration\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"jsx\": \"react-jsx\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"allowJs\": false,\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noImplicitReturns\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"isolatedModules\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"baseUrl\": \"./src\",\n    \"paths\": {\n      \"@components/*\": [\"components/*\"],\n      \"@hooks/*\": [\"hooks/*\"],\n      \"@utils/*\": [\"utils/*\"],\n      \"@types/*\": [\"types/*\"]\n    }\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## TypeScript Best Practices for React\n\n### Component Typing Checklist\n- [ ] Define explicit prop interfaces\n- [ ] Type all event handlers\n- [ ] Use discriminated unions for complex props\n- [ ] Extend HTML attributes when appropriate\n- [ ] Type children correctly based on requirements\n- [ ] Use generics for reusable components\n\n### Hook Typing Checklist\n- [ ] Type all custom hooks with proper generics\n- [ ] Provide explicit return types\n- [ ] Type hook dependencies correctly\n- [ ] Use proper callback typing with useCallback\n- [ ] Type refs with correct element types\n\n### Advanced TypeScript Checklist\n- [ ] Use utility types to reduce duplication\n- [ ] Create type guards for runtime checks\n- [ ] Use const assertions for literal types\n- [ ] Leverage template literal types\n- [ ] Use conditional types for complex logic\n- [ ] Implement proper error types\n\n## Common Patterns Summary\n\n```typescript\n// 1. Props with children\ninterface Props {\n  children: React.ReactNode;\n}\n\n// 2. Optional callback prop\ninterface Props {\n  onClick?: (id: string) => void;\n}\n\n// 3. Generic component\ninterface Props<T> {\n  data: T[];\n  render: (item: T) => React.ReactNode;\n}\n\n// 4. Extending HTML props\ninterface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant: 'primary' | 'secondary';\n}\n\n// 5. Discriminated union\ntype Props = \n  | { type: 'text'; value: string }\n  | { type: 'number'; value: number };\n\n// 6. Component with ref\nconst Component = React.forwardRef<HTMLDivElement, Props>((props, ref) => {\n  return <div ref={ref} />;\n});\n\n// 7. Context with custom hook\nconst useMyContext = (): ContextValue => {\n  const context = useContext(MyContext);\n  if (!context) throw new Error('Used outside provider');\n  return context;\n};\n```\n\nThis skill provides comprehensive TypeScript patterns for building type-safe React applications.",
  "prompt": "A skill that provides advanced TypeScript patterns and best practices for React applications, including generic components, utility types, type guards, discriminated unions, proper event typing, custom hooks, and strategies for building fully type-safe React applications with excellent developer experience.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}
