{
  "id": "project-tech-specs",
  "name": "Technical Specifications",
  "description": "Create comprehensive technical specifications, design documents, RFCs, and architectural decision records (ADRs) with detailed implementation plans, API contracts, and system requirements",
  "category": "Project",
  "content": "---\nname: Technical Specifications\ndescription: Create comprehensive technical specifications, design documents, RFCs, and architectural decision records (ADRs) with detailed implementation plans, API contracts, and system requirements\ncategory: Project\n---\n\n# Technical Specifications\n\n## Overview\n\nThis skill guides the creation of professional technical specifications, design documents, RFCs (Request for Comments), and ADRs (Architectural Decision Records). It ensures thorough planning before implementation and serves as documentation for future reference.\n\n## Activation\n\nThis skill activates when you need to:\n- Write a technical specification for a new feature\n- Create an RFC for architectural changes\n- Document an architectural decision (ADR)\n- Design API contracts and interfaces\n- Plan system architecture and integration\n- Document technical requirements\n- Create implementation plans\n\n## Instructions\n\nWhen activated, this skill will:\n\n1. **Define Scope and Goals**\n   - Identify problem being solved\n   - Define success criteria\n   - List non-goals and out-of-scope items\n   - Specify stakeholders\n\n2. **Describe Solution**\n   - High-level architecture\n   - Component interactions\n   - Data models and schemas\n   - API contracts\n   - Technology choices with rationale\n\n3. **Detail Implementation**\n   - Step-by-step implementation plan\n   - Database migrations\n   - Deployment strategy\n   - Rollback procedures\n   - Testing strategy\n\n4. **Assess Risks and Alternatives**\n   - Identify risks and mitigations\n   - Consider alternative approaches\n   - Trade-off analysis\n   - Security and compliance considerations\n\n5. **Plan Execution**\n   - Timeline and milestones\n   - Resource requirements\n   - Dependencies\n   - Success metrics\n\n## Templates\n\n### Technical Specification Template\n\n```markdown\n# Technical Specification: [Feature Name]\n\n**Author**: [Name]\n**Date**: [Date]\n**Status**: [Draft | Review | Approved | Implemented]\n**Reviewers**: [Names]\n**Epic/Story**: [EPIC-123]\n\n## Executive Summary\n\n[2-3 paragraph overview of what's being built and why]\n\n## Background\n\n### Problem Statement\n[Describe the problem this solves]\n\n### Current State\n[Describe how things work today]\n\n### Desired State\n[Describe how things should work]\n\n### Success Metrics\n- [Metric 1]: [Target value]\n- [Metric 2]: [Target value]\n- [Metric 3]: [Target value]\n\n## Goals and Non-Goals\n\n### Goals\n- [ ] [Goal 1]\n- [ ] [Goal 2]\n- [ ] [Goal 3]\n\n### Non-Goals\n- [ ] [Explicitly out of scope item 1]\n- [ ] [Explicitly out of scope item 2]\n\n## Proposed Solution\n\n### Architecture Overview\n\n```\n[High-level architecture diagram or description]\n```\n\n### Components\n\n#### Component 1: [Name]\n**Responsibility**: [What this component does]\n**Technology**: [Tech stack]\n**Interfaces**: [APIs it exposes]\n**Dependencies**: [What it depends on]\n\n#### Component 2: [Name]\n[Repeat structure]\n\n### Data Model\n\n```sql\n-- Database schema changes\nCREATE TABLE example (\n  id SERIAL PRIMARY KEY,\n  field1 VARCHAR(255) NOT NULL,\n  field2 JSONB,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n### API Contracts\n\n#### Endpoint: POST /api/v1/resource\n\n**Request**:\n```json\n{\n  \"field1\": \"string\",\n  \"field2\": {\n    \"nested\": \"object\"\n  }\n}\n```\n\n**Response (200 OK)**:\n```json\n{\n  \"id\": \"uuid\",\n  \"field1\": \"string\",\n  \"field2\": {\n    \"nested\": \"object\"\n  },\n  \"createdAt\": \"2024-01-15T10:00:00Z\"\n}\n```\n\n**Error Responses**:\n- `400 Bad Request`: Invalid input\n- `401 Unauthorized`: Missing or invalid auth token\n- `429 Too Many Requests`: Rate limit exceeded\n\n### Sequence Diagrams\n\n```mermaid\nsequenceDiagram\n    Client->>+API: POST /resource\n    API->>+Database: INSERT INTO resources\n    Database-->>-API: Resource created\n    API->>+Queue: Publish event\n    Queue-->>-API: Acknowledged\n    API-->>-Client: 201 Created\n    Queue->>+Worker: Process event\n    Worker->>+External API: Notify\n    External API-->>-Worker: Success\n```\n\n### Technology Choices\n\n| Decision | Choice | Rationale |\n|----------|--------|----------|\n| Database | PostgreSQL | ACID compliance, JSON support |\n| Message Queue | RabbitMQ | Reliable delivery, dead letter queues |\n| Cache | Redis | Fast, supports complex data types |\n| Language | TypeScript | Type safety, team familiarity |\n\n## Detailed Design\n\n### Implementation Plan\n\n**Phase 1: Foundation (Sprint 1)**\n1. Database migration\n2. Create data models\n3. Implement repository layer\n4. Unit tests\n\n**Phase 2: API Layer (Sprint 1-2)**\n1. API endpoints\n2. Request validation\n3. Error handling\n4. Integration tests\n\n**Phase 3: Business Logic (Sprint 2)**\n1. Service layer implementation\n2. Event publishing\n3. Background workers\n4. E2E tests\n\n**Phase 4: Integration & Polish (Sprint 3)**\n1. Frontend integration\n2. Performance optimization\n3. Monitoring and alerts\n4. Documentation\n\n### Database Migrations\n\n```sql\n-- Migration 001: Create resources table\n-- Up\nCREATE TABLE resources (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(255) NOT NULL,\n  status VARCHAR(50) NOT NULL DEFAULT 'active',\n  metadata JSONB,\n  created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_resources_status ON resources(status);\nCREATE INDEX idx_resources_created_at ON resources(created_at);\n\n-- Down\nDROP INDEX IF EXISTS idx_resources_created_at;\nDROP INDEX IF EXISTS idx_resources_status;\nDROP TABLE IF EXISTS resources;\n```\n\n### Error Handling Strategy\n\n- **Validation Errors**: Return 400 with detailed field errors\n- **Business Logic Errors**: Return 422 with error codes\n- **Transient Errors**: Retry with exponential backoff (max 3 retries)\n- **Fatal Errors**: Log, alert, return 500\n\n### Security Considerations\n\n- [ ] All endpoints require authentication\n- [ ] Input validation and sanitization\n- [ ] Rate limiting (100 requests/minute per user)\n- [ ] SQL injection prevention (parameterized queries)\n- [ ] XSS prevention (output encoding)\n- [ ] CORS configuration\n- [ ] Audit logging for sensitive operations\n\n### Performance Requirements\n\n- API response time: p95 < 200ms\n- Database query time: p95 < 50ms\n- Throughput: 1000 requests/second\n- Cache hit ratio: > 80%\n\n### Monitoring and Observability\n\n**Metrics**:\n- Request count by endpoint and status code\n- Response time percentiles (p50, p95, p99)\n- Error rate\n- Database connection pool usage\n- Queue depth\n\n**Alerts**:\n- Error rate > 5% for 5 minutes\n- p95 response time > 500ms for 5 minutes\n- Queue depth > 1000 messages\n\n**Dashboards**:\n- Real-time request metrics\n- Database performance\n- System health overview\n\n## Deployment Strategy\n\n### Rollout Plan\n\n1. **Phase 1 - Internal Testing (Week 1)**\n   - Deploy to staging\n   - Internal team testing\n   - Performance testing\n\n2. **Phase 2 - Beta Release (Week 2)**\n   - Feature flag enabled for 5% of users\n   - Monitor metrics closely\n   - Gather feedback\n\n3. **Phase 3 - Gradual Rollout (Week 3-4)**\n   - Increase to 25%, 50%, 100%\n   - Monitor at each stage\n   - Rollback if issues detected\n\n4. **Phase 4 - Full Release (Week 5)**\n   - Remove feature flag\n   - Announce to all users\n   - Update documentation\n\n### Rollback Procedure\n\n1. Disable feature flag (takes effect immediately)\n2. Revert database migration if necessary\n3. Redeploy previous version\n4. Communicate with stakeholders\n5. Post-mortem to understand what went wrong\n\n## Testing Strategy\n\n### Unit Tests\n- All service layer methods\n- Repository layer with in-memory database\n- Validation logic\n- Target: >80% code coverage\n\n### Integration Tests\n- API endpoints with test database\n- Database queries\n- External API interactions (mocked)\n- Target: All critical paths covered\n\n### E2E Tests\n- Complete user workflows\n- Error scenarios\n- Edge cases\n- Target: Top 5 user journeys\n\n### Performance Tests\n- Load testing with expected traffic\n- Stress testing at 2x expected traffic\n- Soak testing for 24 hours\n\n## Risks and Mitigations\n\n| Risk | Probability | Impact | Mitigation |\n|------|------------|--------|------------|\n| External API rate limits | Medium | High | Implement caching, queue requests |\n| Database performance | Low | High | Index optimization, query tuning |\n| Feature complexity underestimated | Medium | Medium | Phased rollout, regular check-ins |\n| Team member availability | Low | Medium | Knowledge sharing, documentation |\n\n## Alternative Approaches Considered\n\n### Alternative 1: [Approach Name]\n**Pros**:\n- [Pro 1]\n- [Pro 2]\n\n**Cons**:\n- [Con 1]\n- [Con 2]\n\n**Why not chosen**: [Reason]\n\n### Alternative 2: [Approach Name]\n[Repeat structure]\n\n## Dependencies\n\n- **Team Dependencies**: Design team for UI mockups\n- **Technical Dependencies**: OAuth service upgrade to v2\n- **External Dependencies**: Third-party API access\n\n## Timeline and Milestones\n\n| Milestone | Date | Owner |\n|-----------|------|-------|\n| Spec approved | 2024-01-20 | PM |\n| Development complete | 2024-02-15 | Engineering |\n| Testing complete | 2024-02-20 | QA |\n| Beta launch | 2024-02-25 | Product |\n| Full launch | 2024-03-05 | Product |\n\n## Open Questions\n\n- [ ] Question 1? (Owner: Name, Due: Date)\n- [ ] Question 2? (Owner: Name, Due: Date)\n\n## Appendix\n\n### References\n- [Related documentation]\n- [API documentation]\n- [Research materials]\n\n### Glossary\n- **Term 1**: Definition\n- **Term 2**: Definition\n```\n\n### RFC (Request for Comments) Template\n\n```markdown\n# RFC: [Title]\n\n**RFC Number**: RFC-001\n**Author**: [Name]\n**Status**: [Proposed | Discussing | Accepted | Rejected | Implemented]\n**Created**: [Date]\n**Last Updated**: [Date]\n\n## Summary\n\n[One paragraph summary of the proposal]\n\n## Motivation\n\n### Why are we doing this?\n[Explain the problem and why it's important to solve]\n\n### What use cases does it support?\n[List specific use cases this enables]\n\n### What is the expected outcome?\n[Describe the desired end state]\n\n## Detailed Design\n\n### Proposed Changes\n\n[Detailed description of what will change]\n\n### API Changes\n\n#### Before\n```typescript\n// Current API\nfunction oldFunction(param: string): Result {\n  // ...\n}\n```\n\n#### After\n```typescript\n// Proposed API\nfunction newFunction(param: string, options?: Options): Promise<Result> {\n  // ...\n}\n```\n\n### Migration Path\n\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n\n**Backward Compatibility**: [Yes/No and explanation]\n\n**Breaking Changes**: [List any breaking changes]\n\n### Code Examples\n\n```typescript\n// Example of how developers will use the new API\nconst result = await newFunction('value', {\n  option1: true,\n  option2: 'custom'\n});\n```\n\n## Drawbacks\n\n- [Potential drawback 1]\n- [Potential drawback 2]\n\n## Alternatives\n\n### Alternative 1: [Name]\n[Description, pros, cons]\n\n### Alternative 2: [Name]\n[Description, pros, cons]\n\n## Prior Art\n\n[How do other projects/languages solve this problem?]\n\n## Unresolved Questions\n\n- [ ] Question 1?\n- [ ] Question 2?\n\n## Future Possibilities\n\n[What future work does this enable?]\n\n## Implementation Timeline\n\n- Week 1-2: [Milestone]\n- Week 3-4: [Milestone]\n- Week 5: [Milestone]\n\n## Stakeholders\n\n- **Author**: [Name]\n- **Reviewers**: [Names]\n- **Decision Makers**: [Names]\n- **Implementers**: [Names]\n\n## Comments and Discussion\n\n[Space for team members to add comments during review]\n```\n\n### ADR (Architectural Decision Record) Template\n\n```markdown\n# ADR-[Number]: [Title]\n\n**Date**: [Date]\n**Status**: [Proposed | Accepted | Deprecated | Superseded]\n**Deciders**: [Names]\n**Technical Story**: [Link to ticket/epic]\n\n## Context and Problem Statement\n\n[Describe the context and problem statement, including any constraints]\n\n## Decision Drivers\n\n- [Driver 1: e.g., must support 10k concurrent users]\n- [Driver 2: e.g., team familiarity with technology]\n- [Driver 3: e.g., cost constraints]\n- [Driver 4: e.g., time to market]\n\n## Considered Options\n\n- [Option 1]\n- [Option 2]\n- [Option 3]\n\n## Decision Outcome\n\nChosen option: \"[Option]\", because [justification].\n\n### Positive Consequences\n\n- [Good consequence 1]\n- [Good consequence 2]\n\n### Negative Consequences\n\n- [Bad consequence 1]\n- [Bad consequence 2]\n\n## Pros and Cons of the Options\n\n### [Option 1]\n\n**Description**: [Brief description]\n\n**Pros**:\n- [Pro 1]\n- [Pro 2]\n\n**Cons**:\n- [Con 1]\n- [Con 2]\n\n### [Option 2]\n\n[Repeat structure]\n\n### [Option 3]\n\n[Repeat structure]\n\n## Links\n\n- [Related ADRs]\n- [External references]\n- [Implementation PR]\n```\n\n## Examples\n\n### Example 1: Tech Spec for Payment Processing\n\n```markdown\n# Technical Specification: Stripe Payment Integration\n\n**Author**: Alice Chen\n**Date**: 2024-01-15\n**Status**: Approved\n**Reviewers**: Bob (Backend Lead), Carol (Security), Dan (Product)\n**Epic**: EPIC-456 - Payment Processing\n\n## Executive Summary\n\nWe're integrating Stripe as our primary payment processor to enable customers to purchase subscriptions and one-time products. This will replace our current manual invoice process and enable self-service upgrades. The implementation includes webhook handling for payment events, subscription management, and invoice generation.\n\n## Background\n\n### Problem Statement\nCustomers currently must contact sales to upgrade their plans or purchase add-ons. This creates friction in the conversion funnel and increases operational overhead for the sales team. We need a self-service payment solution.\n\n### Current State\n- Manual invoice generation via accounting software\n- Sales team processes all upgrades\n- Average 2-3 day delay from purchase decision to activation\n- 30% drop-off in conversion funnel at payment stage\n\n### Desired State\n- Instant subscription activation\n- Self-service plan upgrades and downgrades\n- Automated invoice generation and delivery\n- Support for multiple payment methods (cards, ACH)\n- Automated dunning for failed payments\n\n### Success Metrics\n- Reduce time-to-activation from 2-3 days to <5 minutes\n- Increase conversion rate by 20%\n- Reduce sales team involvement by 80%\n- Payment success rate >95%\n- Support 1000+ transactions/month\n\n## Goals and Non-Goals\n\n### Goals\n- [ ] Accept credit card payments via Stripe\n- [ ] Support monthly and annual subscriptions\n- [ ] Handle subscription upgrades and downgrades\n- [ ] Process webhooks for payment events\n- [ ] Generate and email invoices\n- [ ] Display billing history to customers\n- [ ] Handle failed payments with retry logic\n\n### Non-Goals\n- [ ] Cryptocurrency payments (future consideration)\n- [ ] PayPal integration (Phase 2)\n- [ ] Physical goods/shipping (SaaS only)\n- [ ] Multi-currency support (USD only for now)\n- [ ] Tax calculation (using Stripe Tax later)\n\n## Proposed Solution\n\n### Architecture Overview\n\n```\n┌─────────────┐\n│   Frontend  │\n│   (React)   │\n└──────┬──────┘\n       │\n       │ HTTPS\n       ▼\n┌─────────────────────┐\n│   API Gateway       │\n│   /api/v1/billing/* │\n└─────────┬───────────┘\n          │\n          ▼\n┌────────────────────────┐\n│  Billing Service       │\n│  (Node.js/Express)     │\n└───┬────────────────┬───┘\n    │                │\n    │                │ Webhooks\n    │                ▼\n    │         ┌─────────────┐\n    │         │   Stripe    │\n    │         │     API     │\n    │         └─────────────┘\n    │\n    ▼\n┌──────────────┐\n│  PostgreSQL  │\n│  (Billing DB)│\n└──────────────┘\n```\n\n### Components\n\n#### Component 1: Billing Service (Backend)\n**Responsibility**: Handle all payment-related operations\n**Technology**: Node.js, Express, TypeScript, Stripe SDK\n**Interfaces**: \n- REST API for client requests\n- Webhook endpoint for Stripe events\n**Dependencies**: \n- PostgreSQL for billing data\n- User service for customer information\n- Email service for invoice delivery\n\n#### Component 2: Stripe Integration\n**Responsibility**: Communicate with Stripe API\n**Technology**: Stripe Node.js SDK v11\n**Interfaces**: Stripe REST API and webhooks\n**Dependencies**: Stripe account, API keys\n\n#### Component 3: Frontend Checkout\n**Responsibility**: Payment UI and checkout flow\n**Technology**: React, Stripe Elements\n**Interfaces**: Billing Service API\n**Dependencies**: Billing Service endpoints\n\n### Data Model\n\n```sql\n-- Subscriptions table\nCREATE TABLE subscriptions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES users(id),\n  stripe_subscription_id VARCHAR(255) UNIQUE NOT NULL,\n  stripe_customer_id VARCHAR(255) NOT NULL,\n  plan_id VARCHAR(100) NOT NULL, -- 'starter', 'pro', 'enterprise'\n  status VARCHAR(50) NOT NULL, -- 'active', 'canceled', 'past_due', 'trialing'\n  current_period_start TIMESTAMP NOT NULL,\n  current_period_end TIMESTAMP NOT NULL,\n  cancel_at_period_end BOOLEAN DEFAULT false,\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);\nCREATE INDEX idx_subscriptions_stripe_customer_id ON subscriptions(stripe_customer_id);\n\n-- Invoices table\nCREATE TABLE invoices (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  subscription_id UUID REFERENCES subscriptions(id),\n  stripe_invoice_id VARCHAR(255) UNIQUE NOT NULL,\n  amount_due INTEGER NOT NULL, -- cents\n  amount_paid INTEGER NOT NULL, -- cents\n  currency VARCHAR(3) DEFAULT 'usd',\n  status VARCHAR(50) NOT NULL, -- 'draft', 'open', 'paid', 'void', 'uncollectible'\n  invoice_pdf VARCHAR(500), -- URL to PDF\n  hosted_invoice_url VARCHAR(500),\n  due_date TIMESTAMP,\n  paid_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_invoices_subscription_id ON invoices(subscription_id);\nCREATE INDEX idx_invoices_status ON invoices(status);\n\n-- Payment methods table\nCREATE TABLE payment_methods (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES users(id),\n  stripe_payment_method_id VARCHAR(255) UNIQUE NOT NULL,\n  type VARCHAR(50) NOT NULL, -- 'card', 'bank_account'\n  card_brand VARCHAR(50), -- 'visa', 'mastercard', etc.\n  card_last4 VARCHAR(4),\n  card_exp_month INTEGER,\n  card_exp_year INTEGER,\n  is_default BOOLEAN DEFAULT false,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_payment_methods_user_id ON payment_methods(user_id);\n```\n\n### API Contracts\n\n#### Endpoint: POST /api/v1/billing/subscriptions\n\n**Description**: Create a new subscription\n\n**Request**:\n```json\n{\n  \"planId\": \"pro\",\n  \"paymentMethodId\": \"pm_1234567890\",\n  \"billingInterval\": \"month\" // or \"year\"\n}\n```\n\n**Response (201 Created)**:\n```json\n{\n  \"subscription\": {\n    \"id\": \"sub_abc123\",\n    \"planId\": \"pro\",\n    \"status\": \"active\",\n    \"currentPeriodStart\": \"2024-01-15T10:00:00Z\",\n    \"currentPeriodEnd\": \"2024-02-15T10:00:00Z\",\n    \"cancelAtPeriodEnd\": false\n  },\n  \"invoice\": {\n    \"id\": \"inv_xyz789\",\n    \"amountDue\": 2900,\n    \"amountPaid\": 2900,\n    \"currency\": \"usd\",\n    \"status\": \"paid\",\n    \"invoicePdf\": \"https://stripe.com/invoices/...\"\n  }\n}\n```\n\n**Error Responses**:\n- `400 Bad Request`: Invalid plan ID or payment method\n- `402 Payment Required`: Payment method declined\n- `409 Conflict`: User already has active subscription\n\n#### Endpoint: POST /api/v1/billing/subscriptions/:id/upgrade\n\n**Description**: Upgrade/downgrade subscription plan\n\n**Request**:\n```json\n{\n  \"newPlanId\": \"enterprise\",\n  \"prorationBehavior\": \"create_prorations\" // or \"none\"\n}\n```\n\n**Response (200 OK)**:\n```json\n{\n  \"subscription\": {\n    \"id\": \"sub_abc123\",\n    \"planId\": \"enterprise\",\n    \"status\": \"active\",\n    \"currentPeriodStart\": \"2024-01-15T10:00:00Z\",\n    \"currentPeriodEnd\": \"2024-02-15T10:00:00Z\"\n  },\n  \"proratedAmount\": 3500 // Additional charge for upgrade\n}\n```\n\n#### Endpoint: POST /api/v1/billing/webhooks/stripe\n\n**Description**: Handle Stripe webhook events\n\n**Headers**:\n- `Stripe-Signature`: Webhook signature for verification\n\n**Request Body**: Stripe event object\n\n**Processed Events**:\n- `invoice.paid`: Mark invoice as paid, activate subscription\n- `invoice.payment_failed`: Mark invoice as failed, send dunning email\n- `customer.subscription.updated`: Update subscription status\n- `customer.subscription.deleted`: Cancel subscription\n\n### Sequence Diagram: Subscription Creation\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Frontend\n    participant API\n    participant Billing Service\n    participant Stripe\n    participant Database\n    participant Email Service\n\n    User->>Frontend: Select plan & enter payment\n    Frontend->>Stripe: Create payment method\n    Stripe-->>Frontend: Payment method ID\n    Frontend->>+API: POST /billing/subscriptions\n    API->>+Billing Service: Create subscription\n    Billing Service->>+Stripe: Create customer\n    Stripe-->>-Billing Service: Customer ID\n    Billing Service->>+Stripe: Create subscription\n    Stripe-->>-Billing Service: Subscription + Invoice\n    Billing Service->>+Database: Save subscription\n    Database-->>-Billing Service: Saved\n    Billing Service->>+Email Service: Send invoice email\n    Email Service-->>-Billing Service: Queued\n    Billing Service-->>-API: Subscription created\n    API-->>-Frontend: 201 Created\n    Frontend-->>User: Success! Subscription active\n    \n    Note over Stripe,Billing Service: Async webhook\n    Stripe->>Billing Service: webhook: invoice.paid\n    Billing Service->>Database: Update invoice status\n    Billing Service->>Email Service: Send welcome email\n```\n\n### Technology Choices\n\n| Decision | Choice | Rationale |\n|----------|--------|----------|\n| Payment Processor | Stripe | Industry leader, excellent API/docs, supports our use cases |\n| Payment UI | Stripe Elements | PCI compliance handled by Stripe, customizable |\n| Backend Language | TypeScript | Type safety for complex payment logic, team familiarity |\n| Database | PostgreSQL | ACID compliance critical for financial data |\n| Webhook Queue | Bull (Redis) | Reliable job processing, retries, dead letter queue |\n\n## Detailed Design\n\n### Implementation Plan\n\n**Phase 1: Foundation (Week 1)**\n1. Set up Stripe account (test & production)\n2. Database schema creation and migrations\n3. Install Stripe SDK and configure\n4. Create billing service boilerplate\n5. Set up error logging and monitoring\n\n**Phase 2: Core Subscription API (Week 2-3)**\n1. Implement subscription creation endpoint\n2. Implement subscription cancellation endpoint\n3. Implement plan upgrade/downgrade endpoint\n4. Add payment method management\n5. Unit tests for all endpoints\n\n**Phase 3: Webhook Processing (Week 3)**\n1. Set up webhook endpoint with signature verification\n2. Implement event handlers for critical events\n3. Add retry logic and dead letter queue\n4. Test webhook processing thoroughly\n\n**Phase 4: Frontend Integration (Week 4)**\n1. Build checkout UI with Stripe Elements\n2. Billing dashboard for customers\n3. Invoice history page\n4. Payment method management UI\n5. E2E tests for checkout flow\n\n**Phase 5: Testing & Launch (Week 5)**\n1. Security audit\n2. Load testing (1000 concurrent checkouts)\n3. Staging environment testing\n4. Beta launch to internal users\n5. Production launch with monitoring\n\n### Security Considerations\n\n- [ ] API keys stored in secure secrets manager (AWS Secrets Manager)\n- [ ] Webhook signature verification (prevent spoofing)\n- [ ] HTTPS only for all payment endpoints\n- [ ] PCI compliance via Stripe (no card data touches our servers)\n- [ ] Rate limiting on payment endpoints (10 req/min per user)\n- [ ] Audit logging for all payment operations\n- [ ] Input validation and sanitization\n- [ ] CSRF protection on payment forms\n- [ ] SQL injection prevention (parameterized queries)\n- [ ] Regular security scans and penetration testing\n\n### Error Handling Strategy\n\n**Payment Declined**:\n- Return specific error code to user\n- Suggest trying different payment method\n- Log for fraud analysis\n\n**Stripe API Errors**:\n- Transient errors (rate limit, timeout): Retry with exponential backoff\n- Client errors (invalid request): Return 400 to user\n- Server errors: Alert engineering team, return 500 to user\n\n**Webhook Processing Errors**:\n- Parse error: Log and alert (potential Stripe API change)\n- Processing error: Retry up to 3 times, then dead letter queue\n- Database error: Retry with backoff\n\n### Monitoring and Observability\n\n**Metrics**:\n- Subscription creation success rate\n- Payment failure rate by reason code\n- Webhook processing lag time\n- Subscription churn rate\n- Revenue metrics (MRR, ARR)\n\n**Alerts**:\n- Payment failure rate > 10% (immediate)\n- Webhook processing lag > 5 minutes (warning)\n- Subscription creation errors > 5% (immediate)\n- Stripe API error rate > 1% (warning)\n\n**Dashboards**:\n- Real-time payment processing metrics\n- Subscription funnel (checkout started → completed)\n- Revenue dashboard\n- Failed payment reasons\n\n## Deployment Strategy\n\n### Rollout Plan\n\n1. **Week 1-5: Development and Testing**\n   - All development in staging environment\n   - Use Stripe test mode\n   - Internal team testing\n\n2. **Week 6: Beta Release**\n   - Enable for internal users only (feature flag)\n   - Use Stripe production with test cards\n   - Monitor closely for issues\n\n3. **Week 7: Limited Release**\n   - Enable for 10% of new customers\n   - Existing customers remain on manual process\n   - Monitor conversion rates and errors\n\n4. **Week 8: Full Release**\n   - Enable for all new customers\n   - Migrate existing customers (with consent)\n   - Sunset manual invoice process\n\n### Rollback Procedure\n\n1. Disable feature flag (immediate effect)\n2. Redirect users to contact sales page\n3. Continue processing existing subscriptions\n4. Investigate and fix issues\n5. Communicate with affected customers\n\n## Testing Strategy\n\n### Unit Tests\n- Subscription creation logic\n- Payment method validation\n- Webhook event handlers\n- Proration calculations\n- Target: >90% coverage (financial code)\n\n### Integration Tests\n- Stripe API integration (using test mode)\n- Database operations\n- Webhook signature verification\n- Email sending\n\n### E2E Tests (Cypress)\n1. Complete checkout flow\n2. Plan upgrade flow\n3. Payment method update\n4. Subscription cancellation\n5. Failed payment handling\n\n### Manual Testing\n- Test with real Stripe test cards\n- Verify email formatting\n- Check invoice PDF generation\n- Test various error scenarios\n\n## Risks and Mitigations\n\n| Risk | Probability | Impact | Mitigation |\n|------|------------|--------|------------|\n| Stripe outage | Low | High | Cache subscription status, queue payments for retry |\n| Payment fraud | Medium | Medium | Use Stripe Radar for fraud detection |\n| Webhook delivery failure | Low | High | Implement polling as backup, monitor webhook lag |\n| Complex tax requirements | Medium | High | Use Stripe Tax add-on when needed |\n| PCI compliance issues | Low | Critical | Annual security audit, penetration testing |\n\n## Dependencies\n\n- **Stripe Account**: Production account approval (2-3 days)\n- **Design Team**: Checkout UI mockups\n- **Legal**: Terms of service update for billing\n- **Accounting**: Integration with accounting software (QuickBooks)\n\n## Timeline and Milestones\n\n| Milestone | Date | Owner |\n|-----------|------|-------|\n| Spec approved | 2024-01-20 | Alice |\n| Stripe account approved | 2024-01-25 | Finance |\n| Backend MVP complete | 2024-02-10 | Bob |\n| Frontend MVP complete | 2024-02-17 | Carol |\n| Testing complete | 2024-02-24 | Dan |\n| Beta launch | 2024-03-01 | Alice |\n| Full launch | 2024-03-15 | Alice |\n\n## Open Questions\n\n- [ ] Do we need to support ACH/bank transfers? (Owner: Product, Due: Jan 20)\n- [ ] What's the dunning email sequence for failed payments? (Owner: Marketing, Due: Jan 22)\n- [ ] How do we handle mid-cycle plan changes? (Owner: Finance, Due: Jan 25)\n- [ ] Should we offer discounts for annual billing? (Owner: Product, Due: Jan 25)\n```\n\n### Example 2: RFC for GraphQL Migration\n\n```markdown\n# RFC-003: Migrate from REST to GraphQL\n\n**Author**: David Kim\n**Status**: Discussing\n**Created**: 2024-01-15\n**Last Updated**: 2024-01-18\n\n## Summary\n\nThis RFC proposes migrating our client-facing API from REST to GraphQL over the next two quarters. This will reduce over-fetching, enable clients to request exactly the data they need, and improve mobile app performance.\n\n## Motivation\n\n### Why are we doing this?\n\nOur current REST API has several pain points:\n\n1. **Over-fetching**: Mobile clients download 3-5x more data than needed\n   - Example: `/users/:id` returns 40 fields, mobile only uses 8\n   - Wastes bandwidth, especially on slow connections\n   - Impacts battery life on mobile devices\n\n2. **Multiple Round Trips**: Complex views require 5-10 API calls\n   - Dashboard page: 7 different endpoints\n   - 2-3 second load time on 3G networks\n   - Poor user experience\n\n3. **API Versioning Complexity**: Supporting v1, v2, v3 simultaneously\n   - Maintenance burden\n   - Difficult to deprecate old versions\n   - Code duplication\n\n4. **Frontend Development Friction**: Waiting for backend to add endpoints\n   - Slows down feature development\n   - Requires coordination between teams\n\n### What use cases does it support?\n\n- **Mobile App Performance**: Reduce data transfer by 60-70%\n- **Flexible Data Fetching**: Clients request exactly what they need\n- **Real-time Updates**: GraphQL subscriptions for live data\n- **Rapid Prototyping**: Frontend can iterate without backend changes\n- **Better Developer Experience**: Type-safe queries, excellent tooling\n\n### What is the expected outcome?\n\n- 50% reduction in mobile data usage\n- 40% faster page load times\n- Sunset REST API v1 and v2 (remove technical debt)\n- Improved developer productivity\n- Foundation for real-time features\n\n## Detailed Design\n\n### Proposed Architecture\n\n```\n┌─────────────┐\n│   Clients   │\n│ (Web/Mobile)│\n└──────┬──────┘\n       │\n       │ GraphQL Queries\n       ▼\n┌──────────────────┐\n│  GraphQL Server  │\n│  (Apollo Server) │\n└────────┬─────────┘\n         │\n    ┌────┴────┐\n    │         │\n    ▼         ▼\n┌────────┐ ┌────────┐\n│ REST   │ │ gRPC   │\n│Services│ │Services│\n└────────┘ └────────┘\n```\n\n### Schema Design\n\n```graphql\ntype Query {\n  # User queries\n  user(id: ID!): User\n  users(filter: UserFilter, pagination: Pagination): UserConnection!\n  \n  # Post queries\n  post(id: ID!): Post\n  posts(filter: PostFilter, pagination: Pagination): PostConnection!\n}\n\ntype Mutation {\n  # User mutations\n  createUser(input: CreateUserInput!): CreateUserPayload!\n  updateUser(id: ID!, input: UpdateUserInput!): UpdateUserPayload!\n  \n  # Post mutations\n  createPost(input: CreatePostInput!): CreatePostPayload!\n  publishPost(id: ID!): PublishPostPayload!\n}\n\ntype Subscription {\n  # Real-time updates\n  postPublished: Post!\n  userStatusChanged(userId: ID!): UserStatus!\n}\n\ntype User {\n  id: ID!\n  email: String!\n  name: String!\n  avatar: String\n  posts(first: Int, after: String): PostConnection!\n  followers(first: Int): UserConnection!\n  createdAt: DateTime!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  comments: [Comment!]!\n  publishedAt: DateTime\n  status: PostStatus!\n}\n\nenum PostStatus {\n  DRAFT\n  PUBLISHED\n  ARCHIVED\n}\n\n# Relay-style pagination\ntype PostConnection {\n  edges: [PostEdge!]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype PostEdge {\n  node: Post!\n  cursor: String!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n```\n\n### API Changes\n\n#### Before (REST)\n\n```javascript\n// Fetching user with posts requires 2 requests\nconst user = await fetch('/api/v1/users/123');\nconst posts = await fetch('/api/v1/users/123/posts');\n\n// Response includes many unused fields\n// User response: ~5KB with 40 fields\n// Posts response: ~20KB with full post data\n```\n\n#### After (GraphQL)\n\n```javascript\n// Single request, exact data needed\nconst { data } = await client.query({\n  query: gql`\n    query GetUserWithPosts($userId: ID!) {\n      user(id: $userId) {\n        id\n        name\n        avatar\n        posts(first: 10) {\n          edges {\n            node {\n              id\n              title\n              publishedAt\n            }\n          }\n        }\n      }\n    }\n  `,\n  variables: { userId: '123' }\n});\n\n// Response: ~2KB with only requested fields\n```\n\n### Migration Path\n\n**Phase 1: Foundation (Q1 Week 1-4)**\n1. Set up Apollo Server\n2. Define initial GraphQL schema\n3. Implement authentication/authorization\n4. Set up monitoring and logging\n\n**Phase 2: Parallel Development (Q1 Week 5 - Q2 Week 8)**\n1. Implement GraphQL resolvers (wrapping existing REST services)\n2. GraphQL and REST coexist\n3. New features use GraphQL\n4. Gradually migrate existing features\n\n**Phase 3: Client Migration (Q2 Week 9-12)**\n1. Migrate web app to GraphQL (one page at a time)\n2. Migrate mobile app to GraphQL\n3. Monitor performance improvements\n\n**Phase 4: Sunset REST (Q3)**\n1. Deprecate REST v1 and v2\n2. Remove unused endpoints\n3. Keep minimal REST v3 for legacy integrations\n\n**Backward Compatibility**: Yes, during migration phase (6 months)\n\n**Breaking Changes**: None initially, GraphQL is additive. REST will be deprecated gradually.\n\n### Code Examples\n\n```typescript\n// Resolver example\nconst resolvers = {\n  Query: {\n    user: async (_, { id }, context) => {\n      // Authorization check\n      if (!context.user) {\n        throw new AuthenticationError('Must be logged in');\n      }\n      \n      // Fetch from existing service\n      return context.dataSources.userService.getUserById(id);\n    },\n    \n    posts: async (_, { filter, pagination }, context) => {\n      const posts = await context.dataSources.postService.getPosts({\n        filter,\n        ...pagination\n      });\n      \n      return {\n        edges: posts.map(post => ({\n          node: post,\n          cursor: Buffer.from(post.id).toString('base64')\n        })),\n        pageInfo: {\n          hasNextPage: posts.length === pagination.first,\n          hasPreviousPage: !!pagination.after,\n        },\n        totalCount: await context.dataSources.postService.getTotalCount(filter)\n      };\n    }\n  },\n  \n  User: {\n    // N+1 query prevention with DataLoader\n    posts: async (user, { first, after }, context) => {\n      return context.loaders.userPostsLoader.load({\n        userId: user.id,\n        first,\n        after\n      });\n    }\n  },\n  \n  Mutation: {\n    createPost: async (_, { input }, context) => {\n      // Validation\n      if (!input.title || input.title.length < 3) {\n        throw new UserInputError('Title must be at least 3 characters');\n      }\n      \n      // Create post\n      const post = await context.dataSources.postService.createPost({\n        ...input,\n        authorId: context.user.id\n      });\n      \n      // Publish subscription event\n      context.pubsub.publish('POST_PUBLISHED', { postPublished: post });\n      \n      return {\n        post,\n        userErrors: []\n      };\n    }\n  },\n  \n  Subscription: {\n    postPublished: {\n      subscribe: (_, __, context) => {\n        return context.pubsub.asyncIterator(['POST_PUBLISHED']);\n      }\n    }\n  }\n};\n```\n\n### Performance Optimizations\n\n1. **DataLoader**: Batch and cache database queries\n2. **Query Complexity Analysis**: Prevent expensive queries\n3. **Persisted Queries**: Reduce payload size\n4. **Response Caching**: Cache at field level\n5. **Pagination**: Cursor-based for efficiency\n\n## Drawbacks\n\n- **Learning Curve**: Team needs to learn GraphQL concepts\n- **Complexity**: More complex than simple REST endpoints\n- **Caching**: HTTP caching doesn't work (all POST requests)\n- **File Uploads**: More complex than multipart REST\n- **Versioning**: Different approach than REST versioning\n- **Over-fetching Still Possible**: If clients don't optimize queries\n\n## Alternatives\n\n### Alternative 1: Optimize REST API\n\n**Approach**: \n- Add field filtering (`?fields=id,name,email`)\n- Implement JSON:API spec\n- Better endpoint design\n\n**Pros**:\n- Less learning curve\n- Keep existing infrastructure\n- Simpler caching\n\n**Cons**:\n- Doesn't solve N+1 request problem\n- Still requires multiple endpoints\n- Continued versioning complexity\n\n**Why not chosen**: Doesn't address core issues (multiple round trips, versioning)\n\n### Alternative 2: gRPC\n\n**Approach**:\n- Use gRPC for efficient binary protocol\n- Protocol Buffers for schema\n\n**Pros**:\n- Very efficient (binary)\n- Strong typing\n- Good for microservices\n\n**Cons**:\n- Not web-friendly (requires grpc-web proxy)\n- Less tooling for frontend developers\n- Doesn't solve flexible querying problem\n\n**Why not chosen**: Not ideal for web/mobile clients, lacks GraphQL's flexibility\n\n## Prior Art\n\n- **GitHub**: Migrated to GraphQL, reported 50% reduction in API calls\n- **Shopify**: GraphQL for Storefront API, improved mobile performance\n- **Twitter**: Uses GraphQL internally, faster feature development\n- **Airbnb**: GraphQL reduced over-fetching, improved mobile UX\n\n## Unresolved Questions\n\n- [ ] How do we handle file uploads in GraphQL? (Researching multipart spec)\n- [ ] What's the strategy for schema versioning? (Schema stitching vs federation?)\n- [ ] Do we need GraphQL subscriptions immediately or later? (Nice-to-have)\n- [ ] How to handle legacy clients that can't upgrade? (Keep minimal REST v3)\n\n## Future Possibilities\n\n- **GraphQL Federation**: Split schema across microservices\n- **Real-time Features**: Use subscriptions for chat, notifications\n- **Unified Gateway**: Single GraphQL endpoint for all services\n- **Schema Registry**: Version and manage schema changes\n\n## Implementation Timeline\n\n- **Week 1-2**: Set up Apollo Server, initial schema\n- **Week 3-4**: Authentication, authorization, monitoring\n- **Week 5-8**: Implement resolvers for core resources\n- **Week 9-12**: Client migration (web app)\n- **Week 13-16**: Client migration (mobile app)\n- **Week 17-20**: Optimize, fix issues, documentation\n- **Q3**: Gradual REST deprecation\n\n## Stakeholders\n\n- **Author**: David Kim (Backend Lead)\n- **Reviewers**: \n  - Emma (Frontend Lead)\n  - Frank (Mobile Lead)\n  - Grace (DevOps)\n- **Decision Makers**: \n  - CTO\n  - VP Engineering\n- **Implementers**: \n  - Backend team\n  - Frontend team\n  - Mobile team\n\n## Comments and Discussion\n\n**Emma (Frontend Lead)** - 2024-01-16:\n> This looks great! I'm excited about the flexibility. One concern: how do we prevent juniors from writing expensive queries that fetch too much data?\n\n**David** - 2024-01-16:\n> Good point. We'll implement query complexity analysis that rejects queries above a threshold. Also planning to provide query templates/fragments for common use cases.\n\n**Frank (Mobile Lead)** - 2024-01-17:\n> What about offline support? Our app uses REST response caching extensively.\n\n**David** - 2024-01-17:\n> Apollo Client has sophisticated caching (normalized cache). It's actually better than what we have now. We can also use persisted queries for offline scenarios. Let's discuss in detail.\n\n**Grace (DevOps)** - 2024-01-18:\n> How does this affect our monitoring and alerting? REST endpoints are easy to monitor.\n\n**David** - 2024-01-18:\n> We'll use Apollo Studio for query monitoring. Can track slow queries, errors, field usage. Also planning to add custom metrics for critical operations.\n```\n\n### Example 3: ADR for Database Choice\n\n```markdown\n# ADR-007: Use PostgreSQL for Main Application Database\n\n**Date**: 2024-01-15\n**Status**: Accepted\n**Deciders**: Alice (CTO), Bob (Backend Lead), Carol (DevOps)\n**Technical Story**: EPIC-123 - Database Migration\n\n## Context and Problem Statement\n\nWe're building a new SaaS platform for project management. We need to choose a primary database that will:\n- Store user data, projects, tasks, comments\n- Support complex queries (filtering, sorting, aggregations)\n- Handle concurrent writes from multiple users\n- Scale to 100k users in first year\n- Ensure data consistency and integrity\n- Support full-text search\n\nWhich database should we use as our primary data store?\n\n## Decision Drivers\n\n- **Data Integrity**: Financial data (billing) requires ACID compliance\n- **Query Complexity**: Need complex joins, aggregations, and filtering\n- **Developer Experience**: Team familiar with SQL, strong typing desired\n- **Scalability**: Must handle 100k users, 10M records\n- **Cost**: Must fit within $500/month infrastructure budget initially\n- **Ecosystem**: Rich ecosystem of tools, ORMs, and libraries\n- **Search**: Need full-text search capabilities\n- **JSON Support**: Some fields have variable schema (custom fields)\n\n## Considered Options\n\n- **Option 1**: PostgreSQL\n- **Option 2**: MySQL\n- **Option 3**: MongoDB\n- **Option 4**: DynamoDB (AWS)\n\n## Decision Outcome\n\nChosen option: \"PostgreSQL\", because it provides the best balance of:\n- ACID compliance for financial data\n- Rich query capabilities (joins, CTEs, window functions)\n- JSON support for flexible schemas\n- Full-text search built-in\n- Excellent performance for our scale\n- Team familiarity and strong ecosystem\n- Cost-effective (can start on $50/mo RDS instance)\n\n### Positive Consequences\n\n- **Data Integrity**: ACID guarantees prevent data inconsistencies\n- **Developer Productivity**: Team already knows PostgreSQL\n- **Powerful Queries**: Can handle complex reporting without ETL\n- **Future-Proof**: Scales to millions of records vertically\n- **JSON Support**: Flexible schema where needed\n- **Full-Text Search**: Built-in, no separate search service initially\n- **Tooling**: Excellent tools (pgAdmin, Postico, migrations)\n\n### Negative Consequences\n\n- **Horizontal Scaling**: More complex than NoSQL for sharding\n- **Schema Migrations**: Require planning and coordination\n- **Learning Curve**: Advanced features (CTEs, window functions) require expertise\n- **Write Performance**: Slightly slower than some NoSQL for pure write workloads\n\n## Pros and Cons of the Options\n\n### Option 1: PostgreSQL\n\n**Description**: Open-source relational database with advanced features\n\n**Pros**:\n- ✅ Full ACID compliance\n- ✅ Excellent for complex queries (joins, aggregations)\n- ✅ JSON/JSONB support for flexible schemas\n- ✅ Full-text search built-in\n- ✅ Rich extension ecosystem (PostGIS, pg_cron, etc.)\n- ✅ Strong typing and data validation\n- ✅ Excellent documentation and community\n- ✅ Team already experienced with it\n- ✅ Cost-effective (RDS, Render, etc.)\n\n**Cons**:\n- ❌ Vertical scaling primarily (harder to shard than NoSQL)\n- ❌ Schema migrations require careful planning\n- ❌ Slightly more complex for simple key-value operations\n\n### Option 2: MySQL\n\n**Description**: Popular open-source relational database\n\n**Pros**:\n- ✅ ACID compliance\n- ✅ Wide adoption and hosting options\n- ✅ Good performance\n- ✅ Team familiarity\n- ✅ JSON support (as of 5.7+)\n\n**Cons**:\n- ❌ Less advanced features than PostgreSQL (no CTEs until 8.0)\n- ❌ Full-text search less powerful\n- ❌ Less consistent handling of edge cases\n- ❌ Some features require expensive commercial licenses\n\n**Why not chosen**: PostgreSQL has better advanced features we'll need (window functions, CTEs, better JSON support)\n\n### Option 3: MongoDB\n\n**Description**: Document-oriented NoSQL database\n\n**Pros**:\n- ✅ Flexible schema (easy to iterate)\n- ✅ Horizontal scaling (sharding)\n- ✅ Good for rapid prototyping\n- ✅ JSON-native\n\n**Cons**:\n- ❌ Weaker consistency guarantees (eventual consistency by default)\n- ❌ No joins (requires application-level logic)\n- ❌ Less ideal for complex queries and aggregations\n- ❌ Less suitable for financial/billing data\n- ❌ Team less experienced with it\n- ❌ Can lead to data duplication\n\n**Why not chosen**: Need ACID compliance for billing data, complex queries common in our domain\n\n### Option 4: DynamoDB\n\n**Description**: AWS managed NoSQL database\n\n**Pros**:\n- ✅ Fully managed, no operations\n- ✅ Excellent horizontal scaling\n- ✅ Predictable performance\n- ✅ Pay-per-request pricing option\n\n**Cons**:\n- ❌ AWS vendor lock-in\n- ❌ Limited query capabilities (no joins, complex filters)\n- ❌ Requires careful data modeling upfront\n- ❌ No full-text search built-in\n- ❌ Team has no experience\n- ❌ Can get expensive at scale\n\n**Why not chosen**: Query limitations, vendor lock-in, team inexperience\n\n## Links\n\n- [PostgreSQL vs MySQL comparison analysis](internal-link)\n- [Database performance benchmarks](internal-link)\n- [Team survey on database preferences](internal-link)\n- [Estimated database costs spreadsheet](internal-link)\n```\n\n## Best Practices\n\n1. **Start with Why**\n   - Clearly articulate the problem\n   - Define success criteria upfront\n   - Identify stakeholders early\n\n2. **Be Specific and Detailed**\n   - Include code examples\n   - Provide actual API contracts\n   - Add diagrams for clarity\n\n3. **Consider Alternatives**\n   - Document other approaches considered\n   - Explain why they were rejected\n   - Show trade-off analysis\n\n4. **Plan for Failure**\n   - Identify risks and mitigations\n   - Define rollback procedures\n   - Plan for edge cases\n\n5. **Make it Actionable**\n   - Clear implementation plan\n   - Defined timeline and milestones\n   - Assigned owners\n\n6. **Keep it Updated**\n   - Update status as work progresses\n   - Document decisions made during implementation\n   - Add lessons learned\n\n7. **Get Feedback Early**\n   - Share draft with team\n   - Incorporate feedback\n   - Get buy-in from stakeholders\n\n## Common Pitfalls\n\n- **Too Vague**: \"We'll build a payment system\" without details\n- **Too Detailed**: 100-page spec that nobody reads\n- **Ignoring Alternatives**: Only showing the chosen solution\n- **No Diagrams**: Text-only specs are hard to understand\n- **Missing Security**: Forgetting security considerations\n- **No Testing Plan**: Not defining how to validate it works\n- **Unrealistic Timeline**: Not accounting for complexity\n- **Missing Dependencies**: Forgetting external team dependencies\n\n## Document Lifecycle\n\n1. **Draft**: Initial version, gathering feedback\n2. **Review**: Team review and discussion\n3. **Approved**: Stakeholders sign off\n4. **Implementation**: Being built\n5. **Completed**: Shipped to production\n6. **Deprecated**: No longer relevant (link to replacement)\n",
  "prompt": "A skill that guides creation of professional technical specifications, design documents, RFCs (Request for Comments), and ADRs (Architectural Decision Records). Includes templates for comprehensive tech specs with API contracts, sequence diagrams, database schemas, security considerations, deployment strategies, and testing plans. Provides detailed examples for payment processing integration, GraphQL migration RFC, and database selection ADR with trade-off analysis and stakeholder discussion.",
  "createdAt": "2024-01-15T10:00:00.000Z",
  "published": true
}